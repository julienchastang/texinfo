This is python.info, produced by makeinfo version 6.0 from python.texi.

     Python 3.6.0a0, May 06, 2016

     Georg Brandl

     Copyright © 2001-2016, Python Software Foundation

INFO-DIR-SECTION Documentation tools
START-INFO-DIR-ENTRY
* Python: (python.info). The Python Programming Language
END-INFO-DIR-ENTRY


   Generated by Sphinx 1.4.1.


File: python.info,  Node: Future statements,  Up: The import statement

4.7.11.1 Future statements
..........................

A `future statement' is a directive to the compiler that a particular
module should be compiled using syntax or semantics that will be
available in a specified future release of Python where the feature
becomes standard.

The future statement is intended to ease migration to future versions of
Python that introduce incompatible changes to the language.  It allows
use of the new features on a per-module basis before the release in
which the feature becomes standard.

     future_statement ::= "from" "__future__" "import" feature ["as" name]
                          ("," feature ["as" name])*
                          | "from" "__future__" "import" "(" feature ["as" name]
                          ("," feature ["as" name])* [","] ")"
     feature          ::= identifier
     name             ::= identifier

A future statement must appear near the top of the module.  The only
lines that can appear before a future statement are:

   * the module docstring (if any),

   * comments,

   * blank lines, and

   * other future statements.

The features recognized by Python 3.0 are ‘absolute_import’, ‘division’,
‘generators’, ‘unicode_literals’, ‘print_function’, ‘nested_scopes’ and
‘with_statement’.  They are all redundant because they are always
enabled, and only kept for backwards compatibility.

A future statement is recognized and treated specially at compile time:
Changes to the semantics of core constructs are often implemented by
generating different code.  It may even be the case that a new feature
introduces new incompatible syntax (such as a new reserved word), in
which case the compiler may need to parse the module differently.  Such
decisions cannot be pushed off until runtime.

For any given release, the compiler knows which feature names have been
defined, and raises a compile-time error if a future statement contains
a feature not known to it.

The direct runtime semantics are the same as for any import statement:
there is a standard module *note __future__: 0, described later, and it
will be imported in the usual way at the time the future statement is
executed.

The interesting runtime semantics depend on the specific feature enabled
by the future statement.

Note that there is nothing special about the statement:

     import __future__ [as name]

That is not a future statement; it’s an ordinary import statement with
no special semantics or syntax restrictions.

Code compiled by calls to the built-in functions *note exec(): 8ac. and
*note compile(): 903. that occur in a module ‘M’ containing a future
statement will, by default, use the new syntax or semantics associated
with the future statement.  This can be controlled by optional arguments
to *note compile(): 903. — see the documentation of that function for
details.

A future statement typed at an interactive interpreter prompt will take
effect for the rest of the interpreter session.  If an interpreter is
started with the *note -i: aa1. option, is passed a script name to
execute, and the script includes a future statement, it will be in
effect in the interactive session started after the script is executed.

See also
........

PEP 236(1) - Back to the __future__

     The original proposal for the __future__ mechanism.

   ---------- Footnotes ----------

   (1) https://www.python.org/dev/peps/pep-0236


File: python.info,  Node: The global statement,  Next: The nonlocal statement,  Prev: The import statement,  Up: Simple statements

4.7.12 The ‘global’ statement
-----------------------------

     global_stmt ::= "global" identifier ("," identifier)*

The *note global: c0b. statement is a declaration which holds for the
entire current code block.  It means that the listed identifiers are to
be interpreted as globals.  It would be impossible to assign to a global
variable without *note global: c0b, although free variables may refer to
globals without being declared global.

Names listed in a *note global: c0b. statement must not be used in the
same code block textually preceding that *note global: c0b. statement.

Names listed in a *note global: c0b. statement must not be defined as
formal parameters or in a *note for: 895. loop control target, *note
class: 8d6. definition, function definition, or *note import: 881.
statement.

`CPython implementation detail:' The current implementation does not
enforce the two restrictions, but programs should not abuse this
freedom, as future implementations may enforce them or silently change
the meaning of the program.

`Programmer’s note:' the *note global: c0b. is a directive to the
parser.  It applies only to code parsed at the same time as the *note
global: c0b. statement.  In particular, a *note global: c0b. statement
contained in a string or code object supplied to the built-in *note
exec(): 8ac. function does not affect the code block `containing' the
function call, and code contained in such a string is unaffected by
*note global: c0b. statements in the code containing the function call.
The same applies to the *note eval(): 7e8. and *note compile(): 903.
functions.


File: python.info,  Node: The nonlocal statement,  Prev: The global statement,  Up: Simple statements

4.7.13 The ‘nonlocal’ statement
-------------------------------

     nonlocal_stmt ::= "nonlocal" identifier ("," identifier)*

The *note nonlocal: 8a6. statement causes the listed identifiers to
refer to previously bound variables in the nearest enclosing scope
excluding globals.  This is important because the default behavior for
binding is to search the local namespace first.  The statement allows
encapsulated code to rebind variables outside of the local scope besides
the global (module) scope.

Names listed in a *note nonlocal: 8a6. statement, unlike those listed in
a *note global: c0b. statement, must refer to pre-existing bindings in
an enclosing scope (the scope in which a new binding should be created
cannot be determined unambiguously).

Names listed in a *note nonlocal: 8a6. statement must not collide with
pre-existing bindings in the local scope.

See also
........

PEP 3104(1) - Access to Names in Outer Scopes

     The specification for the *note nonlocal: 8a6. statement.

   ---------- Footnotes ----------

   (1) https://www.python.org/dev/peps/pep-3104


File: python.info,  Node: Compound statements,  Next: Top-level components,  Prev: Simple statements,  Up: The Python Language Reference

4.8 Compound statements
=======================

Compound statements contain (groups of) other statements; they affect or
control the execution of those other statements in some way.  In
general, compound statements span multiple lines, although in simple
incarnations a whole compound statement may be contained in one line.

The *note if: a65, *note while: bf3. and *note for: 895. statements
implement traditional control flow constructs.  *note try: 9e9.
specifies exception handlers and/or cleanup code for a group of
statements, while the *note with: 29d. statement allows the execution of
initialization and finalization code around a block of code.  Function
and class definitions are also syntactically compound statements.

A compound statement consists of one or more ’clauses.’ A clause
consists of a header and a ’suite.’ The clause headers of a particular
compound statement are all at the same indentation level.  Each clause
header begins with a uniquely identifying keyword and ends with a colon.
A suite is a group of statements controlled by a clause.  A suite can be
one or more semicolon-separated simple statements on the same line as
the header, following the header’s colon, or it can be one or more
indented statements on subsequent lines.  Only the latter form of a
suite can contain nested compound statements; the following is illegal,
mostly because it wouldn’t be clear to which *note if: a65. clause a
following *note else: bfa. clause would belong:

     if test1: if test2: print(x)

Also note that the semicolon binds tighter than the colon in this
context, so that in the following example, either all or none of the
*note print(): 481. calls are executed:

     if x < y < z: print(x); print(y); print(z)

Summarizing:

     compound_stmt ::= if_stmt
                       | while_stmt
                       | for_stmt
                       | try_stmt
                       | with_stmt
                       | funcdef
                       | classdef
                       | async_with_stmt
                       | async_for_stmt
                       | async_funcdef
     suite         ::= stmt_list NEWLINE | NEWLINE INDENT statement+ DEDENT
     statement     ::= stmt_list NEWLINE | compound_stmt
     stmt_list     ::= simple_stmt (";" simple_stmt)* [";"]

Note that statements always end in a ‘NEWLINE’ possibly followed by a
‘DEDENT’.  Also note that optional continuation clauses always begin
with a keyword that cannot start a statement, thus there are no
ambiguities (the ’dangling *note else: bfa.’ problem is solved in Python
by requiring nested *note if: a65. statements to be indented).

The formatting of the grammar rules in the following sections places
each clause on a separate line for clarity.
* Menu:

* The if statement:: 
* The while statement:: 
* The for statement:: 
* The try statement:: 
* The with statement:: 
* Function definitions:: 
* Class definitions:: 
* Coroutines: Coroutines<2>. 


File: python.info,  Node: The if statement,  Next: The while statement,  Up: Compound statements

4.8.1 The ‘if’ statement
------------------------

The *note if: a65. statement is used for conditional execution:

     if_stmt ::= "if" expression ":" suite
                 ( "elif" expression ":" suite )*
                 ["else" ":" suite]

It selects exactly one of the suites by evaluating the expressions one
by one until one is found to be true (see section *note Boolean
operations: f05. for the definition of true and false); then that suite
is executed (and no other part of the *note if: a65. statement is
executed or evaluated).  If all expressions are false, the suite of the
*note else: bfa. clause, if present, is executed.


File: python.info,  Node: The while statement,  Next: The for statement,  Prev: The if statement,  Up: Compound statements

4.8.2 The ‘while’ statement
---------------------------

The *note while: bf3. statement is used for repeated execution as long
as an expression is true:

     while_stmt ::= "while" expression ":" suite
                    ["else" ":" suite]

This repeatedly tests the expression and, if it is true, executes the
first suite; if the expression is false (which may be the first time it
is tested) the suite of the *note else: bfa. clause, if present, is
executed and the loop terminates.

A *note break: c02. statement executed in the first suite terminates the
loop without executing the *note else: bfa. clause’s suite.  A *note
continue: c04. statement executed in the first suite skips the rest of
the suite and goes back to testing the expression.


File: python.info,  Node: The for statement,  Next: The try statement,  Prev: The while statement,  Up: Compound statements

4.8.3 The ‘for’ statement
-------------------------

The *note for: 895. statement is used to iterate over the elements of a
sequence (such as a string, tuple or list) or other iterable object:

     for_stmt ::= "for" target_list "in" expression_list ":" suite
                  ["else" ":" suite]

The expression list is evaluated once; it should yield an iterable
object.  An iterator is created for the result of the ‘expression_list’.
The suite is then executed once for each item provided by the iterator,
in the order returned by the iterator.  Each item in turn is assigned to
the target list using the standard rules for assignments (see *note
Assignment statements: f23.), and then the suite is executed.  When the
items are exhausted (which is immediately when the sequence is empty or
an iterator raises a *note StopIteration: 191. exception), the suite in
the *note else: bfa. clause, if present, is executed, and the loop
terminates.

A *note break: c02. statement executed in the first suite terminates the
loop without executing the *note else: bfa. clause’s suite.  A *note
continue: c04. statement executed in the first suite skips the rest of
the suite and continues with the next item, or with the *note else: bfa.
clause if there is no next item.

The for-loop makes assignments to the variables(s) in the target list.
This overwrites all previous assignments to those variables including
those made in the suite of the for-loop:

     for i in range(10):
         print(i)
         i = 5             # this will not affect the for-loop
                           # because i will be overwritten with the next
                           # index in the range

Names in the target list are not deleted when the loop is finished, but
if the sequence is empty, they will not have been assigned to at all by
the loop.  Hint: the built-in function *note range(): 5e0. returns an
iterator of integers suitable to emulate the effect of Pascal’s ‘for i
:= a to b do’; e.g., ‘list(range(3))’ returns the list ‘[0, 1, 2]’.

     Note: 
     There is a subtlety when the sequence is being modified by the loop
     (this can only occur for mutable sequences, i.e.  lists).  An
     internal counter is used to keep track of which item is used next,
     and this is incremented on each iteration.  When this counter has
     reached the length of the sequence the loop terminates.  This means
     that if the suite deletes the current (or a previous) item from the
     sequence, the next item will be skipped (since it gets the index of
     the current item which has already been treated).  Likewise, if the
     suite inserts an item in the sequence before the current item, the
     current item will be treated again the next time through the loop.
     This can lead to nasty bugs that can be avoided by making a
     temporary copy using a slice of the whole sequence, e.g.,

          for x in a[:]:
              if x < 0: a.remove(x)


File: python.info,  Node: The try statement,  Next: The with statement,  Prev: The for statement,  Up: Compound statements

4.8.4 The ‘try’ statement
-------------------------

The *note try: 9e9. statement specifies exception handlers and/or
cleanup code for a group of statements:

     try_stmt  ::= try1_stmt | try2_stmt
     try1_stmt ::= "try" ":" suite
                   ("except" [expression ["as" identifier]] ":" suite)+
                   ["else" ":" suite]
                   ["finally" ":" suite]
     try2_stmt ::= "try" ":" suite
                   "finally" ":" suite

The *note except: 785. clause(s) specify one or more exception handlers.
When no exception occurs in the *note try: 9e9. clause, no exception
handler is executed.  When an exception occurs in the *note try: 9e9.
suite, a search for an exception handler is started.  This search
inspects the except clauses in turn until one is found that matches the
exception.  An expression-less except clause, if present, must be last;
it matches any exception.  For an except clause with an expression, that
expression is evaluated, and the clause matches the exception if the
resulting object is "compatible" with the exception.  An object is
compatible with an exception if it is the class or a base class of the
exception object or a tuple containing an item compatible with the
exception.

If no except clause matches the exception, the search for an exception
handler continues in the surrounding code and on the invocation stack.
(1)

If the evaluation of an expression in the header of an except clause
raises an exception, the original search for a handler is canceled and a
search starts for the new exception in the surrounding code and on the
call stack (it is treated as if the entire *note try: 9e9. statement
raised the exception).

When a matching except clause is found, the exception is assigned to the
target specified after the *note as: 8aa. keyword in that except clause,
if present, and the except clause’s suite is executed.  All except
clauses must have an executable block.  When the end of this block is
reached, execution continues normally after the entire try statement.
(This means that if two nested handlers exist for the same exception,
and the exception occurs in the try clause of the inner handler, the
outer handler will not handle the exception.)

When an exception has been assigned using ‘as target’, it is cleared at
the end of the except clause.  This is as if

     except E as N:
         foo

was translated to

     except E as N:
         try:
             foo
         finally:
             del N

This means the exception must be assigned to a different name to be able
to refer to it after the except clause.  Exceptions are cleared because
with the traceback attached to them, they form a reference cycle with
the stack frame, keeping all locals in that frame alive until the next
garbage collection occurs.

Before an except clause’s suite is executed, details about the exception
are stored in the *note sys: fb. module and can be accessed via *note
sys.exc_info(): 8ca.  *note sys.exc_info(): 8ca. returns a 3-tuple
consisting of the exception class, the exception instance and a
traceback object (see section *note The standard type hierarchy: de0.)
identifying the point in the program where the exception occurred.
*note sys.exc_info(): 8ca. values are restored to their previous values
(before the call) when returning from a function that handled an
exception.

The optional *note else: bfa. clause is executed if and when control
flows off the end of the *note try: 9e9. clause.  (2) Exceptions in the
*note else: bfa. clause are not handled by the preceding *note except:
785. clauses.

If *note finally: 526. is present, it specifies a ’cleanup’ handler.
The *note try: 9e9. clause is executed, including any *note except: 785.
and *note else: bfa. clauses.  If an exception occurs in any of the
clauses and is not handled, the exception is temporarily saved.  The
*note finally: 526. clause is executed.  If there is a saved exception
it is re-raised at the end of the *note finally: 526. clause.  If the
*note finally: 526. clause raises another exception, the saved exception
is set as the context of the new exception.  If the *note finally: 526.
clause executes a *note return: 981. or *note break: c02. statement, the
saved exception is discarded:

     >>> def f():
     ...     try:
     ...         1/0
     ...     finally:
     ...         return 42
     ...
     >>> f()
     42

The exception information is not available to the program during
execution of the *note finally: 526. clause.

When a *note return: 981, *note break: c02. or *note continue: c04.
statement is executed in the *note try: 9e9. suite of a *note try:
9e9...*note finally: 526. statement, the *note finally: 526. clause is
also executed ’on the way out.’ A *note continue: c04. statement is
illegal in the *note finally: 526. clause.  (The reason is a problem
with the current implementation — this restriction may be lifted in the
future).

The return value of a function is determined by the last *note return:
981. statement executed.  Since the *note finally: 526. clause always
executes, a *note return: 981. statement executed in the *note finally:
526. clause will always be the last one executed:

     >>> def foo():
     ...     try:
     ...         return 'try'
     ...     finally:
     ...         return 'finally'
     ...
     >>> foo()
     'finally'

Additional information on exceptions can be found in section *note
Exceptions: e6f, and information on using the *note raise: 8a9.
statement to generate exceptions may be found in section *note The raise
statement: 8a9.

   ---------- Footnotes ----------

   (1) The exception is propagated to the invocation stack unless there
is a *note finally: 526. clause which happens to raise another
exception.  That new exception causes the old one to be lost.

   (2) Currently, control "flows off the end" except in the case of an
exception or the execution of a *note return: 981, *note continue: c04,
or *note break: c02. statement.


File: python.info,  Node: The with statement,  Next: Function definitions,  Prev: The try statement,  Up: Compound statements

4.8.5 The ‘with’ statement
--------------------------

The *note with: 29d. statement is used to wrap the execution of a block
with methods defined by a context manager (see section *note With
Statement Context Managers: e48.).  This allows common *note try:
9e9...*note except: 785...*note finally: 526. usage patterns to be
encapsulated for convenient reuse.

     with_stmt ::= "with" with_item ("," with_item)* ":" suite
     with_item ::= expression ["as" target]

The execution of the *note with: 29d. statement with one "item" proceeds
as follows:

  1. The context expression (the expression given in the *note
     with_item: f60.) is evaluated to obtain a context manager.

  2. The context manager’s *note __exit__(): 908. is loaded for later
     use.

  3. The context manager’s *note __enter__(): 907. method is invoked.

  4. If a target was included in the *note with: 29d. statement, the
     return value from *note __enter__(): 907. is assigned to it.

          Note: The *note with: 29d. statement guarantees that if the
          *note __enter__(): 907. method returns without an error, then
          *note __exit__(): 908. will always be called.  Thus, if an
          error occurs during the assignment to the target list, it will
          be treated the same as an error occurring within the suite
          would be.  See step 6 below.

  5. The suite is executed.

  6. The context manager’s *note __exit__(): 908. method is invoked.  If
     an exception caused the suite to be exited, its type, value, and
     traceback are passed as arguments to *note __exit__(): 908.
     Otherwise, three *note None: 19d. arguments are supplied.

     If the suite was exited due to an exception, and the return value
     from the *note __exit__(): 908. method was false, the exception is
     reraised.  If the return value was true, the exception is
     suppressed, and execution continues with the statement following
     the *note with: 29d. statement.

     If the suite was exited for any reason other than an exception, the
     return value from *note __exit__(): 908. is ignored, and execution
     proceeds at the normal location for the kind of exit that was
     taken.

With more than one item, the context managers are processed as if
multiple *note with: 29d. statements were nested:

     with A() as a, B() as b:
         suite

is equivalent to

     with A() as a:
         with B() as b:
             suite

Changed in version 3.1: Support for multiple context expressions.

See also
........

PEP 343(1) - The "with" statement

     The specification, background, and examples for the Python *note
     with: 29d. statement.

   ---------- Footnotes ----------

   (1) https://www.python.org/dev/peps/pep-0343


File: python.info,  Node: Function definitions,  Next: Class definitions,  Prev: The with statement,  Up: Compound statements

4.8.6 Function definitions
--------------------------

A function definition defines a user-defined function object (see
section *note The standard type hierarchy: de0.):

     funcdef                 ::= [decorators] "def" funcname "(" [parameter_list] ")" ["->" expression] ":" suite
     decorators              ::= decorator+
     decorator               ::= "@" dotted_name ["(" [parameter_list [","]] ")"] NEWLINE
     dotted_name             ::= identifier ("." identifier)*
     parameter_list          ::= defparameter ("," defparameter)* ["," [parameter_list_starargs]]
                                 | parameter_list_starargs
     parameter_list_starargs ::= "*" [parameter] ("," defparameter)* ["," ["**" parameter [","]]]
                                 | "**" parameter [","]
     parameter               ::= identifier [":" expression]
     defparameter            ::= parameter ["=" expression]
     funcname                ::= identifier

A function definition is an executable statement.  Its execution binds
the function name in the current local namespace to a function object (a
wrapper around the executable code for the function).  This function
object contains a reference to the current global namespace as the
global namespace to be used when the function is called.

The function definition does not execute the function body; this gets
executed only when the function is called.  (1)

A function definition may be wrapped by one or more *note decorator:
f6c. expressions.  Decorator expressions are evaluated when the function
is defined, in the scope that contains the function definition.  The
result must be a callable, which is invoked with the function object as
the only argument.  The returned value is bound to the function name
instead of the function object.  Multiple decorators are applied in
nested fashion.  For example, the following code

     @f1(arg)
     @f2
     def func(): pass

is equivalent to

     def func(): pass
     func = f1(arg)(f2(func))

When one or more *note parameters: ee6. have the form `parameter' ‘=’
`expression', the function is said to have "default parameter values."
For a parameter with a default value, the corresponding *note argument:
ee0. may be omitted from a call, in which case the parameter’s default
value is substituted.  If a parameter has a default value, all following
parameters up until the "‘*’" must also have a default value — this is a
syntactic restriction that is not expressed by the grammar.

`Default parameter values are evaluated from left to right when the
function definition is executed.'  This means that the expression is
evaluated once, when the function is defined, and that the same
"pre-computed" value is used for each call.  This is especially
important to understand when a default parameter is a mutable object,
such as a list or a dictionary: if the function modifies the object
(e.g.  by appending an item to a list), the default value is in effect
modified.  This is generally not what was intended.  A way around this
is to use ‘None’ as the default, and explicitly test for it in the body
of the function, e.g.:

     def whats_on_the_telly(penguin=None):
         if penguin is None:
             penguin = []
         penguin.append("property of the zoo")
         return penguin

Function call semantics are described in more detail in section *note
Calls: deb.  A function call always assigns values to all parameters
mentioned in the parameter list, either from position arguments, from
keyword arguments, or from default values.  If the form "‘*identifier’"
is present, it is initialized to a tuple receiving any excess positional
parameters, defaulting to the empty tuple.  If the form "‘**identifier’"
is present, it is initialized to a new dictionary receiving any excess
keyword arguments, defaulting to a new empty dictionary.  Parameters
after "‘*’" or "‘*identifier’" are keyword-only parameters and may only
be passed used keyword arguments.

Parameters may have annotations of the form "‘: expression’" following
the parameter name.  Any parameter may have an annotation even those of
the form ‘*identifier’ or ‘**identifier’.  Functions may have "return"
annotation of the form "‘-> expression’" after the parameter list.
These annotations can be any valid Python expression and are evaluated
when the function definition is executed.  Annotations may be evaluated
in a different order than they appear in the source code.  The presence
of annotations does not change the semantics of a function.  The
annotation values are available as values of a dictionary keyed by the
parameters’ names in the ‘__annotations__’ attribute of the function
object.

It is also possible to create anonymous functions (functions not bound
to a name), for immediate use in expressions.  This uses lambda
expressions, described in section *note Lambdas: 894.  Note that the
lambda expression is merely a shorthand for a simplified function
definition; a function defined in a "*note def: a3a." statement can be
passed around or assigned to another name just like a function defined
by a lambda expression.  The "*note def: a3a." form is actually more
powerful since it allows the execution of multiple statements and
annotations.

`Programmer’s note:' Functions are first-class objects.  A "‘def’"
statement executed inside a function definition defines a local function
that can be returned or passed around.  Free variables used in the
nested function can access the local variables of the function
containing the def.  See section *note Naming and binding: e66. for
details.

See also
........

PEP 3107(2) - Function Annotations

     The original specification for function annotations.

   ---------- Footnotes ----------

   (1) A string literal appearing as the first statement in the function
body is transformed into the function’s ‘__doc__’ attribute and
therefore the function’s *note docstring: f6b.

   (2) https://www.python.org/dev/peps/pep-3107


File: python.info,  Node: Class definitions,  Next: Coroutines<2>,  Prev: Function definitions,  Up: Compound statements

4.8.7 Class definitions
-----------------------

A class definition defines a class object (see section *note The
standard type hierarchy: de0.):

     classdef    ::= [decorators] "class" classname [inheritance] ":" suite
     inheritance ::= "(" [parameter_list] ")"
     classname   ::= identifier

A class definition is an executable statement.  The inheritance list
usually gives a list of base classes (see *note Customizing class
creation: e0b. for more advanced uses), so each item in the list should
evaluate to a class object which allows subclassing.  Classes without an
inheritance list inherit, by default, from the base class *note object:
5cb.; hence,

     class Foo:
         pass

is equivalent to

     class Foo(object):
         pass

The class’s suite is then executed in a new execution frame (see *note
Naming and binding: e66.), using a newly created local namespace and the
original global namespace.  (Usually, the suite contains mostly function
definitions.)  When the class’s suite finishes execution, its execution
frame is discarded but its local namespace is saved.  (1) A class object
is then created using the inheritance list for the base classes and the
saved local namespace for the attribute dictionary.  The class name is
bound to this class object in the original local namespace.

Class creation can be customized heavily using *note metaclasses: e0b.

Classes can also be decorated: just like when decorating functions,

     @f1(arg)
     @f2
     class Foo: pass

is equivalent to

     class Foo: pass
     Foo = f1(arg)(f2(Foo))

The evaluation rules for the decorator expressions are the same as for
function decorators.  The result must be a class object, which is then
bound to the class name.

`Programmer’s note:' Variables defined in the class definition are class
attributes; they are shared by instances.  Instance attributes can be
set in a method with ‘self.name = value’.  Both class and instance
attributes are accessible through the notation "‘self.name’", and an
instance attribute hides a class attribute with the same name when
accessed in this way.  Class attributes can be used as defaults for
instance attributes, but using mutable values there can lead to
unexpected results.  *note Descriptors: df1. can be used to create
instance variables with different implementation details.

See also
........

PEP 3115(2) - Metaclasses in Python 3 PEP 3129(3) - Class Decorators

   ---------- Footnotes ----------

   (1) A string literal appearing as the first statement in the class
body is transformed into the namespace’s ‘__doc__’ item and therefore
the class’s *note docstring: f6b.

   (2) https://www.python.org/dev/peps/pep-3115

   (3) https://www.python.org/dev/peps/pep-3129


File: python.info,  Node: Coroutines<2>,  Prev: Class definitions,  Up: Compound statements

4.8.8 Coroutines
----------------

New in version 3.5.

* Menu:

* Coroutine function definition:: 
* The async for statement:: 
* The async with statement:: 


File: python.info,  Node: Coroutine function definition,  Next: The async for statement,  Up: Coroutines<2>

4.8.8.1 Coroutine function definition
.....................................

     async_funcdef ::= [decorators] "async" "def" funcname "(" [parameter_list] ")" ["->" expression] ":" suite

Execution of Python coroutines can be suspended and resumed at many
points (see *note coroutine: 2ad.).  In the body of a coroutine, any
‘await’ and ‘async’ identifiers become reserved keywords; *note await:
1cf. expressions, *note async for: 1d1. and *note async with: 1d2. can
only be used in coroutine bodies.

Functions defined with ‘async def’ syntax are always coroutine
functions, even if they do not contain ‘await’ or ‘async’ keywords.

It is a *note SyntaxError: 3a6. to use *note yield: 480. expressions in
‘async def’ coroutines.

An example of a coroutine function:

     async def func(param1, param2):
         do_stuff()
         await some_coroutine()


File: python.info,  Node: The async for statement,  Next: The async with statement,  Prev: Coroutine function definition,  Up: Coroutines<2>

4.8.8.2 The ‘async for’ statement
.................................

     async_for_stmt ::= "async" for_stmt

An *note asynchronous iterable: 1cc. is able to call asynchronous code
in its `iter' implementation, and *note asynchronous iterator: f76. can
call asynchronous code in its `next' method.

The ‘async for’ statement allows convenient iteration over asynchronous
iterators.

The following code:

     async for TARGET in ITER:
         BLOCK
     else:
         BLOCK2

Is semantically equivalent to:

     iter = (ITER)
     iter = await type(iter).__aiter__(iter)
     running = True
     while running:
         try:
             TARGET = await type(iter).__anext__(iter)
         except StopAsyncIteration:
             running = False
         else:
             BLOCK
     else:
         BLOCK2

See also *note __aiter__(): e5a. and *note __anext__(): e5b. for
details.

It is a *note SyntaxError: 3a6. to use ‘async for’ statement outside of
an *note async def: 1ce. function.


File: python.info,  Node: The async with statement,  Prev: The async for statement,  Up: Coroutines<2>

4.8.8.3 The ‘async with’ statement
..................................

     async_with_stmt ::= "async" with_stmt

An *note asynchronous context manager: 1cd. is a *note context manager:
165. that is able to suspend execution in its `enter' and `exit'
methods.

The following code:

     async with EXPR as VAR:
         BLOCK

Is semantically equivalent to:

     mgr = (EXPR)
     aexit = type(mgr).__aexit__
     aenter = type(mgr).__aenter__(mgr)
     exc = True

     VAR = await aenter
     try:
         BLOCK
     except:
         if not await aexit(mgr, *sys.exc_info()):
             raise
     else:
         await aexit(mgr, None, None, None)

See also *note __aenter__(): e5e. and *note __aexit__(): e5f. for
details.

It is a *note SyntaxError: 3a6. to use ‘async with’ statement outside of
an *note async def: 1ce. function.

See also
........

PEP 492(1) - Coroutines with async and await syntax

   ---------- Footnotes ----------

   (1) https://www.python.org/dev/peps/pep-0492


File: python.info,  Node: Top-level components,  Next: Full Grammar specification,  Prev: Compound statements,  Up: The Python Language Reference

4.9 Top-level components
========================

The Python interpreter can get its input from a number of sources: from
a script passed to it as standard input or as program argument, typed in
interactively, from a module source file, etc.  This chapter gives the
syntax used in these cases.

* Menu:

* Complete Python programs:: 
* File input:: 
* Interactive input:: 
* Expression input:: 


File: python.info,  Node: Complete Python programs,  Next: File input,  Up: Top-level components

4.9.1 Complete Python programs
------------------------------

While a language specification need not prescribe how the language
interpreter is invoked, it is useful to have a notion of a complete
Python program.  A complete Python program is executed in a minimally
initialized environment: all built-in and standard modules are
available, but none have been initialized, except for *note sys: fb.
(various system services), *note builtins: 13. (built-in functions,
exceptions and ‘None’) and *note __main__: 1.  The latter is used to
provide the local and global namespace for execution of the complete
program.

The syntax for a complete Python program is that for file input,
described in the next section.

The interpreter may also be invoked in interactive mode; in this case,
it does not read and execute a complete program but reads and executes
one statement (possibly compound) at a time.  The initial environment is
identical to that of a complete program; each statement is executed in
the namespace of *note __main__: 1.

Under Unix, a complete program can be passed to the interpreter in three
forms: with the *note -c: bd2. `string' command line option, as a file
passed as the first command line argument, or as standard input.  If the
file or standard input is a tty device, the interpreter enters
interactive mode; otherwise, it executes the file as a complete program.


File: python.info,  Node: File input,  Next: Interactive input,  Prev: Complete Python programs,  Up: Top-level components

4.9.2 File input
----------------

All input read from non-interactive files has the same form:

     file_input ::= (NEWLINE | statement)*

This syntax is used in the following situations:

   * when parsing a complete Python program (from a file or from a
     string);

   * when parsing a module;

   * when parsing a string passed to the *note exec(): 8ac. function;


File: python.info,  Node: Interactive input,  Next: Expression input,  Prev: File input,  Up: Top-level components

4.9.3 Interactive input
-----------------------

Input in interactive mode is parsed using the following grammar:

     interactive_input ::= [stmt_list] NEWLINE | compound_stmt NEWLINE

Note that a (top-level) compound statement must be followed by a blank
line in interactive mode; this is needed to help the parser detect the
end of the input.


File: python.info,  Node: Expression input,  Prev: Interactive input,  Up: Top-level components

4.9.4 Expression input
----------------------

*note eval(): 7e8. is used for expression input.  It ignores leading
whitespace.  The string argument to *note eval(): 7e8. must have the
following form:

     eval_input ::= expression_list NEWLINE*


File: python.info,  Node: Full Grammar specification,  Prev: Top-level components,  Up: The Python Language Reference

4.10 Full Grammar specification
===============================

This is the full Python grammar, as it is read by the parser generator
and used to parse Python source files:

     # Grammar for Python

     # Note:  Changing the grammar specified in this file will most likely
     #        require corresponding changes in the parser module
     #        (../Modules/parsermodule.c).  If you can't make the changes to
     #        that module yourself, please co-ordinate the required changes
     #        with someone who can; ask around on python-dev for help.  Fred
     #        Drake <fdrake@acm.org> will probably be listening there.

     # NOTE WELL: You should also follow all the steps listed at
     # https://docs.python.org/devguide/grammar.html

     # Start symbols for the grammar:
     #       single_input is a single interactive statement;
     #       file_input is a module or sequence of commands read from an input file;
     #       eval_input is the input for the eval() functions.
     # NB: compound_stmt in single_input is followed by extra NEWLINE!
     single_input: NEWLINE | simple_stmt | compound_stmt NEWLINE
     file_input: (NEWLINE | stmt)* ENDMARKER
     eval_input: testlist NEWLINE* ENDMARKER

     decorator: '@' dotted_name [ '(' [arglist] ')' ] NEWLINE
     decorators: decorator+
     decorated: decorators (classdef | funcdef | async_funcdef)

     async_funcdef: ASYNC funcdef
     funcdef: 'def' NAME parameters ['->' test] ':' suite

     parameters: '(' [typedargslist] ')'
     typedargslist: (tfpdef ['=' test] (',' tfpdef ['=' test])* [',' [
             '*' [tfpdef] (',' tfpdef ['=' test])* [',' ['**' tfpdef [',']]]
           | '**' tfpdef [',']]]
       | '*' [tfpdef] (',' tfpdef ['=' test])* [',' ['**' tfpdef [',']]]
       | '**' tfpdef [','])
     tfpdef: NAME [':' test]
     varargslist: (vfpdef ['=' test] (',' vfpdef ['=' test])* [',' [
             '*' [vfpdef] (',' vfpdef ['=' test])* [',' ['**' vfpdef [',']]]
           | '**' vfpdef [',']]]
       | '*' [vfpdef] (',' vfpdef ['=' test])* [',' ['**' vfpdef [',']]]
       | '**' vfpdef [',']
     )
     vfpdef: NAME

     stmt: simple_stmt | compound_stmt
     simple_stmt: small_stmt (';' small_stmt)* [';'] NEWLINE
     small_stmt: (expr_stmt | del_stmt | pass_stmt | flow_stmt |
                  import_stmt | global_stmt | nonlocal_stmt | assert_stmt)
     expr_stmt: testlist_star_expr (augassign (yield_expr|testlist) |
                          ('=' (yield_expr|testlist_star_expr))*)
     testlist_star_expr: (test|star_expr) (',' (test|star_expr))* [',']
     augassign: ('+=' | '-=' | '*=' | '@=' | '/=' | '%=' | '&=' | '|=' | '^=' |
                 '<<=' | '>>=' | '**=' | '//=')
     # For normal assignments, additional restrictions enforced by the interpreter
     del_stmt: 'del' exprlist
     pass_stmt: 'pass'
     flow_stmt: break_stmt | continue_stmt | return_stmt | raise_stmt | yield_stmt
     break_stmt: 'break'
     continue_stmt: 'continue'
     return_stmt: 'return' [testlist]
     yield_stmt: yield_expr
     raise_stmt: 'raise' [test ['from' test]]
     import_stmt: import_name | import_from
     import_name: 'import' dotted_as_names
     # note below: the ('.' | '...') is necessary because '...' is tokenized as ELLIPSIS
     import_from: ('from' (('.' | '...')* dotted_name | ('.' | '...')+)
                   'import' ('*' | '(' import_as_names ')' | import_as_names))
     import_as_name: NAME ['as' NAME]
     dotted_as_name: dotted_name ['as' NAME]
     import_as_names: import_as_name (',' import_as_name)* [',']
     dotted_as_names: dotted_as_name (',' dotted_as_name)*
     dotted_name: NAME ('.' NAME)*
     global_stmt: 'global' NAME (',' NAME)*
     nonlocal_stmt: 'nonlocal' NAME (',' NAME)*
     assert_stmt: 'assert' test [',' test]

     compound_stmt: if_stmt | while_stmt | for_stmt | try_stmt | with_stmt | funcdef | classdef | decorated | async_stmt
     async_stmt: ASYNC (funcdef | with_stmt | for_stmt)
     if_stmt: 'if' test ':' suite ('elif' test ':' suite)* ['else' ':' suite]
     while_stmt: 'while' test ':' suite ['else' ':' suite]
     for_stmt: 'for' exprlist 'in' testlist ':' suite ['else' ':' suite]
     try_stmt: ('try' ':' suite
                ((except_clause ':' suite)+
                 ['else' ':' suite]
                 ['finally' ':' suite] |
                'finally' ':' suite))
     with_stmt: 'with' with_item (',' with_item)*  ':' suite
     with_item: test ['as' expr]
     # NB compile.c makes sure that the default except clause is last
     except_clause: 'except' [test ['as' NAME]]
     suite: simple_stmt | NEWLINE INDENT stmt+ DEDENT

     test: or_test ['if' or_test 'else' test] | lambdef
     test_nocond: or_test | lambdef_nocond
     lambdef: 'lambda' [varargslist] ':' test
     lambdef_nocond: 'lambda' [varargslist] ':' test_nocond
     or_test: and_test ('or' and_test)*
     and_test: not_test ('and' not_test)*
     not_test: 'not' not_test | comparison
     comparison: expr (comp_op expr)*
     # <> isn't actually a valid comparison operator in Python. It's here for the
     # sake of a __future__ import described in PEP 401 (which really works :-)
     comp_op: '<'|'>'|'=='|'>='|'<='|'<>'|'!='|'in'|'not' 'in'|'is'|'is' 'not'
     star_expr: '*' expr
     expr: xor_expr ('|' xor_expr)*
     xor_expr: and_expr ('^' and_expr)*
     and_expr: shift_expr ('&' shift_expr)*
     shift_expr: arith_expr (('<<'|'>>') arith_expr)*
     arith_expr: term (('+'|'-') term)*
     term: factor (('*'|'@'|'/'|'%'|'//') factor)*
     factor: ('+'|'-'|'~') factor | power
     power: atom_expr ['**' factor]
     atom_expr: [AWAIT] atom trailer*
     atom: ('(' [yield_expr|testlist_comp] ')' |
            '[' [testlist_comp] ']' |
            '{' [dictorsetmaker] '}' |
            NAME | NUMBER | STRING+ | '...' | 'None' | 'True' | 'False')
     testlist_comp: (test|star_expr) ( comp_for | (',' (test|star_expr))* [','] )
     trailer: '(' [arglist] ')' | '[' subscriptlist ']' | '.' NAME
     subscriptlist: subscript (',' subscript)* [',']
     subscript: test | [test] ':' [test] [sliceop]
     sliceop: ':' [test]
     exprlist: (expr|star_expr) (',' (expr|star_expr))* [',']
     testlist: test (',' test)* [',']
     dictorsetmaker: ( ((test ':' test | '**' expr)
                        (comp_for | (',' (test ':' test | '**' expr))* [','])) |
                       ((test | star_expr)
                        (comp_for | (',' (test | star_expr))* [','])) )

     classdef: 'class' NAME ['(' [arglist] ')'] ':' suite

     arglist: argument (',' argument)*  [',']

     # The reason that keywords are test nodes instead of NAME is that using NAME
     # results in an ambiguity. ast.c makes sure it's a NAME.
     # "test '=' test" is really "keyword '=' test", but we have no such token.
     # These need to be in a single rule to avoid grammar that is ambiguous
     # to our LL(1) parser. Even though 'test' includes '*expr' in star_expr,
     # we explicitly match '*' here, too, to give it proper precedence.
     # Illegal combinations and orderings are blocked in ast.c:
     # multiple (test comp_for) arguements are blocked; keyword unpackings
     # that precede iterable unpackings are blocked; etc.
     argument: ( test [comp_for] |
                 test '=' test |
                 '**' test |
                 '*' test )

     comp_iter: comp_for | comp_if
     comp_for: 'for' exprlist 'in' or_test [comp_iter]
     comp_if: 'if' test_nocond [comp_iter]

     # not used in grammar, but may appear in "node" passed from Parser to Compiler
     encoding_decl: NAME

     yield_expr: 'yield' [yield_arg]
     yield_arg: 'from' test | testlist


File: python.info,  Node: The Python Standard Library,  Next: Extending and Embedding the Python Interpreter,  Prev: The Python Language Reference,  Up: Top

5 The Python Standard Library
*****************************

While *note The Python Language Reference: bc6. describes the exact
syntax and semantics of the Python language, this library reference
manual describes the standard library that is distributed with Python.
It also describes some of the optional components that are commonly
included in Python distributions.

Python’s standard library is very extensive, offering a wide range of
facilities as indicated by the long table of contents listed below.  The
library contains built-in modules (written in C) that provide access to
system functionality such as file I/O that would otherwise be
inaccessible to Python programmers, as well as modules written in Python
that provide standardized solutions for many problems that occur in
everyday programming.  Some of these modules are explicitly designed to
encourage and enhance the portability of Python programs by abstracting
away platform-specifics into platform-neutral APIs.

The Python installers for the Windows platform usually include the
entire standard library and often also include many additional
components.  For Unix-like operating systems Python is normally provided
as a collection of packages, so it may be necessary to use the packaging
tools provided with the operating system to obtain some or all of the
optional components.

In addition to the standard library, there is a growing collection of
several thousand components (from individual programs and modules to
packages and entire application development frameworks), available from
the Python Package Index(1).

* Menu:

* Introduction: Introduction<6>. 
* Built-in Functions:: 
* Built-in Constants:: 
* Built-in Types:: 
* Built-in Exceptions:: 
* Text Processing Services:: 
* Binary Data Services:: 
* Data Types:: 
* Numeric and Mathematical Modules:: 
* Functional Programming Modules:: 
* File and Directory Access:: 
* Data Persistence:: 
* Data Compression and Archiving:: 
* File Formats:: 
* Cryptographic Services:: 
* Generic Operating System Services:: 
* Concurrent Execution:: 
* Interprocess Communication and Networking:: 
* Internet Data Handling:: 
* Structured Markup Processing Tools:: 
* Internet Protocols and Support:: 
* Multimedia Services:: 
* Internationalization:: 
* Program Frameworks:: 
* Graphical User Interfaces with Tk:: 
* Development Tools:: 
* Debugging and Profiling:: 
* Software Packaging and Distribution:: 
* Python Runtime Services:: 
* Custom Python Interpreters:: 
* Importing Modules:: 
* Python Language Services:: 
* Miscellaneous Services:: 
* MS Windows Specific Services:: 
* Unix Specific Services:: 
* Superseded Modules:: 
* Undocumented Modules:: 

   ---------- Footnotes ----------

   (1) https://pypi.python.org/pypi


File: python.info,  Node: Introduction<6>,  Next: Built-in Functions,  Up: The Python Standard Library

5.1 Introduction
================

The "Python library" contains several different kinds of components.

It contains data types that would normally be considered part of the
"core" of a language, such as numbers and lists.  For these types, the
Python language core defines the form of literals and places some
constraints on their semantics, but does not fully define the semantics.
(On the other hand, the language core does define syntactic properties
like the spelling and priorities of operators.)

The library also contains built-in functions and exceptions — objects
that can be used by all Python code without the need of an *note import:
881. statement.  Some of these are defined by the core language, but
many are not essential for the core semantics and are only described
here.

The bulk of the library, however, consists of a collection of modules.
There are many ways to dissect this collection.  Some modules are
written in C and built in to the Python interpreter; others are written
in Python and imported in source form.  Some modules provide interfaces
that are highly specific to Python, like printing a stack trace; some
provide interfaces that are specific to particular operating systems,
such as access to specific hardware; others provide interfaces that are
specific to a particular application domain, like the World Wide Web.
Some modules are available in all versions and ports of Python; others
are only available when the underlying system supports or requires them;
yet others are available only when a particular configuration option was
chosen at the time when Python was compiled and installed.

This manual is organized "from the inside out:" it first describes the
built-in functions, data types and exceptions, and finally the modules,
grouped in chapters of related modules.

This means that if you start reading this manual from the start, and
skip to the next chapter when you get bored, you will get a reasonable
overview of the available modules and application areas that are
supported by the Python library.  Of course, you don’t `have' to read it
like a novel — you can also browse the table of contents (in front of
the manual), or look for a specific function, module or term in the
index (in the back).  And finally, if you enjoy learning about random
subjects, you choose a random page number (see module *note random: da.)
and read a section or two.  Regardless of the order in which you read
the sections of this manual, it helps to start with chapter *note
Built-in Functions: 854, as the remainder of the manual assumes
familiarity with this material.

Let the show begin!


File: python.info,  Node: Built-in Functions,  Next: Built-in Constants,  Prev: Introduction<6>,  Up: The Python Standard Library

5.2 Built-in Functions
======================

The Python interpreter has a number of functions and types built into it
that are always available.  They are listed here in alphabetical order.

                                              Built-in Functions
                                              
-------------------------------------------------------------------------------------------------------------------
                                                                                          
*note abs(): c7c.       *note dict(): f8f.    *note help(): 3b6.     *note min(): 3f9.    *note setattr(): f90.
                                                                                          
                                                                                          
*note all(): 9fe.       *note dir(): 16a.     *note hex(): 8d1.      *note next(): 218.   *note slice(): a85.
                                                                                          
                                                                                          
*note any(): 9fd.       *note divmod(): e2c.  *note id(): a00.       *note object(): 5cb. *note sorted(): 84e.
                                                                                          
                                                                                          
*note ascii(): 9c3.     *note enumerate(): a61.*note input(): 8d7.   *note oct(): 8d0.    *note staticmethod(): 5f6.
                                                                                          
                                                                                          
*note bin(): 8a7.       *note eval(): 7e8.    *note int(): 227.      *note open(): 1e8.   *note str(): f91.
                                                                                          
                                                                                          
*note bool(): a72.      *note exec(): 8ac.    *note isinstance(): 998.*note ord(): de6.   *note sum(): a60.
                                                                                          
                                                                                          
*note bytearray(): 1dc. *note filter(): 893.  *note issubclass(): 999.*note pow(): ad3.   *note super(): 56a.
                                                                                          
                                                                                          
*note bytes(): 1db.     *note float(): 57a.   *note iter(): 99a.     *note print(): 481.  *note tuple(): f92.
                                                                                          
                                                                                          
*note callable(): 78d.  *note format(): 14e.  *note len(): 5a8.      *note property(): 377.*note type(): 376.
                                                                                          
                                                                                          
*note chr(): de7.       *note frozenset(): f93.*note list(): f94.    *note range(): f95.  *note vars(): c5a.
                                                                                          
                                                                                          
*note classmethod(): 5f4.*note getattr(): 781.*note locals(): 9a8.   *note repr(): 3bb.   *note zip(): 897.
                                                                                          
                                                                                          
*note compile(): 903.   *note globals(): f96. *note map(): 892.      *note reversed(): 24d.*note __import__(): 5cd.
                                                                                          
                                                                                          
*note complex(): 579.   *note hasattr(): 780. *note max(): 3fa.      *note round(): 8d9.
                                                                     
                                                                                          
*note delattr(): f97.   *note hash(): 5e6.    *note memoryview(): f98.*note set(): f99.
                                                                     

 -- Function: abs (x)

     Return the absolute value of a number.  The argument may be an
     integer or a floating point number.  If the argument is a complex
     number, its magnitude is returned.

 -- Function: all (iterable)

     Return ‘True’ if all elements of the `iterable' are true (or if the
     iterable is empty).  Equivalent to:

          def all(iterable):
              for element in iterable:
                  if not element:
                      return False
              return True

 -- Function: any (iterable)

     Return ‘True’ if any element of the `iterable' is true.  If the
     iterable is empty, return ‘False’.  Equivalent to:

          def any(iterable):
              for element in iterable:
                  if element:
                      return True
              return False

 -- Function: ascii (object)

     As *note repr(): 3bb, return a string containing a printable
     representation of an object, but escape the non-ASCII characters in
     the string returned by *note repr(): 3bb. using ‘\x’, ‘\u’ or ‘\U’
     escapes.  This generates a string similar to that returned by *note
     repr(): 3bb. in Python 2.

 -- Function: bin (x)

     Convert an integer number to a binary string.  The result is a
     valid Python expression.  If `x' is not a Python *note int: 227.
     object, it has to define an *note __index__(): 8d2. method that
     returns an integer.

 -- Class: bool ([x])

     Return a Boolean value, i.e.  one of ‘True’ or ‘False’.  `x' is
     converted using the standard *note truth testing procedure: f9a.
     If `x' is false or omitted, this returns ‘False’; otherwise it
     returns ‘True’.  The *note bool: a72. class is a subclass of *note
     int: 227. (see *note Numeric Types — int, float, complex: be6.).
     It cannot be subclassed further.  Its only instances are ‘False’
     and ‘True’ (see *note Boolean Values: f9b.).

 -- Class: bytearray ([source[, encoding[, errors]]])

     Return a new array of bytes.  The *note bytearray: 1dc. class is a
     mutable sequence of integers in the range 0 <= x < 256.  It has
     most of the usual methods of mutable sequences, described in *note
     Mutable Sequence Types: f9d, as well as most methods that the *note
     bytes: 1db. type has, see *note Bytes and Bytearray Operations:
     f9e.

     The optional `source' parameter can be used to initialize the array
     in a few different ways:

        * If it is a `string', you must also give the `encoding' (and
          optionally, `errors') parameters; *note bytearray(): 1dc. then
          converts the string to bytes using *note str.encode(): 89d.

        * If it is an `integer', the array will have that size and will
          be initialized with null bytes.

        * If it is an object conforming to the `buffer' interface, a
          read-only buffer of the object will be used to initialize the
          bytes array.

        * If it is an `iterable', it must be an iterable of integers in
          the range ‘0 <= x < 256’, which are used as the initial
          contents of the array.

     Without an argument, an array of size 0 is created.

     See also *note Binary Sequence Types — bytes, bytearray,
     memoryview: f9f. and *note Bytearray Objects: fa0.
 -- Class: bytes ([source[, encoding[, errors]]])

     Return a new "bytes" object, which is an immutable sequence of
     integers in the range ‘0 <= x < 256’.  *note bytes: 1db. is an
     immutable version of *note bytearray: 1dc. – it has the same
     non-mutating methods and the same indexing and slicing behavior.

     Accordingly, constructor arguments are interpreted as for *note
     bytearray(): 1dc.

     Bytes objects can also be created with literals, see *note String
     and Bytes literals: d9f.

     See also *note Binary Sequence Types — bytes, bytearray,
     memoryview: f9f, *note Bytes: fa2, and *note Bytes and Bytearray
     Operations: f9e.

 -- Function: callable (object)

     Return *note True: 9ff. if the `object' argument appears callable,
     *note False: 60d. if not.  If this returns true, it is still
     possible that a call fails, but if it is false, calling `object'
     will never succeed.  Note that classes are callable (calling a
     class returns a new instance); instances are callable if their
     class has a *note __call__(): dee. method.

     New in version 3.2: This function was first removed in Python 3.0
     and then brought back in Python 3.2.

 -- Function: chr (i)

     Return the string representing a character whose Unicode code point
     is the integer `i'.  For example, ‘chr(97)’ returns the string
     ‘'a'’, while ‘chr(8364)’ returns the string ‘'€'’.  This is the
     inverse of *note ord(): de6.

     The valid range for the argument is from 0 through 1,114,111
     (0x10FFFF in base 16).  *note ValueError: 19c. will be raised if
     `i' is outside that range.

 -- Function: classmethod (function)

     Return a class method for `function'.

     A class method receives the class as implicit first argument, just
     like an instance method receives the instance.  To declare a class
     method, use this idiom:

          class C:
              @classmethod
              def f(cls, arg1, arg2, ...): ...

     The ‘@classmethod’ form is a function *note decorator: f6c. – see
     the description of function definitions in *note Function
     definitions: c1e. for details.

     It can be called either on the class (such as ‘C.f()’) or on an
     instance (such as ‘C().f()’).  The instance is ignored except for
     its class.  If a class method is called for a derived class, the
     derived class object is passed as the implied first argument.

     Class methods are different than C++ or Java static methods.  If
     you want those, see *note staticmethod(): 5f6. in this section.

     For more information on class methods, consult the documentation on
     the standard type hierarchy in *note The standard type hierarchy:
     de0.

 -- Function: compile (source, filename, mode, flags=0,
          dont_inherit=False, optimize=-1)

     Compile the `source' into a code or AST object.  Code objects can
     be executed by *note exec(): 8ac. or *note eval(): 7e8.  `source'
     can either be a normal string, a byte string, or an AST object.
     Refer to the *note ast: 8. module documentation for information on
     how to work with AST objects.

     The `filename' argument should give the file from which the code
     was read; pass some recognizable value if it wasn’t read from a
     file (‘'<string>'’ is commonly used).

     The `mode' argument specifies what kind of code must be compiled;
     it can be ‘'exec'’ if `source' consists of a sequence of
     statements, ‘'eval'’ if it consists of a single expression, or
     ‘'single'’ if it consists of a single interactive statement (in the
     latter case, expression statements that evaluate to something other
     than ‘None’ will be printed).

     The optional arguments `flags' and `dont_inherit' control which
     future statements (see PEP 236(1)) affect the compilation of
     `source'.  If neither is present (or both are zero) the code is
     compiled with those future statements that are in effect in the
     code that is calling *note compile(): 903.  If the `flags' argument
     is given and `dont_inherit' is not (or is zero) then the future
     statements specified by the `flags' argument are used in addition
     to those that would be used anyway.  If `dont_inherit' is a
     non-zero integer then the `flags' argument is it – the future
     statements in effect around the call to compile are ignored.

     Future statements are specified by bits which can be bitwise ORed
     together to specify multiple statements.  The bitfield required to
     specify a given feature can be found as the ‘compiler_flag’
     attribute on the ‘_Feature’ instance in the *note __future__: 0.
     module.

     The argument `optimize' specifies the optimization level of the
     compiler; the default value of ‘-1’ selects the optimization level
     of the interpreter as given by *note -O: 221. options.  Explicit
     levels are ‘0’ (no optimization; ‘__debug__’ is true), ‘1’ (asserts
     are removed, ‘__debug__’ is false) or ‘2’ (docstrings are removed
     too).

     This function raises *note SyntaxError: 3a6. if the compiled source
     is invalid, and *note ValueError: 19c. if the source contains null
     bytes.

     If you want to parse Python code into its AST representation, see
     *note ast.parse(): bb4.

          Note: When compiling a string with multi-line code in
          ‘'single'’ or ‘'eval'’ mode, input must be terminated by at
          least one newline character.  This is to facilitate detection
          of incomplete and complete statements in the *note code: 1b.
          module.

     Changed in version 3.2: Allowed use of Windows and Mac newlines.
     Also input in ‘'exec'’ mode does not have to end in a newline
     anymore.  Added the `optimize' parameter.

     Changed in version 3.5: Previously, *note TypeError: 562. was
     raised when null bytes were encountered in `source'.

 -- Class: complex ([real[, imag]])

     Return a complex number with the value `real' + `imag'*1j or
     convert a string or number to a complex number.  If the first
     parameter is a string, it will be interpreted as a complex number
     and the function must be called without a second parameter.  The
     second parameter can never be a string.  Each argument may be any
     numeric type (including complex).  If `imag' is omitted, it
     defaults to zero and the constructor serves as a numeric conversion
     like *note int: 227. and *note float: 57a.  If both arguments are
     omitted, returns ‘0j’.

          Note: When converting from a string, the string must not
          contain whitespace around the central ‘+’ or ‘-’ operator.
          For example, ‘complex('1+2j')’ is fine, but ‘complex('1 +
          2j')’ raises *note ValueError: 19c.

     The complex type is described in *note Numeric Types — int, float,
     complex: be6.

 -- Function: delattr (object, name)

     This is a relative of *note setattr(): f90.  The arguments are an
     object and a string.  The string must be the name of one of the
     object’s attributes.  The function deletes the named attribute,
     provided the object allows it.  For example, ‘delattr(x, 'foobar')’
     is equivalent to ‘del x.foobar’.

 -- Class: dict (**kwarg)

 -- Class: dict (mapping, **kwarg)

 -- Class: dict (iterable, **kwarg)

     Create a new dictionary.  The *note dict: 3b0. object is the
     dictionary class.  See *note dict: 3b0. and *note Mapping Types —
     dict: c13. for documentation about this class.

     For other containers see the built-in *note list: 25d, *note set:
     7be, and *note tuple: 25c. classes, as well as the *note
     collections: 1e. module.

 -- Function: dir ([object])

     Without arguments, return the list of names in the current local
     scope.  With an argument, attempt to return a list of valid
     attributes for that object.

     If the object has a method named *note __dir__(): 9a7, this method
     will be called and must return the list of attributes.  This allows
     objects that implement a custom *note __getattr__(): 782. or *note
     __getattribute__(): 783. function to customize the way *note dir():
     16a. reports their attributes.

     If the object does not provide *note __dir__(): 9a7, the function
     tries its best to gather information from the object’s ‘__dict__’
     attribute, if defined, and from its type object.  The resulting
     list is not necessarily complete, and may be inaccurate when the
     object has a custom *note __getattr__(): 782.

     The default *note dir(): 16a. mechanism behaves differently with
     different types of objects, as it attempts to produce the most
     relevant, rather than complete, information:

        * If the object is a module object, the list contains the names
          of the module’s attributes.

        * If the object is a type or class object, the list contains the
          names of its attributes, and recursively of the attributes of
          its bases.

        * Otherwise, the list contains the object’s attributes’ names,
          the names of its class’s attributes, and recursively of the
          attributes of its class’s base classes.

     The resulting list is sorted alphabetically.  For example:

          >>> import struct
          >>> dir()   # show the names in the module namespace
          ['__builtins__', '__name__', 'struct']
          >>> dir(struct)   # show the names in the struct module # doctest: +SKIP
          ['Struct', '__all__', '__builtins__', '__cached__', '__doc__', '__file__',
           '__initializing__', '__loader__', '__name__', '__package__',
           '_clearcache', 'calcsize', 'error', 'pack', 'pack_into',
           'unpack', 'unpack_from']
          >>> class Shape:
          ...     def __dir__(self):
          ...         return ['area', 'perimeter', 'location']
          >>> s = Shape()
          >>> dir(s)
          ['area', 'location', 'perimeter']

          Note: Because *note dir(): 16a. is supplied primarily as a
          convenience for use at an interactive prompt, it tries to
          supply an interesting set of names more than it tries to
          supply a rigorously or consistently defined set of names, and
          its detailed behavior may change across releases.  For
          example, metaclass attributes are not in the result list when
          the argument is a class.

 -- Function: divmod (a, b)

     Take two (non complex) numbers as arguments and return a pair of
     numbers consisting of their quotient and remainder when using
     integer division.  With mixed operand types, the rules for binary
     arithmetic operators apply.  For integers, the result is the same
     as ‘(a // b, a % b)’.  For floating point numbers the result is
     ‘(q, a % b)’, where `q' is usually ‘math.floor(a / b)’ but may be 1
     less than that.  In any case ‘q * b + a % b’ is very close to `a',
     if ‘a % b’ is non-zero it has the same sign as `b', and ‘0 <= abs(a
     % b) < abs(b)’.

 -- Function: enumerate (iterable, start=0)

     Return an enumerate object.  `iterable' must be a sequence, an
     *note iterator: e4f, or some other object which supports iteration.
     The *note __next__(): 8cf. method of the iterator returned by *note
     enumerate(): a61. returns a tuple containing a count (from `start'
     which defaults to 0) and the values obtained from iterating over
     `iterable'.

          >>> seasons = ['Spring', 'Summer', 'Fall', 'Winter']
          >>> list(enumerate(seasons))
          [(0, 'Spring'), (1, 'Summer'), (2, 'Fall'), (3, 'Winter')]
          >>> list(enumerate(seasons, start=1))
          [(1, 'Spring'), (2, 'Summer'), (3, 'Fall'), (4, 'Winter')]

     Equivalent to:

          def enumerate(sequence, start=0):
              n = start
              for elem in sequence:
                  yield n, elem
                  n += 1

 -- Function: eval (expression, globals=None, locals=None)

     The arguments are a string and optional globals and locals.  If
     provided, `globals' must be a dictionary.  If provided, `locals'
     can be any mapping object.

     The `expression' argument is parsed and evaluated as a Python
     expression (technically speaking, a condition list) using the
     `globals' and `locals' dictionaries as global and local namespace.
     If the `globals' dictionary is present and lacks ’__builtins__’,
     the current globals are copied into `globals' before `expression'
     is parsed.  This means that `expression' normally has full access
     to the standard *note builtins: 13. module and restricted
     environments are propagated.  If the `locals' dictionary is omitted
     it defaults to the `globals' dictionary.  If both dictionaries are
     omitted, the expression is executed in the environment where *note
     eval(): 7e8. is called.  The return value is the result of the
     evaluated expression.  Syntax errors are reported as exceptions.
     Example:

          >>> x = 1
          >>> eval('x+1')
          2

     This function can also be used to execute arbitrary code objects
     (such as those created by *note compile(): 903.).  In this case
     pass a code object instead of a string.  If the code object has
     been compiled with ‘'exec'’ as the `mode' argument, *note eval():
     7e8.’s return value will be ‘None’.

     Hints: dynamic execution of statements is supported by the *note
     exec(): 8ac. function.  The *note globals(): f96. and *note
     locals(): 9a8. functions returns the current global and local
     dictionary, respectively, which may be useful to pass around for
     use by *note eval(): 7e8. or *note exec(): 8ac.

     See *note ast.literal_eval(): 7e7. for a function that can safely
     evaluate strings with expressions containing only literals.

 -- Function: exec (object[, globals[, locals]])

     This function supports dynamic execution of Python code.  `object'
     must be either a string or a code object.  If it is a string, the
     string is parsed as a suite of Python statements which is then
     executed (unless a syntax error occurs).  (2) If it is a code
     object, it is simply executed.  In all cases, the code that’s
     executed is expected to be valid as file input (see the section
     "File input" in the Reference Manual).  Be aware that the *note
     return: 981. and *note yield: 480. statements may not be used
     outside of function definitions even within the context of code
     passed to the *note exec(): 8ac. function.  The return value is
     ‘None’.

     In all cases, if the optional parts are omitted, the code is
     executed in the current scope.  If only `globals' is provided, it
     must be a dictionary, which will be used for both the global and
     the local variables.  If `globals' and `locals' are given, they are
     used for the global and local variables, respectively.  If
     provided, `locals' can be any mapping object.  Remember that at
     module level, globals and locals are the same dictionary.  If exec
     gets two separate objects as `globals' and `locals', the code will
     be executed as if it were embedded in a class definition.

     If the `globals' dictionary does not contain a value for the key
     ‘__builtins__’, a reference to the dictionary of the built-in
     module *note builtins: 13. is inserted under that key.  That way
     you can control what builtins are available to the executed code by
     inserting your own ‘__builtins__’ dictionary into `globals' before
     passing it to *note exec(): 8ac.

          Note: The built-in functions *note globals(): f96. and *note
          locals(): 9a8. return the current global and local dictionary,
          respectively, which may be useful to pass around for use as
          the second and third argument to *note exec(): 8ac.

          Note: The default `locals' act as described for function *note
          locals(): 9a8. below: modifications to the default `locals'
          dictionary should not be attempted.  Pass an explicit `locals'
          dictionary if you need to see effects of the code on `locals'
          after function *note exec(): 8ac. returns.

 -- Function: filter (function, iterable)

     Construct an iterator from those elements of `iterable' for which
     `function' returns true.  `iterable' may be either a sequence, a
     container which supports iteration, or an iterator.  If `function'
     is ‘None’, the identity function is assumed, that is, all elements
     of `iterable' that are false are removed.

     Note that ‘filter(function, iterable)’ is equivalent to the
     generator expression ‘(item for item in iterable if
     function(item))’ if function is not ‘None’ and ‘(item for item in
     iterable if item)’ if function is ‘None’.

     See *note itertools.filterfalse(): fa3. for the complementary
     function that returns elements of `iterable' for which `function'
     returns false.

 -- Class: float ([x])

     Return a floating point number constructed from a number or string
     `x'.

     If the argument is a string, it should contain a decimal number,
     optionally preceded by a sign, and optionally embedded in
     whitespace.  The optional sign may be ‘'+'’ or ‘'-'’; a ‘'+'’ sign
     has no effect on the value produced.  The argument may also be a
     string representing a NaN (not-a-number), or a positive or negative
     infinity.  More precisely, the input must conform to the following
     grammar after leading and trailing whitespace characters are
     removed:

          sign           ::= "+" | "-"
          infinity       ::= "Infinity" | "inf"
          nan            ::= "nan"
          numeric_value  ::= floatnumber | infinity | nan
          numeric_string ::= [sign] numeric_value

     Here ‘floatnumber’ is the form of a Python floating-point literal,
     described in *note Floating point literals: dca.  Case is not
     significant, so, for example, "inf", "Inf", "INFINITY" and
     "iNfINity" are all acceptable spellings for positive infinity.

     Otherwise, if the argument is an integer or a floating point
     number, a floating point number with the same value (within
     Python’s floating point precision) is returned.  If the argument is
     outside the range of a Python float, an *note OverflowError: 578.
     will be raised.

     For a general Python object ‘x’, ‘float(x)’ delegates to
     ‘x.__float__()’.

     If no argument is given, ‘0.0’ is returned.

     Examples:

          >>> float('+1.23')
          1.23
          >>> float('   -12345\n')
          -12345.0
          >>> float('1e-003')
          0.001
          >>> float('+1E6')
          1000000.0
          >>> float('-Infinity')
          -inf

     The float type is described in *note Numeric Types — int, float,
     complex: be6.

 -- Function: format (value[, format_spec])

     Convert a `value' to a "formatted" representation, as controlled by
     `format_spec'.  The interpretation of `format_spec' will depend on
     the type of the `value' argument, however there is a standard
     formatting syntax that is used by most built-in types: *note Format
     Specification Mini-Language: dfc.

     The default `format_spec' is an empty string which usually gives
     the same effect as calling *note str(value): 25a.

     A call to ‘format(value, format_spec)’ is translated to
     ‘type(value).__format__(value, format_spec)’ which bypasses the
     instance dictionary when searching for the value’s *note
     __format__(): 561. method.  A *note TypeError: 562. exception is
     raised if the method search reaches *note object: 5cb. and the
     `format_spec' is non-empty, or if either the `format_spec' or the
     return value are not strings.

     Changed in version 3.4: ‘object().__format__(format_spec)’ raises
     *note TypeError: 562. if `format_spec' is not an empty string.

 -- Class: frozenset ([iterable])

     Return a new *note frozenset: 84c. object, optionally with elements
     taken from `iterable'.  ‘frozenset’ is a built-in class.  See *note
     frozenset: 84c. and *note Set Types — set, frozenset: fa9. for
     documentation about this class.

     For other containers see the built-in *note set: 7be, *note list:
     25d, *note tuple: 25c, and *note dict: 3b0. classes, as well as the
     *note collections: 1e. module.

 -- Function: getattr (object, name[, default])

     Return the value of the named attribute of `object'.  `name' must
     be a string.  If the string is the name of one of the object’s
     attributes, the result is the value of that attribute.  For
     example, ‘getattr(x, 'foobar')’ is equivalent to ‘x.foobar’.  If
     the named attribute does not exist, `default' is returned if
     provided, otherwise *note AttributeError: 356. is raised.

 -- Function: globals ()

     Return a dictionary representing the current global symbol table.
     This is always the dictionary of the current module (inside a
     function or method, this is the module where it is defined, not the
     module from which it is called).

 -- Function: hasattr (object, name)

     The arguments are an object and a string.  The result is ‘True’ if
     the string is the name of one of the object’s attributes, ‘False’
     if not.  (This is implemented by calling ‘getattr(object, name)’
     and seeing whether it raises an *note AttributeError: 356. or not.)

 -- Function: hash (object)

          Return the hash value of the object (if it has one).  Hash
          values are integers.  They are used to quickly compare
          dictionary keys during a dictionary lookup.  Numeric values
          that compare equal have the same hash value (even if they are
          of different types, as is the case for 1 and 1.0).

          Note: For object’s with custom *note __hash__(): 5e7. methods,
          note that *note hash(): 5e6. truncates the return value based
          on the bit width of the host machine.  See *note __hash__():
          5e7. for details.

 -- Function: help ([object])

     Invoke the built-in help system.  (This function is intended for
     interactive use.)  If no argument is given, the interactive help
     system starts on the interpreter console.  If the argument is a
     string, then the string is looked up as the name of a module,
     function, class, method, keyword, or documentation topic, and a
     help page is printed on the console.  If the argument is any other
     kind of object, a help page on the object is generated.

     This function is added to the built-in namespace by the *note site:
     e9. module.

     Changed in version 3.4: Changes to *note pydoc: d7. and *note
     inspect: 9e. mean that the reported signatures for callables are
     now more comprehensive and consistent.

 -- Function: hex (x)

     Convert an integer number to a lowercase hexadecimal string
     prefixed with "0x", for example:

          >>> hex(255)
          '0xff'
          >>> hex(-42)
          '-0x2a'

     If x is not a Python *note int: 227. object, it has to define an
     __index__() method that returns an integer.

     See also *note int(): 227. for converting a hexadecimal string to
     an integer using a base of 16.

          Note: To obtain a hexadecimal string representation for a
          float, use the *note float.hex(): ce5. method.

 -- Function: id (object)

     Return the "identity" of an object.  This is an integer which is
     guaranteed to be unique and constant for this object during its
     lifetime.  Two objects with non-overlapping lifetimes may have the
     same *note id(): a00. value.

     `CPython implementation detail:' This is the address of the object
     in memory.

 -- Function: input ([prompt])

     If the `prompt' argument is present, it is written to standard
     output without a trailing newline.  The function then reads a line
     from input, converts it to a string (stripping a trailing newline),
     and returns that.  When EOF is read, *note EOFError: 8d8. is
     raised.  Example:

          >>> s = input('--> ')  # doctest: +SKIP
          --> Monty Python's Flying Circus
          >>> s  # doctest: +SKIP
          "Monty Python's Flying Circus"

     If the *note readline: dc. module was loaded, then *note input():
     8d7. will use it to provide elaborate line editing and history
     features.

 -- Class: int (x=0)

 -- Class: int (x, base=10)

     Return an integer object constructed from a number or string `x',
     or return ‘0’ if no arguments are given.  If `x' is a number,
     return *note x.__int__(): 929.  For floating point numbers, this
     truncates towards zero.

     If `x' is not a number or if `base' is given, then `x' must be a
     string, *note bytes: 1db, or *note bytearray: 1dc. instance
     representing an *note integer literal: dbe. in radix `base'.
     Optionally, the literal can be preceded by ‘+’ or ‘-’ (with no
     space in between) and surrounded by whitespace.  A base-n literal
     consists of the digits 0 to n-1, with ‘a’ to ‘z’ (or ‘A’ to ‘Z’)
     having values 10 to 35.  The default `base' is 10.  The allowed
     values are 0 and 2-36.  Base-2, -8, and -16 literals can be
     optionally prefixed with ‘0b’/‘0B’, ‘0o’/‘0O’, or ‘0x’/‘0X’, as
     with integer literals in code.  Base 0 means to interpret exactly
     as a code literal, so that the actual base is 2, 8, 10, or 16, and
     so that ‘int('010', 0)’ is not legal, while ‘int('010')’ is, as
     well as ‘int('010', 8)’.

     The integer type is described in *note Numeric Types — int, float,
     complex: be6.

     Changed in version 3.4: If `base' is not an instance of *note int:
     227. and the `base' object has a *note base.__index__: 8d2. method,
     that method is called to obtain an integer for the base.  Previous
     versions used *note base.__int__: 929. instead of *note
     base.__index__: 8d2.

 -- Function: isinstance (object, classinfo)

     Return true if the `object' argument is an instance of the
     `classinfo' argument, or of a (direct, indirect or *note virtual:
     776.) subclass thereof.  If `object' is not an object of the given
     type, the function always returns false.  If `classinfo' is a tuple
     of type objects (or recursively, other such tuples), return true if
     `object' is an instance of any of the types.  If `classinfo' is not
     a type or tuple of types and such tuples, a *note TypeError: 562.
     exception is raised.

 -- Function: issubclass (class, classinfo)

     Return true if `class' is a subclass (direct, indirect or *note
     virtual: 776.) of `classinfo'.  A class is considered a subclass of
     itself.  `classinfo' may be a tuple of class objects, in which case
     every entry in `classinfo' will be checked.  In any other case, a
     *note TypeError: 562. exception is raised.

 -- Function: iter (object[, sentinel])

     Return an *note iterator: e4f. object.  The first argument is
     interpreted very differently depending on the presence of the
     second argument.  Without a second argument, `object' must be a
     collection object which supports the iteration protocol (the *note
     __iter__(): 99b. method), or it must support the sequence protocol
     (the *note __getitem__(): a84. method with integer arguments
     starting at ‘0’).  If it does not support either of those
     protocols, *note TypeError: 562. is raised.  If the second
     argument, `sentinel', is given, then `object' must be a callable
     object.  The iterator created in this case will call `object' with
     no arguments for each call to its *note __next__(): 8cf. method; if
     the value returned is equal to `sentinel', *note StopIteration:
     191. will be raised, otherwise the value will be returned.

     See also *note Iterator Types: e1e.

     One useful application of the second form of *note iter(): 99a. is
     to read lines of a file until a certain line is reached.  The
     following example reads a file until the *note readline(): faa.
     method returns an empty string:

          with open('mydata.txt') as fp:
              for line in iter(fp.readline, ''):
                  process_line(line)

 -- Function: len (s)

     Return the length (the number of items) of an object.  The argument
     may be a sequence (such as a string, bytes, tuple, list, or range)
     or a collection (such as a dictionary, set, or frozen set).

 -- Class: list ([iterable])

     Rather than being a function, *note list: 25d. is actually a
     mutable sequence type, as documented in *note Lists: fab. and *note
     Sequence Types — list, tuple, range: c32.

 -- Function: locals ()

     Update and return a dictionary representing the current local
     symbol table.  Free variables are returned by *note locals(): 9a8.
     when it is called in function blocks, but not in class blocks.

          Note: The contents of this dictionary should not be modified;
          changes may not affect the values of local and free variables
          used by the interpreter.

 -- Function: map (function, iterable, ...)

     Return an iterator that applies `function' to every item of
     `iterable', yielding the results.  If additional `iterable'
     arguments are passed, `function' must take that many arguments and
     is applied to the items from all iterables in parallel.  With
     multiple iterables, the iterator stops when the shortest iterable
     is exhausted.  For cases where the function inputs are already
     arranged into argument tuples, see *note itertools.starmap(): 659.

 -- Function: max (iterable, *[, key, default])

 -- Function: max (arg1, arg2, *args[, key])

     Return the largest item in an iterable or the largest of two or
     more arguments.

     If one positional argument is provided, it should be an *note
     iterable: 80a.  The largest item in the iterable is returned.  If
     two or more positional arguments are provided, the largest of the
     positional arguments is returned.

     There are two optional keyword-only arguments.  The `key' argument
     specifies a one-argument ordering function like that used for *note
     list.sort(): 84d.  The `default' argument specifies an object to
     return if the provided iterable is empty.  If the iterable is empty
     and `default' is not provided, a *note ValueError: 19c. is raised.

     If multiple items are maximal, the function returns the first one
     encountered.  This is consistent with other sort-stability
     preserving tools such as ‘sorted(iterable, key=keyfunc,
     reverse=True)[0]’ and ‘heapq.nlargest(1, iterable, key=keyfunc)’.

     New in version 3.4: The `default' keyword-only argument.

 -- Function: memoryview (obj)

     Return a "memory view" object created from the given argument.  See
     *note Memory Views: fac. for more information.

 -- Function: min (iterable, *[, key, default])

 -- Function: min (arg1, arg2, *args[, key])

     Return the smallest item in an iterable or the smallest of two or
     more arguments.

     If one positional argument is provided, it should be an *note
     iterable: 80a.  The smallest item in the iterable is returned.  If
     two or more positional arguments are provided, the smallest of the
     positional arguments is returned.

     There are two optional keyword-only arguments.  The `key' argument
     specifies a one-argument ordering function like that used for *note
     list.sort(): 84d.  The `default' argument specifies an object to
     return if the provided iterable is empty.  If the iterable is empty
     and `default' is not provided, a *note ValueError: 19c. is raised.

     If multiple items are minimal, the function returns the first one
     encountered.  This is consistent with other sort-stability
     preserving tools such as ‘sorted(iterable, key=keyfunc)[0]’ and
     ‘heapq.nsmallest(1, iterable, key=keyfunc)’.

     New in version 3.4: The `default' keyword-only argument.

 -- Function: next (iterator[, default])

     Retrieve the next item from the `iterator' by calling its *note
     __next__(): 8cf. method.  If `default' is given, it is returned if
     the iterator is exhausted, otherwise *note StopIteration: 191. is
     raised.

 -- Class: object

     Return a new featureless object.  *note object: 5cb. is a base for
     all classes.  It has the methods that are common to all instances
     of Python classes.  This function does not accept any arguments.

          Note: *note object: 5cb. does `not' have a *note __dict__:
          df4, so you can’t assign arbitrary attributes to an instance
          of the *note object: 5cb. class.

 -- Function: oct (x)

     Convert an integer number to an octal string.  The result is a
     valid Python expression.  If `x' is not a Python *note int: 227.
     object, it has to define an *note __index__(): 8d2. method that
     returns an integer.

 -- Function: open (file, mode='r', buffering=-1, encoding=None,
          errors=None, newline=None, closefd=True, opener=None)

     Open `file' and return a corresponding *note file object: 78b.  If
     the file cannot be opened, an *note OSError: 4b6. is raised.

     `file' is either a string or bytes object giving the pathname
     (absolute or relative to the current working directory) of the file
     to be opened or an integer file descriptor of the file to be
     wrapped.  (If a file descriptor is given, it is closed when the
     returned I/O object is closed, unless `closefd' is set to ‘False’.)

     `mode' is an optional string that specifies the mode in which the
     file is opened.  It defaults to ‘'r'’ which means open for reading
     in text mode.  Other common values are ‘'w'’ for writing
     (truncating the file if it already exists), ‘'x'’ for exclusive
     creation and ‘'a'’ for appending (which on `some' Unix systems,
     means that `all' writes append to the end of the file regardless of
     the current seek position).  In text mode, if `encoding' is not
     specified the encoding used is platform dependent:
     ‘locale.getpreferredencoding(False)’ is called to get the current
     locale encoding.  (For reading and writing raw bytes use binary
     mode and leave `encoding' unspecified.)  The available modes are:

     Character     Meaning
                   
     ----------------------------------------------------------------------------------
                   
     ‘'r'’         open for reading (default)
                   
                   
     ‘'w'’         open for writing, truncating the file first
                   
                   
     ‘'x'’         open for exclusive creation, failing if the file already exists
                   
                   
     ‘'a'’         open for writing, appending to the end of the file if it exists
                   
                   
     ‘'b'’         binary mode
                   
                   
     ‘'t'’         text mode (default)
                   
                   
     ‘'+'’         open a disk file for updating (reading and writing)
                   
                   
     ‘'U'’         *note universal newlines: 994. mode (deprecated)
                   

     The default mode is ‘'r'’ (open for reading text, synonym of
     ‘'rt'’).  For binary read-write access, the mode ‘'w+b'’ opens and
     truncates the file to 0 bytes.  ‘'r+b'’ opens the file without
     truncation.

     As mentioned in the *note Overview: fad, Python distinguishes
     between binary and text I/O. Files opened in binary mode (including
     ‘'b'’ in the `mode' argument) return contents as *note bytes: 1db.
     objects without any decoding.  In text mode (the default, or when
     ‘'t'’ is included in the `mode' argument), the contents of the file
     are returned as *note str: 25a, the bytes having been first decoded
     using a platform-dependent encoding or using the specified
     `encoding' if given.

          Note: Python doesn’t depend on the underlying operating
          system’s notion of text files; all the processing is done by
          Python itself, and is therefore platform-independent.

     `buffering' is an optional integer used to set the buffering
     policy.  Pass 0 to switch buffering off (only allowed in binary
     mode), 1 to select line buffering (only usable in text mode), and
     an integer > 1 to indicate the size in bytes of a fixed-size chunk
     buffer.  When no `buffering' argument is given, the default
     buffering policy works as follows:

        * Binary files are buffered in fixed-size chunks; the size of
          the buffer is chosen using a heuristic trying to determine the
          underlying device’s "block size" and falling back on *note
          io.DEFAULT_BUFFER_SIZE: fae.  On many systems, the buffer will
          typically be 4096 or 8192 bytes long.

        * "Interactive" text files (files for which *note isatty(): faf.
          returns ‘True’) use line buffering.  Other text files use the
          policy described above for binary files.

     `encoding' is the name of the encoding used to decode or encode the
     file.  This should only be used in text mode.  The default encoding
     is platform dependent (whatever *note
     locale.getpreferredencoding(): fb0. returns), but any *note text
     encoding: fb1. supported by Python can be used.  See the *note
     codecs: 1c. module for the list of supported encodings.

     `errors' is an optional string that specifies how encoding and
     decoding errors are to be handled–this cannot be used in binary
     mode.  A variety of standard error handlers are available (listed
     under *note Error Handlers: fb2.), though any error handling name
     that has been registered with *note codecs.register_error(): a74.
     is also valid.  The standard names include:

        * ‘'strict'’ to raise a *note ValueError: 19c. exception if
          there is an encoding error.  The default value of ‘None’ has
          the same effect.

        * ‘'ignore'’ ignores errors.  Note that ignoring encoding errors
          can lead to data loss.

        * ‘'replace'’ causes a replacement marker (such as ‘'?'’) to be
          inserted where there is malformed data.

        * ‘'surrogateescape'’ will represent any incorrect bytes as code
          points in the Unicode Private Use Area ranging from U+DC80 to
          U+DCFF. These private code points will then be turned back
          into the same bytes when the ‘surrogateescape’ error handler
          is used when writing data.  This is useful for processing
          files in an unknown encoding.

        * ‘'xmlcharrefreplace'’ is only supported when writing to a
          file.  Characters not supported by the encoding are replaced
          with the appropriate XML character reference ‘&#nnn;’.

        * ‘'backslashreplace'’ replaces malformed data by Python’s
          backslashed escape sequences.

        * ‘'namereplace'’ (also only supported when writing) replaces
          unsupported characters with ‘\N{...}’ escape sequences.

     `newline' controls how *note universal newlines: 994. mode works
     (it only applies to text mode).  It can be ‘None’, ‘''’, ‘'\n'’,
     ‘'\r'’, and ‘'\r\n'’.  It works as follows:

        * When reading input from the stream, if `newline' is ‘None’,
          universal newlines mode is enabled.  Lines in the input can
          end in ‘'\n'’, ‘'\r'’, or ‘'\r\n'’, and these are translated
          into ‘'\n'’ before being returned to the caller.  If it is
          ‘''’, universal newlines mode is enabled, but line endings are
          returned to the caller untranslated.  If it has any of the
          other legal values, input lines are only terminated by the
          given string, and the line ending is returned to the caller
          untranslated.

        * When writing output to the stream, if `newline' is ‘None’, any
          ‘'\n'’ characters written are translated to the system default
          line separator, *note os.linesep: fb3.  If `newline' is ‘''’
          or ‘'\n'’, no translation takes place.  If `newline' is any of
          the other legal values, any ‘'\n'’ characters written are
          translated to the given string.

     If `closefd' is ‘False’ and a file descriptor rather than a
     filename was given, the underlying file descriptor will be kept
     open when the file is closed.  If a filename is given `closefd'
     must be ‘True’ (the default) otherwise an error will be raised.

     A custom opener can be used by passing a callable as `opener'.  The
     underlying file descriptor for the file object is then obtained by
     calling `opener' with (`file', `flags').  `opener' must return an
     open file descriptor (passing *note os.open: 1f4. as `opener'
     results in functionality similar to passing ‘None’).

     The newly created file is *note non-inheritable: 3ea.

     The following example uses the *note dir_fd: 661. parameter of the
     *note os.open(): 1f4. function to open a file relative to a given
     directory:

          >>> import os
          >>> dir_fd = os.open('somedir', os.O_RDONLY)
          >>> def opener(path, flags):
          ...     return os.open(path, flags, dir_fd=dir_fd)
          ...
          >>> with open('spamspam.txt', 'w', opener=opener) as f:
          ...     print('This will be written to somedir/spamspam.txt', file=f)
          ...
          >>> os.close(dir_fd)  # don't leak a file descriptor

     The type of *note file object: 78b. returned by the *note open():
     1e8. function depends on the mode.  When *note open(): 1e8. is used
     to open a file in a text mode (‘'w'’, ‘'r'’, ‘'wt'’, ‘'rt'’, etc.),
     it returns a subclass of *note io.TextIOBase: 89f. (specifically
     *note io.TextIOWrapper: 557.).  When used to open a file in a
     binary mode with buffering, the returned class is a subclass of
     *note io.BufferedIOBase: 5fe.  The exact class varies: in read
     binary mode, it returns an *note io.BufferedReader: 7df.; in write
     binary and append binary modes, it returns an *note
     io.BufferedWriter: fb4, and in read/write mode, it returns an *note
     io.BufferedRandom: fb5.  When buffering is disabled, the raw
     stream, a subclass of *note io.RawIOBase: 640, *note io.FileIO:
     917, is returned.

     See also the file handling modules, such as, *note fileinput: 7e,
     *note io: 9f. (where *note open(): 1e8. is declared), *note os: c2,
     *note os.path: c3, *note tempfile: 101, and *note shutil: e7.

     Changed in version 3.3: The `opener' parameter was added.  The
     ‘'x'’ mode was added.  *note IOError: 5b0. used to be raised, it is
     now an alias of *note OSError: 4b6.  *note FileExistsError: 56f. is
     now raised if the file opened in exclusive creation mode (‘'x'’)
     already exists.

     Changed in version 3.4: The file is now non-inheritable.

     Deprecated since version 3.4, will be removed in version 4.0: The
     ‘'U'’ mode.

     Changed in version 3.5: If the system call is interrupted and the
     signal handler does not raise an exception, the function now
     retries the system call instead of raising an *note
     InterruptedError: 1e7. exception (see PEP 475(3) for the
     rationale).

     Changed in version 3.5: The ‘'namereplace'’ error handler was
     added.

 -- Function: ord (c)

     Given a string representing one Unicode character, return an
     integer representing the Unicode code point of that character.  For
     example, ‘ord('a')’ returns the integer ‘97’ and ‘ord('€')’ (Euro
     sign) returns ‘8364’.  This is the inverse of *note chr(): de7.

 -- Function: pow (x, y[, z])

     Return `x' to the power `y'; if `z' is present, return `x' to the
     power `y', modulo `z' (computed more efficiently than ‘pow(x, y) %
     z’).  The two-argument form ‘pow(x, y)’ is equivalent to using the
     power operator: ‘x**y’.

     The arguments must have numeric types.  With mixed operand types,
     the coercion rules for binary arithmetic operators apply.  For
     *note int: 227. operands, the result has the same type as the
     operands (after coercion) unless the second argument is negative;
     in that case, all arguments are converted to float and a float
     result is delivered.  For example, ‘10**2’ returns ‘100’, but
     ‘10**-2’ returns ‘0.01’.  If the second argument is negative, the
     third argument must be omitted.  If `z' is present, `x' and `y'
     must be of integer types, and `y' must be non-negative.

 -- Function: print (*objects, sep=' ', end='\n', file=sys.stdout,
          flush=False)

     Print `objects' to the text stream `file', separated by `sep' and
     followed by `end'.  `sep', `end' and `file', if present, must be
     given as keyword arguments.

     All non-keyword arguments are converted to strings like *note
     str(): 25a. does and written to the stream, separated by `sep' and
     followed by `end'.  Both `sep' and `end' must be strings; they can
     also be ‘None’, which means to use the default values.  If no
     `objects' are given, *note print(): 481. will just write `end'.

     The `file' argument must be an object with a ‘write(string)’
     method; if it is not present or ‘None’, *note sys.stdout: 1ba. will
     be used.  Since printed arguments are converted to text strings,
     *note print(): 481. cannot be used with binary mode file objects.
     For these, use ‘file.write(...)’ instead.

     Whether output is buffered is usually determined by `file', but if
     the `flush' keyword argument is true, the stream is forcibly
     flushed.

     Changed in version 3.3: Added the `flush' keyword argument.

 -- Class: property (fget=None, fset=None, fdel=None, doc=None)

     Return a property attribute.

     `fget' is a function for getting an attribute value.  `fset' is a
     function for setting an attribute value.  `fdel' is a function for
     deleting an attribute value.  And `doc' creates a docstring for the
     attribute.

     A typical use is to define a managed attribute ‘x’:

          class C:
              def __init__(self):
                  self._x = None

              def getx(self):
                  return self._x

              def setx(self, value):
                  self._x = value

              def delx(self):
                  del self._x

              x = property(getx, setx, delx, "I'm the 'x' property.")

     If `c' is an instance of `C', ‘c.x’ will invoke the getter, ‘c.x =
     value’ will invoke the setter and ‘del c.x’ the deleter.

     If given, `doc' will be the docstring of the property attribute.
     Otherwise, the property will copy `fget'’s docstring (if it
     exists).  This makes it possible to create read-only properties
     easily using *note property(): 377. as a *note decorator: f6c.:

          class Parrot:
              def __init__(self):
                  self._voltage = 100000

              @property
              def voltage(self):
                  """Get the current voltage."""
                  return self._voltage

     The ‘@property’ decorator turns the ‘voltage()’ method into a
     "getter" for a read-only attribute with the same name, and it sets
     the docstring for `voltage' to "Get the current voltage."

     A property object has ‘getter’, ‘setter’, and ‘deleter’ methods
     usable as decorators that create a copy of the property with the
     corresponding accessor function set to the decorated function.
     This is best explained with an example:

          class C:
              def __init__(self):
                  self._x = None

              @property
              def x(self):
                  """I'm the 'x' property."""
                  return self._x

              @x.setter
              def x(self, value):
                  self._x = value

              @x.deleter
              def x(self):
                  del self._x

     This code is exactly equivalent to the first example.  Be sure to
     give the additional functions the same name as the original
     property (‘x’ in this case.)

     The returned property object also has the attributes ‘fget’,
     ‘fset’, and ‘fdel’ corresponding to the constructor arguments.

     Changed in version 3.5: The docstrings of property objects are now
     writeable.

 -- Function: range (stop)

 -- Function: range (start, stop[, step])

     Rather than being a function, *note range: 5e0. is actually an
     immutable sequence type, as documented in *note Ranges: fb6. and
     *note Sequence Types — list, tuple, range: c32.

 -- Function: repr (object)

     Return a string containing a printable representation of an object.
     For many types, this function makes an attempt to return a string
     that would yield an object with the same value when passed to *note
     eval(): 7e8, otherwise the representation is a string enclosed in
     angle brackets that contains the name of the type of the object
     together with additional information often including the name and
     address of the object.  A class can control what this function
     returns for its instances by defining a *note __repr__(): 7bd.
     method.

 -- Function: reversed (seq)

     Return a reverse *note iterator: e4f.  `seq' must be an object
     which has a *note __reversed__(): e1f. method or supports the
     sequence protocol (the *note __len__(): a47. method and the *note
     __getitem__(): a84. method with integer arguments starting at ‘0’).

 -- Function: round (number[, ndigits])

     Return the floating point value `number' rounded to `ndigits'
     digits after the decimal point.  If `ndigits' is omitted, it
     returns the nearest integer to its input.  Delegates to
     ‘number.__round__(ndigits)’.

     For the built-in types supporting *note round(): 8d9, values are
     rounded to the closest multiple of 10 to the power minus `ndigits';
     if two multiples are equally close, rounding is done toward the
     even choice (so, for example, both ‘round(0.5)’ and ‘round(-0.5)’
     are ‘0’, and ‘round(1.5)’ is ‘2’).  The return value is an integer
     if called with one argument, otherwise of the same type as
     `number'.

          Note: The behavior of *note round(): 8d9. for floats can be
          surprising: for example, ‘round(2.675, 2)’ gives ‘2.67’
          instead of the expected ‘2.68’.  This is not a bug: it’s a
          result of the fact that most decimal fractions can’t be
          represented exactly as a float.  See *note Floating Point
          Arithmetic; Issues and Limitations: ce3. for more information.

 -- Class: set ([iterable])

     Return a new *note set: 7be. object, optionally with elements taken
     from `iterable'.  ‘set’ is a built-in class.  See *note set: 7be.
     and *note Set Types — set, frozenset: fa9. for documentation about
     this class.

     For other containers see the built-in *note frozenset: 84c, *note
     list: 25d, *note tuple: 25c, and *note dict: 3b0. classes, as well
     as the *note collections: 1e. module.

 -- Function: setattr (object, name, value)

     This is the counterpart of *note getattr(): 781.  The arguments are
     an object, a string and an arbitrary value.  The string may name an
     existing attribute or a new attribute.  The function assigns the
     value to the attribute, provided the object allows it.  For
     example, ‘setattr(x, 'foobar', 123)’ is equivalent to ‘x.foobar =
     123’.

 -- Class: slice (stop)

 -- Class: slice (start, stop[, step])

     Return a *note slice: fb7. object representing the set of indices
     specified by ‘range(start, stop, step)’.  The `start' and `step'
     arguments default to ‘None’.  Slice objects have read-only data
     attributes ‘start’, ‘stop’ and ‘step’ which merely return the
     argument values (or their default).  They have no other explicit
     functionality; however they are used by Numerical Python and other
     third party extensions.  Slice objects are also generated when
     extended indexing syntax is used.  For example:
     ‘a[start:stop:step]’ or ‘a[start:stop, i]’.  See *note
     itertools.islice(): a0d. for an alternate version that returns an
     iterator.

 -- Function: sorted (iterable[, key][, reverse])

     Return a new sorted list from the items in `iterable'.

     Has two optional arguments which must be specified as keyword
     arguments.

     `key' specifies a function of one argument that is used to extract
     a comparison key from each list element: ‘key=str.lower’.  The
     default value is ‘None’ (compare the elements directly).

     `reverse' is a boolean value.  If set to ‘True’, then the list
     elements are sorted as if each comparison were reversed.

     Use *note functools.cmp_to_key(): 7a0. to convert an old-style
     `cmp' function to a `key' function.

     The built-in *note sorted(): 84e. function is guaranteed to be
     stable.  A sort is stable if it guarantees not to change the
     relative order of elements that compare equal — this is helpful for
     sorting in multiple passes (for example, sort by department, then
     by salary grade).

     For sorting examples and a brief sorting tutorial, see *note
     Sorting HOW TO: fb8.

 -- Function: staticmethod (function)

     Return a static method for `function'.

     A static method does not receive an implicit first argument.  To
     declare a static method, use this idiom:

          class C:
              @staticmethod
              def f(arg1, arg2, ...): ...

     The ‘@staticmethod’ form is a function *note decorator: f6c. – see
     the description of function definitions in *note Function
     definitions: c1e. for details.

     It can be called either on the class (such as ‘C.f()’) or on an
     instance (such as ‘C().f()’).  The instance is ignored except for
     its class.

     Static methods in Python are similar to those found in Java or C++.
     Also see *note classmethod(): 5f4. for a variant that is useful for
     creating alternate class constructors.

     For more information on static methods, consult the documentation
     on the standard type hierarchy in *note The standard type
     hierarchy: de0.

 -- Class: str (object='')

 -- Class: str (object=b'', encoding='utf-8', errors='strict')

     Return a *note str: 25a. version of `object'.  See *note str():
     25a. for details.

     ‘str’ is the built-in string *note class: fb9.  For general
     information about strings, see *note Text Sequence Type — str: bea.

 -- Function: sum (iterable[, start])

     Sums `start' and the items of an `iterable' from left to right and
     returns the total.  `start' defaults to ‘0’.  The `iterable'’s
     items are normally numbers, and the start value is not allowed to
     be a string.

     For some use cases, there are good alternatives to *note sum():
     a60.  The preferred, fast way to concatenate a sequence of strings
     is by calling ‘''.join(sequence)’.  To add floating point values
     with extended precision, see *note math.fsum(): 9b4.  To
     concatenate a series of iterables, consider using *note
     itertools.chain(): fba.

 -- Function: super ([type[, object-or-type]])

     Return a proxy object that delegates method calls to a parent or
     sibling class of `type'.  This is useful for accessing inherited
     methods that have been overridden in a class.  The search order is
     same as that used by *note getattr(): 781. except that the `type'
     itself is skipped.

     The *note __mro__: fbb. attribute of the `type' lists the method
     resolution search order used by both *note getattr(): 781. and
     *note super(): 56a.  The attribute is dynamic and can change
     whenever the inheritance hierarchy is updated.

     If the second argument is omitted, the super object returned is
     unbound.  If the second argument is an object, ‘isinstance(obj,
     type)’ must be true.  If the second argument is a type,
     ‘issubclass(type2, type)’ must be true (this is useful for
     classmethods).

     There are two typical use cases for `super'.  In a class hierarchy
     with single inheritance, `super' can be used to refer to parent
     classes without naming them explicitly, thus making the code more
     maintainable.  This use closely parallels the use of `super' in
     other programming languages.

     The second use case is to support cooperative multiple inheritance
     in a dynamic execution environment.  This use case is unique to
     Python and is not found in statically compiled languages or
     languages that only support single inheritance.  This makes it
     possible to implement "diamond diagrams" where multiple base
     classes implement the same method.  Good design dictates that this
     method have the same calling signature in every case (because the
     order of calls is determined at runtime, because that order adapts
     to changes in the class hierarchy, and because that order can
     include sibling classes that are unknown prior to runtime).

     For both use cases, a typical superclass call looks like this:

          class C(B):
              def method(self, arg):
                  super().method(arg)    # This does the same thing as:
                                         # super(C, self).method(arg)

     Note that *note super(): 56a. is implemented as part of the binding
     process for explicit dotted attribute lookups such as
     ‘super().__getitem__(name)’.  It does so by implementing its own
     *note __getattribute__(): 783. method for searching classes in a
     predictable order that supports cooperative multiple inheritance.
     Accordingly, *note super(): 56a. is undefined for implicit lookups
     using statements or operators such as ‘super()[name]’.

     Also note that, aside from the zero argument form, *note super():
     56a. is not limited to use inside methods.  The two argument form
     specifies the arguments exactly and makes the appropriate
     references.  The zero argument form only works inside a class
     definition, as the compiler fills in the necessary details to
     correctly retrieve the class being defined, as well as accessing
     the current instance for ordinary methods.

     For practical suggestions on how to design cooperative classes
     using *note super(): 56a, see guide to using super()(4).

 -- Function: tuple ([iterable])

     Rather than being a function, *note tuple: 25c. is actually an
     immutable sequence type, as documented in *note Tuples: fbc. and
     *note Sequence Types — list, tuple, range: c32.

 -- Class: type (object)

 -- Class: type (name, bases, dict)

     With one argument, return the type of an `object'.  The return
     value is a type object and generally the same object as returned by
     *note object.__class__: df5.

     The *note isinstance(): 998. built-in function is recommended for
     testing the type of an object, because it takes subclasses into
     account.

     With three arguments, return a new type object.  This is
     essentially a dynamic form of the *note class: 8d6. statement.  The
     `name' string is the class name and becomes the *note __name__:
     fbd. attribute; the `bases' tuple itemizes the base classes and
     becomes the *note __bases__: df2. attribute; and the `dict'
     dictionary is the namespace containing definitions for class body
     and becomes the *note __dict__: df4. attribute.  For example, the
     following two statements create identical *note type: 376. objects:

          >>> class X:
          ...     a = 1
          ...
          >>> X = type('X', (object,), dict(a=1))

     See also *note Type Objects: fbe.

 -- Function: vars ([object])

     Return the *note __dict__: df4. attribute for a module, class,
     instance, or any other object with a ‘__dict__’ attribute.

     Objects such as modules and instances have an updateable ‘__dict__’
     attribute; however, other objects may have write restrictions on
     their ‘__dict__’ attributes (for example, classes use a dictproxy
     to prevent direct dictionary updates).

     Without an argument, *note vars(): c5a. acts like *note locals():
     9a8.  Note, the locals dictionary is only useful for reads since
     updates to the locals dictionary are ignored.

 -- Function: zip (*iterables)

     Make an iterator that aggregates elements from each of the
     iterables.

     Returns an iterator of tuples, where the `i'-th tuple contains the
     `i'-th element from each of the argument sequences or iterables.
     The iterator stops when the shortest input iterable is exhausted.
     With a single iterable argument, it returns an iterator of
     1-tuples.  With no arguments, it returns an empty iterator.
     Equivalent to:

          def zip(*iterables):
              # zip('ABCD', 'xy') --> Ax By
              sentinel = object()
              iterators = [iter(it) for it in iterables]
              while iterators:
                  result = []
                  for it in iterators:
                      elem = next(it, sentinel)
                      if elem is sentinel:
                          return
                      result.append(elem)
                  yield tuple(result)

     The left-to-right evaluation order of the iterables is guaranteed.
     This makes possible an idiom for clustering a data series into
     n-length groups using ‘zip(*[iter(s)]*n)’.  This repeats the `same'
     iterator ‘n’ times so that each output tuple has the result of ‘n’
     calls to the iterator.  This has the effect of dividing the input
     into n-length chunks.

     *note zip(): 897. should only be used with unequal length inputs
     when you don’t care about trailing, unmatched values from the
     longer iterables.  If those values are important, use *note
     itertools.zip_longest(): 896. instead.

     *note zip(): 897. in conjunction with the ‘*’ operator can be used
     to unzip a list:

          >>> x = [1, 2, 3]
          >>> y = [4, 5, 6]
          >>> zipped = zip(x, y)
          >>> list(zipped)
          [(1, 4), (2, 5), (3, 6)]
          >>> x2, y2 = zip(*zip(x, y))
          >>> x == list(x2) and y == list(y2)
          True

 -- Function: __import__ (name, globals=None, locals=None, fromlist=(),
          level=0)

          Note: This is an advanced function that is not needed in
          everyday Python programming, unlike *note
          importlib.import_module(): 754.

     This function is invoked by the *note import: 881. statement.  It
     can be replaced (by importing the *note builtins: 13. module and
     assigning to ‘builtins.__import__’) in order to change semantics of
     the *note import: 881. statement, but doing so is `strongly'
     discouraged as it is usually simpler to use import hooks (see PEP
     302(5)) to attain the same goals and does not cause issues with
     code which assumes the default import implementation is in use.
     Direct use of *note __import__(): 5cd. is also discouraged in favor
     of *note importlib.import_module(): 754.

     The function imports the module `name', potentially using the given
     `globals' and `locals' to determine how to interpret the name in a
     package context.  The `fromlist' gives the names of objects or
     submodules that should be imported from the module given by `name'.
     The standard implementation does not use its `locals' argument at
     all, and uses its `globals' only to determine the package context
     of the *note import: 881. statement.

     `level' specifies whether to use absolute or relative imports.  ‘0’
     (the default) means only perform absolute imports.  Positive values
     for `level' indicate the number of parent directories to search
     relative to the directory of the module calling *note __import__():
     5cd. (see PEP 328(6) for the details).

     When the `name' variable is of the form ‘package.module’, normally,
     the top-level package (the name up till the first dot) is returned,
     `not' the module named by `name'.  However, when a non-empty
     `fromlist' argument is given, the module named by `name' is
     returned.

     For example, the statement ‘import spam’ results in bytecode
     resembling the following code:

          spam = __import__('spam', globals(), locals(), [], 0)

     The statement ‘import spam.ham’ results in this call:

          spam = __import__('spam.ham', globals(), locals(), [], 0)

     Note how *note __import__(): 5cd. returns the toplevel module here
     because this is the object that is bound to a name by the *note
     import: 881. statement.

     On the other hand, the statement ‘from spam.ham import eggs,
     sausage as saus’ results in

          _temp = __import__('spam.ham', globals(), locals(), ['eggs', 'sausage'], 0)
          eggs = _temp.eggs
          saus = _temp.sausage

     Here, the ‘spam.ham’ module is returned from *note __import__():
     5cd.  From this object, the names to import are retrieved and
     assigned to their respective names.

     If you simply want to import a module (potentially within a
     package) by name, use *note importlib.import_module(): 754.

     Changed in version 3.3: Negative values for `level' are no longer
     supported (which also changes the default value to 0).

   ---------- Footnotes ----------

   (1) https://www.python.org/dev/peps/pep-0236

   (2) Note that the parser only accepts the Unix-style end of line
convention.  If you are reading the code from a file, make sure to use
newline conversion mode to convert Windows or Mac-style newlines.

   (3) https://www.python.org/dev/peps/pep-0475

   (4) 
https://rhettinger.wordpress.com/2011/05/26/super-considered-super/

   (5) https://www.python.org/dev/peps/pep-0302

   (6) https://www.python.org/dev/peps/pep-0328


File: python.info,  Node: Built-in Constants,  Next: Built-in Types,  Prev: Built-in Functions,  Up: The Python Standard Library

5.3 Built-in Constants
======================

A small number of constants live in the built-in namespace.  They are:

 -- Data: False

     The false value of the *note bool: a72. type.  Assignments to
     ‘False’ are illegal and raise a *note SyntaxError: 3a6.

 -- Data: True

     The true value of the *note bool: a72. type.  Assignments to ‘True’
     are illegal and raise a *note SyntaxError: 3a6.

 -- Data: None

     The sole value of the type ‘NoneType’.  ‘None’ is frequently used
     to represent the absence of a value, as when default arguments are
     not passed to a function.  Assignments to ‘None’ are illegal and
     raise a *note SyntaxError: 3a6.

 -- Data: NotImplemented

     Special value which should be returned by the binary special
     methods (e.g.  *note __eq__(): 89a, *note __lt__(): 899, *note
     __add__(): e19, *note __rsub__(): e2d, etc.)  to indicate that the
     operation is not implemented with respect to the other type; may be
     returned by the in-place binary special methods (e.g.  *note
     __imul__(): e1d, *note __iand__(): e3d, etc.)  for the same
     purpose.  Its truth value is true.

     Note: When ‘NotImplemented’ is returned, the interpreter will then
     try the reflected operation on the other type, or some other
     fallback, depending on the operator.  If all attempted operations
     return ‘NotImplemented’, the interpreter will raise an appropriate
     exception.

     See *note Implementing the arithmetic operations: de1. for more
     details.

 -- Data: Ellipsis

     The same as ‘...’.  Special value used mostly in conjunction with
     extended slicing syntax for user-defined container data types.

 -- Data: __debug__

     This constant is true if Python was not started with an *note -O:
     221. option.  See also the *note assert: a87. statement.

     Note: The names *note None: 19d, *note False: 60d, *note True: 9ff.
     and *note __debug__: f2f. cannot be reassigned (assignments to
     them, even as an attribute name, raise *note SyntaxError: 3a6.), so
     they can be considered "true" constants.

* Menu:

* Constants added by the site module:: 


File: python.info,  Node: Constants added by the site module,  Up: Built-in Constants

5.3.1 Constants added by the ‘site’ module
------------------------------------------

The *note site: e9. module (which is imported automatically during
startup, except if the *note -S: 766. command-line option is given) adds
several constants to the built-in namespace.  They are useful for the
interactive interpreter shell and should not be used in programs.

 -- Data: quit (code=None)
 -- Data: exit (code=None)

     Objects that when printed, print a message like "Use quit() or
     Ctrl-D (i.e.  EOF) to exit", and when called, raise *note
     SystemExit: 1a2. with the specified exit code.

 -- Data: copyright
 -- Data: license
 -- Data: credits

     Objects that when printed, print a message like "Type license() to
     see the full license text", and when called, display the
     corresponding text in a pager-like fashion (one screen at a time).


File: python.info,  Node: Built-in Types,  Next: Built-in Exceptions,  Prev: Built-in Constants,  Up: The Python Standard Library

5.4 Built-in Types
==================

The following sections describe the standard types that are built into
the interpreter.

The principal built-in types are numerics, sequences, mappings, classes,
instances and exceptions.

Some collection classes are mutable.  The methods that add, subtract, or
rearrange their members in place, and don’t return a specific item,
never return the collection instance itself but ‘None’.

Some operations are supported by several object types; in particular,
practically all objects can be compared, tested for truth value, and
converted to a string (with the *note repr(): 3bb. function or the
slightly different *note str(): 25a. function).  The latter function is
implicitly used when an object is written by the *note print(): 481.
function.

* Menu:

* Truth Value Testing:: 
* Boolean Operations: Boolean Operations --- and or not. and, or, not
* Comparisons: Comparisons<2>. 
* Numeric Types: Numeric Types --- int float complex. int, float, complex
* Iterator Types:: 
* Sequence Types: Sequence Types --- list tuple range. list, tuple, range
* Text Sequence Type: Text Sequence Type --- str. str
* Binary Sequence Types: Binary Sequence Types --- bytes bytearray memoryview. bytes, bytearray, memoryview
* Set Types: Set Types --- set frozenset. set, frozenset
* Mapping Types: Mapping Types --- dict. dict
* Context Manager Types:: 
* Other Built-in Types:: 
* Special Attributes:: 


File: python.info,  Node: Truth Value Testing,  Next: Boolean Operations --- and or not,  Up: Built-in Types

5.4.1 Truth Value Testing
-------------------------

Any object can be tested for truth value, for use in an *note if: a65.
or *note while: bf3. condition or as operand of the Boolean operations
below.  The following values are considered false:

   * ‘None’

   * ‘False’

   * zero of any numeric type, for example, ‘0’, ‘0.0’, ‘0j’.

   * any empty sequence, for example, ‘''’, ‘()’, ‘[]’.

   * any empty mapping, for example, ‘{}’.

   * instances of user-defined classes, if the class defines a *note
     __bool__(): 8d4. or *note __len__(): a47. method, when that method
     returns the integer zero or *note bool: a72. value ‘False’.  (1)

All other values are considered true — so objects of many types are
always true.

Operations and built-in functions that have a Boolean result always
return ‘0’ or ‘False’ for false and ‘1’ or ‘True’ for true, unless
otherwise stated.  (Important exception: the Boolean operations ‘or’ and
‘and’ always return one of their operands.)

   ---------- Footnotes ----------

   (1) Additional information on these special methods may be found in
the Python Reference Manual (*note Basic customization: dfa.).


File: python.info,  Node: Boolean Operations --- and or not,  Next: Comparisons<2>,  Prev: Truth Value Testing,  Up: Built-in Types

5.4.2 Boolean Operations — ‘and’, ‘or’, ‘not’
---------------------------------------------

These are the Boolean operations, ordered by ascending priority:

Operation         Result                                Notes
                                                        
--------------------------------------------------------------------
                                                        
‘x or y’          if `x' is false, then `y', else `x'   (1)
                                                        
                                                        
‘x and y’         if `x' is false, then `x', else `y'   (2)
                                                        
                                                        
‘not x’           if `x' is false, then ‘True’, else    (3)
                  ‘False’                               
                  

Notes:

  1. This is a short-circuit operator, so it only evaluates the second
     argument if the first one is *note False: 60d.

  2. This is a short-circuit operator, so it only evaluates the second
     argument if the first one is *note True: 9ff.

  3. ‘not’ has a lower priority than non-Boolean operators, so ‘not a ==
     b’ is interpreted as ‘not (a == b)’, and ‘a == not b’ is a syntax
     error.


File: python.info,  Node: Comparisons<2>,  Next: Numeric Types --- int float complex,  Prev: Boolean Operations --- and or not,  Up: Built-in Types

5.4.3 Comparisons
-----------------

There are eight comparison operations in Python.  They all have the same
priority (which is higher than that of the Boolean operations).
Comparisons can be chained arbitrarily; for example, ‘x < y <= z’ is
equivalent to ‘x < y and y <= z’, except that `y' is evaluated only once
(but in both cases `z' is not evaluated at all when ‘x < y’ is found to
be false).

This table summarizes the comparison operations:

Operation        Meaning
                 
-----------------------------------------------
                 
‘<’              strictly less than
                 
                 
‘<=’             less than or equal
                 
                 
‘>’              strictly greater than
                 
                 
‘>=’             greater than or equal
                 
                 
‘==’             equal
                 
                 
‘!=’             not equal
                 
                 
‘is’             object identity
                 
                 
‘is not’         negated object identity
                 

Objects of different types, except different numeric types, never
compare equal.  Furthermore, some types (for example, function objects)
support only a degenerate notion of comparison where any two objects of
that type are unequal.  The ‘<’, ‘<=’, ‘>’ and ‘>=’ operators will raise
a *note TypeError: 562. exception when comparing a complex number with
another built-in numeric type, when the objects are of different types
that cannot be compared, or in other cases where there is no defined
ordering.

Non-identical instances of a class normally compare as non-equal unless
the class defines the *note __eq__(): 89a. method.

Instances of a class cannot be ordered with respect to other instances
of the same class, or other types of object, unless the class defines
enough of the methods *note __lt__(): 899, *note __le__(): 913, *note
__gt__(): 914, and *note __ge__(): 915. (in general, *note __lt__():
899. and *note __eq__(): 89a. are sufficient, if you want the
conventional meanings of the comparison operators).

The behavior of the *note is: dde. and *note is not: f03. operators
cannot be customized; also they can be applied to any two objects and
never raise an exception.

Two more operations with the same syntactic priority, *note in: 37d. and
*note not in: e20, are supported only by sequence types (below).


File: python.info,  Node: Numeric Types --- int float complex,  Next: Iterator Types,  Prev: Comparisons<2>,  Up: Built-in Types

5.4.4 Numeric Types — ‘int’, ‘float’, ‘complex’
-----------------------------------------------

There are three distinct numeric types: `integers', `floating point
numbers', and `complex numbers'.  In addition, Booleans are a subtype of
integers.  Integers have unlimited precision.  Floating point numbers
are usually implemented using ‘double’ in C; information about the
precision and internal representation of floating point numbers for the
machine on which your program is running is available in *note
sys.float_info: fd2.  Complex numbers have a real and imaginary part,
which are each a floating point number.  To extract these parts from a
complex number `z', use ‘z.real’ and ‘z.imag’.  (The standard library
includes additional numeric types, *note fractions: 82. that hold
rationals, and *note decimal: 34. that hold floating-point numbers with
user-definable precision.)

Numbers are created by numeric literals or as the result of built-in
functions and operators.  Unadorned integer literals (including hex,
octal and binary numbers) yield integers.  Numeric literals containing a
decimal point or an exponent sign yield floating point numbers.
Appending ‘'j'’ or ‘'J'’ to a numeric literal yields an imaginary number
(a complex number with a zero real part) which you can add to an integer
or float to get a complex number with real and imaginary parts.

Python fully supports mixed arithmetic: when a binary arithmetic
operator has operands of different numeric types, the operand with the
"narrower" type is widened to that of the other, where integer is
narrower than floating point, which is narrower than complex.
Comparisons between numbers of mixed type use the same rule.  (1) The
constructors *note int(): 227, *note float(): 57a, and *note complex():
579. can be used to produce numbers of a specific type.

All numeric types (except complex) support the following operations,
sorted by ascending priority (all numeric operations have a higher
priority than comparison operations):

Operation                 Result                                Notes         Full documentation
                                                                              
-------------------------------------------------------------------------------------------------------
                                                                              
‘x + y’                   sum of `x' and `y'
                          
                                                                              
‘x - y’                   difference of `x' and `y'
                          
                                                                              
‘x * y’                   product of `x' and `y'
                          
                                                                              
‘x / y’                   quotient of `x' and `y'
                          
                                                                              
‘x // y’                  floored quotient of `x' and `y'       (1)
                                                                
                                                                              
‘x % y’                   remainder of ‘x / y’                  (2)
                                                                
                                                                              
‘-x’                      `x' negated
                          
                                                                              
‘+x’                      `x' unchanged
                          
                                                                              
‘abs(x)’                  absolute value or magnitude of `x'                  *note abs(): c7c.
                                                                              
                                                                              
‘int(x)’                  `x' converted to integer              (3)(6)        *note int(): 227.
                                                                              
                                                                              
‘float(x)’                `x' converted to floating point       (4)(6)        *note float(): 57a.
                                                                              
                                                                              
‘complex(re, im)’         a complex number with real part       (6)           *note complex(): 579.
                          `re', imaginary part `im'.  `im'                    
                          defaults to zero.
                          
                                                                              
‘c.conjugate()’           conjugate of the complex number `c'
                          
                                                                              
‘divmod(x, y)’            the pair ‘(x // y, x % y)’            (2)           *note divmod(): e2c.
                                                                              
                                                                              
‘pow(x, y)’               `x' to the power `y'                  (5)           *note pow(): ad3.
                                                                              
                                                                              
‘x ** y’                  `x' to the power `y'                  (5)
                                                                

Notes:

  1. Also referred to as integer division.  The resultant value is a
     whole integer, though the result’s type is not necessarily int.
     The result is always rounded towards minus infinity: ‘1//2’ is ‘0’,
     ‘(-1)//2’ is ‘-1’, ‘1//(-2)’ is ‘-1’, and ‘(-1)//(-2)’ is ‘0’.

  2. Not for complex numbers.  Instead convert to floats using *note
     abs(): c7c. if appropriate.

  3. 
     Conversion from floating point to integer may round or truncate as
     in C; see functions *note math.floor(): 9a0. and *note math.ceil():
     9a1. for well-defined conversions.

  4. float also accepts the strings "nan" and "inf" with an optional
     prefix "+" or "-" for Not a Number (NaN) and positive or negative
     infinity.

  5. Python defines ‘pow(0, 0)’ and ‘0 ** 0’ to be ‘1’, as is common for
     programming languages.

  6. The numeric literals accepted include the digits ‘0’ to ‘9’ or any
     Unicode equivalent (code points with the ‘Nd’ property).

     See
     ‘http://www.unicode.org/Public/8.0.0/ucd/extracted/DerivedNumericType.txt’
     for a complete list of code points with the ‘Nd’ property.

All *note numbers.Real: de4. types (*note int: 227. and *note float:
57a.) also include the following operations:

Operation                Result                                   Notes
                                                                  
-------------------------------------------------------------------------------
                                                                  
‘math.trunc(x)’          `x' truncated to Integral
                         
                                                                  
‘round(x[, n])’          `x' rounded to n digits, rounding half
                         to even.  If n is omitted, it defaults
                         to 0.
                         
                                                                  
‘math.floor(x)’          the greatest integral float <= `x'
                         
                                                                  
‘math.ceil(x)’           the least integral float >= `x'
                         

For additional numeric operations see the *note math: b0. and *note
cmath: 19. modules.

* Menu:

* Bitwise Operations on Integer Types:: 
* Additional Methods on Integer Types:: 
* Additional Methods on Float:: 
* Hashing of numeric types:: 

   ---------- Footnotes ----------

   (1) As a consequence, the list ‘[1, 2]’ is considered equal to ‘[1.0,
2.0]’, and similarly for tuples.


File: python.info,  Node: Bitwise Operations on Integer Types,  Next: Additional Methods on Integer Types,  Up: Numeric Types --- int float complex

5.4.4.1 Bitwise Operations on Integer Types
...........................................

Bitwise operations only make sense for integers.  Negative numbers are
treated as their 2’s complement value (this assumes that there are
enough bits so that no overflow occurs during the operation).

The priorities of the binary bitwise operations are all lower than the
numeric operations and higher than the comparisons; the unary operation
‘~’ has the same priority as the other unary numeric operations (‘+’ and
‘-’).

This table lists the bitwise operations sorted in ascending priority:

Operation        Result                               Notes
                                                      
---------------------------------------------------------------------
                                                      
‘x | y’          bitwise `or' of `x' and `y'
                 
                                                      
‘x ^ y’          bitwise `exclusive or' of `x' and
                 `y'
                 
                                                      
‘x & y’          bitwise `and' of `x' and `y'
                 
                                                      
‘x << n’         `x' shifted left by `n' bits         (1)(2)
                                                      
                                                      
‘x >> n’         `x' shifted right by `n' bits        (1)(3)
                                                      
                                                      
‘~x’             the bits of `x' inverted
                 

Notes:

  1. Negative shift counts are illegal and cause a *note ValueError:
     19c. to be raised.

  2. A left shift by `n' bits is equivalent to multiplication by ‘pow(2,
     n)’ without overflow check.

  3. A right shift by `n' bits is equivalent to division by ‘pow(2, n)’
     without overflow check.


File: python.info,  Node: Additional Methods on Integer Types,  Next: Additional Methods on Float,  Prev: Bitwise Operations on Integer Types,  Up: Numeric Types --- int float complex

5.4.4.2 Additional Methods on Integer Types
...........................................

The int type implements the *note numbers.Integral: de3. *note abstract
base class: 776.  In addition, it provides a few more methods:

 -- Method: int.bit_length ()

     Return the number of bits necessary to represent an integer in
     binary, excluding the sign and leading zeros:

          >>> n = -37
          >>> bin(n)
          '-0b100101'
          >>> n.bit_length()
          6

     More precisely, if ‘x’ is nonzero, then ‘x.bit_length()’ is the
     unique positive integer ‘k’ such that ‘2**(k-1) <= abs(x) < 2**k’.
     Equivalently, when ‘abs(x)’ is small enough to have a correctly
     rounded logarithm, then ‘k = 1 + int(log(abs(x), 2))’.  If ‘x’ is
     zero, then ‘x.bit_length()’ returns ‘0’.

     Equivalent to:

          def bit_length(self):
              s = bin(self)       # binary representation:  bin(-37) --> '-0b100101'
              s = s.lstrip('-0b') # remove leading zeros and minus sign
              return len(s)       # len('100101') --> 6

     New in version 3.1.

 -- Method: int.to_bytes (length, byteorder, *, signed=False)

     Return an array of bytes representing an integer.

          >>> (1024).to_bytes(2, byteorder='big')
          b'\x04\x00'
          >>> (1024).to_bytes(10, byteorder='big')
          b'\x00\x00\x00\x00\x00\x00\x00\x00\x04\x00'
          >>> (-1024).to_bytes(10, byteorder='big', signed=True)
          b'\xff\xff\xff\xff\xff\xff\xff\xff\xfc\x00'
          >>> x = 1000
          >>> x.to_bytes((x.bit_length() // 8) + 1, byteorder='little')
          b'\xe8\x03'

     The integer is represented using `length' bytes.  An *note
     OverflowError: 578. is raised if the integer is not representable
     with the given number of bytes.

     The `byteorder' argument determines the byte order used to
     represent the integer.  If `byteorder' is ‘"big"’, the most
     significant byte is at the beginning of the byte array.  If
     `byteorder' is ‘"little"’, the most significant byte is at the end
     of the byte array.  To request the native byte order of the host
     system, use *note sys.byteorder: fd8. as the byte order value.

     The `signed' argument determines whether two’s complement is used
     to represent the integer.  If `signed' is ‘False’ and a negative
     integer is given, an *note OverflowError: 578. is raised.  The
     default value for `signed' is ‘False’.

     New in version 3.2.

 -- Class Method: int.from_bytes (bytes, byteorder, *, signed=False)

     Return the integer represented by the given array of bytes.

          >>> int.from_bytes(b'\x00\x10', byteorder='big')
          16
          >>> int.from_bytes(b'\x00\x10', byteorder='little')
          4096
          >>> int.from_bytes(b'\xfc\x00', byteorder='big', signed=True)
          -1024
          >>> int.from_bytes(b'\xfc\x00', byteorder='big', signed=False)
          64512
          >>> int.from_bytes([255, 0, 0], byteorder='big')
          16711680

     The argument `bytes' must either be a *note bytes-like object: 36b.
     or an iterable producing bytes.

     The `byteorder' argument determines the byte order used to
     represent the integer.  If `byteorder' is ‘"big"’, the most
     significant byte is at the beginning of the byte array.  If
     `byteorder' is ‘"little"’, the most significant byte is at the end
     of the byte array.  To request the native byte order of the host
     system, use *note sys.byteorder: fd8. as the byte order value.

     The `signed' argument indicates whether two’s complement is used to
     represent the integer.

     New in version 3.2.


File: python.info,  Node: Additional Methods on Float,  Next: Hashing of numeric types,  Prev: Additional Methods on Integer Types,  Up: Numeric Types --- int float complex

5.4.4.3 Additional Methods on Float
...................................

The float type implements the *note numbers.Real: de4. *note abstract
base class: 776.  float also has the following additional methods.

 -- Method: float.as_integer_ratio ()

     Return a pair of integers whose ratio is exactly equal to the
     original float and with a positive denominator.  Raises *note
     OverflowError: 578. on infinities and a *note ValueError: 19c. on
     NaNs.

 -- Method: float.is_integer ()

     Return ‘True’ if the float instance is finite with integral value,
     and ‘False’ otherwise:

          >>> (-2.0).is_integer()
          True
          >>> (3.2).is_integer()
          False

Two methods support conversion to and from hexadecimal strings.  Since
Python’s floats are stored internally as binary numbers, converting a
float to or from a `decimal' string usually involves a small rounding
error.  In contrast, hexadecimal strings allow exact representation and
specification of floating-point numbers.  This can be useful when
debugging, and in numerical work.

 -- Method: float.hex ()

     Return a representation of a floating-point number as a hexadecimal
     string.  For finite floating-point numbers, this representation
     will always include a leading ‘0x’ and a trailing ‘p’ and exponent.

 -- Class Method: float.fromhex (s)

     Class method to return the float represented by a hexadecimal
     string `s'.  The string `s' may have leading and trailing
     whitespace.

Note that *note float.hex(): ce5. is an instance method, while *note
float.fromhex(): fdc. is a class method.

A hexadecimal string takes the form:

     [sign] ['0x'] integer ['.' fraction] ['p' exponent]

where the optional ‘sign’ may by either ‘+’ or ‘-’, ‘integer’ and
‘fraction’ are strings of hexadecimal digits, and ‘exponent’ is a
decimal integer with an optional leading sign.  Case is not significant,
and there must be at least one hexadecimal digit in either the integer
or the fraction.  This syntax is similar to the syntax specified in
section 6.4.4.2 of the C99 standard, and also to the syntax used in Java
1.5 onwards.  In particular, the output of *note float.hex(): ce5. is
usable as a hexadecimal floating-point literal in C or Java code, and
hexadecimal strings produced by C’s ‘%a’ format character or Java’s
‘Double.toHexString’ are accepted by *note float.fromhex(): fdc.

Note that the exponent is written in decimal rather than hexadecimal,
and that it gives the power of 2 by which to multiply the coefficient.
For example, the hexadecimal string ‘0x3.a7p10’ represents the
floating-point number ‘(3 + 10./16 + 7./16**2) * 2.0**10’, or ‘3740.0’:

     >>> float.fromhex('0x3.a7p10')
     3740.0

Applying the reverse conversion to ‘3740.0’ gives a different
hexadecimal string representing the same number:

     >>> float.hex(3740.0)
     '0x1.d380000000000p+11'


File: python.info,  Node: Hashing of numeric types,  Prev: Additional Methods on Float,  Up: Numeric Types --- int float complex

5.4.4.4 Hashing of numeric types
................................

For numbers ‘x’ and ‘y’, possibly of different types, it’s a requirement
that ‘hash(x) == hash(y)’ whenever ‘x == y’ (see the *note __hash__():
5e7. method documentation for more details).  For ease of implementation
and efficiency across a variety of numeric types (including *note int:
227, *note float: 57a, *note decimal.Decimal: 618. and *note
fractions.Fraction: 378.) Python’s hash for numeric types is based on a
single mathematical function that’s defined for any rational number, and
hence applies to all instances of *note int: 227. and *note
fractions.Fraction: 378, and all finite instances of *note float: 57a.
and *note decimal.Decimal: 618.  Essentially, this function is given by
reduction modulo ‘P’ for a fixed prime ‘P’.  The value of ‘P’ is made
available to Python as the ‘modulus’ attribute of *note sys.hash_info:
528.

`CPython implementation detail:' Currently, the prime used is ‘P = 2**31
- 1’ on machines with 32-bit C longs and ‘P = 2**61 - 1’ on machines
with 64-bit C longs.

Here are the rules in detail:

   - If ‘x = m / n’ is a nonnegative rational number and ‘n’ is not
     divisible by ‘P’, define ‘hash(x)’ as ‘m * invmod(n, P) % P’, where
     ‘invmod(n, P)’ gives the inverse of ‘n’ modulo ‘P’.

   - If ‘x = m / n’ is a nonnegative rational number and ‘n’ is
     divisible by ‘P’ (but ‘m’ is not) then ‘n’ has no inverse modulo
     ‘P’ and the rule above doesn’t apply; in this case define ‘hash(x)’
     to be the constant value ‘sys.hash_info.inf’.

   - If ‘x = m / n’ is a negative rational number define ‘hash(x)’ as
     ‘-hash(-x)’.  If the resulting hash is ‘-1’, replace it with ‘-2’.

   - The particular values ‘sys.hash_info.inf’, ‘-sys.hash_info.inf’ and
     ‘sys.hash_info.nan’ are used as hash values for positive infinity,
     negative infinity, or nans (respectively).  (All hashable nans have
     the same hash value.)

   - For a *note complex: 579. number ‘z’, the hash values of the real
     and imaginary parts are combined by computing ‘hash(z.real) +
     sys.hash_info.imag * hash(z.imag)’, reduced modulo
     ‘2**sys.hash_info.width’ so that it lies in
     ‘range(-2**(sys.hash_info.width - 1), 2**(sys.hash_info.width -
     1))’.  Again, if the result is ‘-1’, it’s replaced with ‘-2’.

To clarify the above rules, here’s some example Python code, equivalent
to the built-in hash, for computing the hash of a rational number, *note
float: 57a, or *note complex: 579.:

     import sys, math

     def hash_fraction(m, n):
         """Compute the hash of a rational number m / n.

         Assumes m and n are integers, with n positive.
         Equivalent to hash(fractions.Fraction(m, n)).

         """
         P = sys.hash_info.modulus
         # Remove common factors of P.  (Unnecessary if m and n already coprime.)
         while m % P == n % P == 0:
             m, n = m // P, n // P

         if n % P == 0:
             hash_ = sys.hash_info.inf
         else:
             # Fermat's Little Theorem: pow(n, P-1, P) is 1, so
             # pow(n, P-2, P) gives the inverse of n modulo P.
             hash_ = (abs(m) % P) * pow(n, P - 2, P) % P
         if m < 0:
             hash_ = -hash_
         if hash_ == -1:
             hash_ = -2
         return hash_

     def hash_float(x):
         """Compute the hash of a float x."""

         if math.isnan(x):
             return sys.hash_info.nan
         elif math.isinf(x):
             return sys.hash_info.inf if x > 0 else -sys.hash_info.inf
         else:
             return hash_fraction(*x.as_integer_ratio())

     def hash_complex(z):
         """Compute the hash of a complex number z."""

         hash_ = hash_float(z.real) + sys.hash_info.imag * hash_float(z.imag)
         # do a signed reduction modulo 2**sys.hash_info.width
         M = 2**(sys.hash_info.width - 1)
         hash_ = (hash_ & (M - 1)) - (hash & M)
         if hash_ == -1:
             hash_ == -2
         return hash_


File: python.info,  Node: Iterator Types,  Next: Sequence Types --- list tuple range,  Prev: Numeric Types --- int float complex,  Up: Built-in Types

5.4.5 Iterator Types
--------------------

Python supports a concept of iteration over containers.  This is
implemented using two distinct methods; these are used to allow
user-defined classes to support iteration.  Sequences, described below
in more detail, always support the iteration methods.

One method needs to be defined for container objects to provide
iteration support:

 -- Method: container.__iter__ ()

     Return an iterator object.  The object is required to support the
     iterator protocol described below.  If a container supports
     different types of iteration, additional methods can be provided to
     specifically request iterators for those iteration types.  (An
     example of an object supporting multiple forms of iteration would
     be a tree structure which supports both breadth-first and
     depth-first traversal.)  This method corresponds to the *note
     tp_iter: ab2. slot of the type structure for Python objects in the
     Python/C API.

The iterator objects themselves are required to support the following
two methods, which together form the `iterator protocol':

 -- Method: iterator.__iter__ ()

     Return the iterator object itself.  This is required to allow both
     containers and iterators to be used with the *note for: 895. and
     *note in: 37d. statements.  This method corresponds to the *note
     tp_iter: ab2. slot of the type structure for Python objects in the
     Python/C API.

 -- Method: iterator.__next__ ()

     Return the next item from the container.  If there are no further
     items, raise the *note StopIteration: 191. exception.  This method
     corresponds to the *note tp_iternext: ab3. slot of the type
     structure for Python objects in the Python/C API.

Python defines several iterator objects to support iteration over
general and specific sequence types, dictionaries, and other more
specialized forms.  The specific types are not important beyond their
implementation of the iterator protocol.

Once an iterator’s *note __next__(): 8cf. method raises *note
StopIteration: 191, it must continue to do so on subsequent calls.
Implementations that do not obey this property are deemed broken.

* Menu:

* Generator Types:: 


File: python.info,  Node: Generator Types,  Up: Iterator Types

5.4.5.1 Generator Types
.......................

Python’s *note generator: 5c0.s provide a convenient way to implement
the iterator protocol.  If a container object’s *note __iter__(): 99b.
method is implemented as a generator, it will automatically return an
iterator object (technically, a generator object) supplying the *note
__iter__(): 99b. and *note __next__(): c99. methods.  More information
about generators can be found in *note the documentation for the yield
expression: ec6.


File: python.info,  Node: Sequence Types --- list tuple range,  Next: Text Sequence Type --- str,  Prev: Iterator Types,  Up: Built-in Types

5.4.6 Sequence Types — ‘list’, ‘tuple’, ‘range’
-----------------------------------------------

There are three basic sequence types: lists, tuples, and range objects.
Additional sequence types tailored for processing of *note binary data:
f9f. and *note text strings: bea. are described in dedicated sections.

* Menu:

* Common Sequence Operations:: 
* Immutable Sequence Types:: 
* Mutable Sequence Types:: 
* Lists: Lists<2>. 
* Tuples:: 
* Ranges:: 


File: python.info,  Node: Common Sequence Operations,  Next: Immutable Sequence Types,  Up: Sequence Types --- list tuple range

5.4.6.1 Common Sequence Operations
..................................

The operations in the following table are supported by most sequence
types, both mutable and immutable.  The *note collections.abc.Sequence:
fe7. ABC is provided to make it easier to correctly implement these
operations on custom sequence types.

This table lists the sequence operations sorted in ascending priority.
In the table, `s' and `t' are sequences of the same type, `n', `i', `j'
and `k' are integers and `x' is an arbitrary object that meets any type
and value restrictions imposed by `s'.

The ‘in’ and ‘not in’ operations have the same priorities as the
comparison operations.  The ‘+’ (concatenation) and ‘*’ (repetition)
operations have the same priority as the corresponding numeric
operations.

Operation                      Result                               Notes
                                                                    
-----------------------------------------------------------------------------------
                                                                    
‘x in s’                       ‘True’ if an item of `s' is equal    (1)
                               to `x', else ‘False’                 
                               
                                                                    
‘x not in s’                   ‘False’ if an item of `s' is equal   (1)
                               to `x', else ‘True’                  
                               
                                                                    
‘s + t’                        the concatenation of `s' and `t'     (6)(7)
                                                                    
                                                                    
‘s * n’ or ‘n * s’             equivalent to adding `s' to itself   (2)(7)
                               `n' times                            
                               
                                                                    
‘s[i]’                         `i'th item of `s', origin 0          (3)
                                                                    
                                                                    
‘s[i:j]’                       slice of `s' from `i' to `j'         (3)(4)
                                                                    
                                                                    
‘s[i:j:k]’                     slice of `s' from `i' to `j' with    (3)(5)
                               step `k'                             
                               
                                                                    
‘len(s)’                       length of `s'
                               
                                                                    
‘min(s)’                       smallest item of `s'
                               
                                                                    
‘max(s)’                       largest item of `s'
                               
                                                                    
‘s.index(x[, i[, j]])’         index of the first occurrence of     (8)
                               `x' in `s' (at or after index `i'    
                               and before index `j')
                               
                                                                    
‘s.count(x)’                   total number of occurrences of `x'
                               in `s'
                               

Sequences of the same type also support comparisons.  In particular,
tuples and lists are compared lexicographically by comparing
corresponding elements.  This means that to compare equal, every element
must compare equal and the two sequences must be of the same type and
have the same length.  (For full details see *note Comparisons: efc. in
the language reference.)

Notes:

  1. While the ‘in’ and ‘not in’ operations are used only for simple
     containment testing in the general case, some specialised sequences
     (such as *note str: 25a, *note bytes: 1db. and *note bytearray:
     1dc.) also use them for subsequence testing:

          >>> "gg" in "eggs"
          True

  2. Values of `n' less than ‘0’ are treated as ‘0’ (which yields an
     empty sequence of the same type as `s').  Note that items in the
     sequence `s' are not copied; they are referenced multiple times.
     This often haunts new Python programmers; consider:

          >>> lists = [[]] * 3
          >>> lists
          [[], [], []]
          >>> lists[0].append(3)
          >>> lists
          [[3], [3], [3]]

     What has happened is that ‘[[]]’ is a one-element list containing
     an empty list, so all three elements of ‘[[]] * 3’ are references
     to this single empty list.  Modifying any of the elements of
     ‘lists’ modifies this single list.  You can create a list of
     different lists this way:

          >>> lists = [[] for i in range(3)]
          >>> lists[0].append(3)
          >>> lists[1].append(5)
          >>> lists[2].append(7)
          >>> lists
          [[3], [5], [7]]

     Further explanation is available in the FAQ entry *note How do I
     create a multidimensional list?: fe8.

  3. If `i' or `j' is negative, the index is relative to the end of the
     string: ‘len(s) + i’ or ‘len(s) + j’ is substituted.  But note that
     ‘-0’ is still ‘0’.

  4. The slice of `s' from `i' to `j' is defined as the sequence of
     items with index `k' such that ‘i <= k < j’.  If `i' or `j' is
     greater than ‘len(s)’, use ‘len(s)’.  If `i' is omitted or ‘None’,
     use ‘0’.  If `j' is omitted or ‘None’, use ‘len(s)’.  If `i' is
     greater than or equal to `j', the slice is empty.

  5. The slice of `s' from `i' to `j' with step `k' is defined as the
     sequence of items with index ‘x = i + n*k’ such that ‘0 <= n <
     (j-i)/k’.  In other words, the indices are ‘i’, ‘i+k’, ‘i+2*k’,
     ‘i+3*k’ and so on, stopping when `j' is reached (but never
     including `j').  If `i' or `j' is greater than ‘len(s)’, use
     ‘len(s)’.  If `i' or `j' are omitted or ‘None’, they become "end"
     values (which end depends on the sign of `k').  Note, `k' cannot be
     zero.  If `k' is ‘None’, it is treated like ‘1’.

  6. Concatenating immutable sequences always results in a new object.
     This means that building up a sequence by repeated concatenation
     will have a quadratic runtime cost in the total sequence length.
     To get a linear runtime cost, you must switch to one of the
     alternatives below:

        * if concatenating *note str: 25a. objects, you can build a list
          and use *note str.join(): fe9. at the end or else write to an
          *note io.StringIO: 41e. instance and retrieve its value when
          complete

        * if concatenating *note bytes: 1db. objects, you can similarly
          use *note bytes.join(): fea. or *note io.BytesIO: 371, or you
          can do in-place concatenation with a *note bytearray: 1dc.
          object.  *note bytearray: 1dc. objects are mutable and have an
          efficient overallocation mechanism

        * if concatenating *note tuple: 25c. objects, extend a *note
          list: 25d. instead

        * for other types, investigate the relevant class documentation

  7. Some sequence types (such as *note range: 5e0.) only support item
     sequences that follow specific patterns, and hence don’t support
     sequence concatenation or repetition.

  8. ‘index’ raises *note ValueError: 19c. when `x' is not found in `s'.
     When supported, the additional arguments to the index method allow
     efficient searching of subsections of the sequence.  Passing the
     extra arguments is roughly equivalent to using ‘s[i:j].index(x)’,
     only without copying any data and with the returned index being
     relative to the start of the sequence rather than the start of the
     slice.


File: python.info,  Node: Immutable Sequence Types,  Next: Mutable Sequence Types,  Prev: Common Sequence Operations,  Up: Sequence Types --- list tuple range

5.4.6.2 Immutable Sequence Types
................................

The only operation that immutable sequence types generally implement
that is not also implemented by mutable sequence types is support for
the *note hash(): 5e6. built-in.

This support allows immutable sequences, such as *note tuple: 25c.
instances, to be used as *note dict: 3b0. keys and stored in *note set:
7be. and *note frozenset: 84c. instances.

Attempting to hash an immutable sequence that contains unhashable values
will result in *note TypeError: 562.


File: python.info,  Node: Mutable Sequence Types,  Next: Lists<2>,  Prev: Immutable Sequence Types,  Up: Sequence Types --- list tuple range

5.4.6.3 Mutable Sequence Types
..............................

The operations in the following table are defined on mutable sequence
types.  The *note collections.abc.MutableSequence: 252. ABC is provided
to make it easier to correctly implement these operations on custom
sequence types.

In the table `s' is an instance of a mutable sequence type, `t' is any
iterable object and `x' is an arbitrary object that meets any type and
value restrictions imposed by `s' (for example, *note bytearray: 1dc.
only accepts integers that meet the value restriction ‘0 <= x <= 255’).

Operation                          Result                               Notes
                                                                        
--------------------------------------------------------------------------------------------------
                                                                        
‘s[i] = x’                         item `i' of `s' is replaced by `x'
                                   
                                                                        
‘s[i:j] = t’                       slice of `s' from `i' to `j' is
                                   replaced by the contents of the
                                   iterable `t'
                                   
                                                                        
‘del s[i:j]’                       same as ‘s[i:j] = []’
                                   
                                                                        
‘s[i:j:k] = t’                     the elements of ‘s[i:j:k]’ are       (1)
                                   replaced by those of `t'             
                                   
                                                                        
‘del s[i:j:k]’                     removes the elements of ‘s[i:j:k]’
                                   from the list
                                   
                                                                        
‘s.append(x)’                      appends `x' to the end of the
                                   sequence (same as
                                   ‘s[len(s):len(s)] = [x]’)
                                   
                                                                        
‘s.clear()’                        removes all items from ‘s’ (same     (5)
                                   as ‘del s[:]’)                       
                                   
                                                                        
‘s.copy()’                         creates a shallow copy of ‘s’        (5)
                                   (same as ‘s[:]’)                     
                                   
                                                                        
‘s.extend(t)’ or ‘s += t’          extends `s' with the contents of
                                   `t' (for the most part the same as
                                   ‘s[len(s):len(s)] = t’)
                                   
                                                                        
‘s *= n’                           updates `s' with its contents        (6)
                                   repeated `n' times                   
                                   
                                                                        
‘s.insert(i, x)’                   inserts `x' into `s' at the index
                                   given by `i' (same as ‘s[i:i] =
                                   [x]’)
                                   
                                                                        
‘s.pop([i])’                       retrieves the item at `i' and also   (2)
                                   removes it from `s'                  
                                   
                                                                        
‘s.remove(x)’                      remove the first item from `s'       (3)
                                   where ‘s[i] == x’                    
                                   
                                                                        
‘s.reverse()’                      reverses the items of `s' in place   (4)
                                                                        

Notes:

  1. `t' must have the same length as the slice it is replacing.

  2. The optional argument `i' defaults to ‘-1’, so that by default the
     last item is removed and returned.

  3. ‘remove’ raises *note ValueError: 19c. when `x' is not found in
     `s'.

  4. The ‘reverse()’ method modifies the sequence in place for economy
     of space when reversing a large sequence.  To remind users that it
     operates by side effect, it does not return the reversed sequence.

  5. ‘clear()’ and ‘copy()’ are included for consistency with the
     interfaces of mutable containers that don’t support slicing
     operations (such as *note dict: 3b0. and *note set: 7be.)

     New in version 3.3: ‘clear()’ and ‘copy()’ methods.

  6. The value `n' is an integer, or an object implementing *note
     __index__(): 8d2.  Zero and negative values of `n' clear the
     sequence.  Items in the sequence are not copied; they are
     referenced multiple times, as explained for ‘s * n’ under *note
     Common Sequence Operations: fe6.


File: python.info,  Node: Lists<2>,  Next: Tuples,  Prev: Mutable Sequence Types,  Up: Sequence Types --- list tuple range

5.4.6.4 Lists
.............

Lists are mutable sequences, typically used to store collections of
homogeneous items (where the precise degree of similarity will vary by
application).

 -- Class: list ([iterable])

     Lists may be constructed in several ways:

        * Using a pair of square brackets to denote the empty list: ‘[]’

        * Using square brackets, separating items with commas: ‘[a]’,
          ‘[a, b, c]’

        * Using a list comprehension: ‘[x for x in iterable]’

        * Using the type constructor: ‘list()’ or ‘list(iterable)’

     The constructor builds a list whose items are the same and in the
     same order as `iterable'’s items.  `iterable' may be either a
     sequence, a container that supports iteration, or an iterator
     object.  If `iterable' is already a list, a copy is made and
     returned, similar to ‘iterable[:]’.  For example, ‘list('abc')’
     returns ‘['a', 'b', 'c']’ and ‘list( (1, 2, 3) )’ returns ‘[1, 2,
     3]’.  If no argument is given, the constructor creates a new empty
     list, ‘[]’.

     Many other operations also produce lists, including the *note
     sorted(): 84e. built-in.

     Lists implement all of the *note common: fe6. and *note mutable:
     f9d. sequence operations.  Lists also provide the following
     additional method:

      -- Method: sort (*, key=None, reverse=None)

          This method sorts the list in place, using only ‘<’
          comparisons between items.  Exceptions are not suppressed - if
          any comparison operations fail, the entire sort operation will
          fail (and the list will likely be left in a partially modified
          state).

          *note sort(): 84d. accepts two arguments that can only be
          passed by keyword (*note keyword-only arguments: 51d.):

          `key' specifies a function of one argument that is used to
          extract a comparison key from each list element (for example,
          ‘key=str.lower’).  The key corresponding to each item in the
          list is calculated once and then used for the entire sorting
          process.  The default value of ‘None’ means that list items
          are sorted directly without calculating a separate key value.

          The *note functools.cmp_to_key(): 7a0. utility is available to
          convert a 2.x style `cmp' function to a `key' function.

          `reverse' is a boolean value.  If set to ‘True’, then the list
          elements are sorted as if each comparison were reversed.

          This method modifies the sequence in place for economy of
          space when sorting a large sequence.  To remind users that it
          operates by side effect, it does not return the sorted
          sequence (use *note sorted(): 84e. to explicitly request a new
          sorted list instance).

          The *note sort(): 84d. method is guaranteed to be stable.  A
          sort is stable if it guarantees not to change the relative
          order of elements that compare equal — this is helpful for
          sorting in multiple passes (for example, sort by department,
          then by salary grade).

          `CPython implementation detail:' While a list is being sorted,
          the effect of attempting to mutate, or even inspect, the list
          is undefined.  The C implementation of Python makes the list
          appear empty for the duration, and raises *note ValueError:
          19c. if it can detect that the list has been mutated during a
          sort.


File: python.info,  Node: Tuples,  Next: Ranges,  Prev: Lists<2>,  Up: Sequence Types --- list tuple range

5.4.6.5 Tuples
..............

Tuples are immutable sequences, typically used to store collections of
heterogeneous data (such as the 2-tuples produced by the *note
enumerate(): a61. built-in).  Tuples are also used for cases where an
immutable sequence of homogeneous data is needed (such as allowing
storage in a *note set: 7be. or *note dict: 3b0. instance).

 -- Class: tuple ([iterable])

     Tuples may be constructed in a number of ways:

        * Using a pair of parentheses to denote the empty tuple: ‘()’

        * Using a trailing comma for a singleton tuple: ‘a,’ or ‘(a,)’

        * Separating items with commas: ‘a, b, c’ or ‘(a, b, c)’

        * Using the *note tuple(): 25c. built-in: ‘tuple()’ or
          ‘tuple(iterable)’

     The constructor builds a tuple whose items are the same and in the
     same order as `iterable'’s items.  `iterable' may be either a
     sequence, a container that supports iteration, or an iterator
     object.  If `iterable' is already a tuple, it is returned
     unchanged.  For example, ‘tuple('abc')’ returns ‘('a', 'b', 'c')’
     and ‘tuple( [1, 2, 3] )’ returns ‘(1, 2, 3)’.  If no argument is
     given, the constructor creates a new empty tuple, ‘()’.

     Note that it is actually the comma which makes a tuple, not the
     parentheses.  The parentheses are optional, except in the empty
     tuple case, or when they are needed to avoid syntactic ambiguity.
     For example, ‘f(a, b, c)’ is a function call with three arguments,
     while ‘f((a, b, c))’ is a function call with a 3-tuple as the sole
     argument.

     Tuples implement all of the *note common: fe6. sequence operations.

For heterogeneous collections of data where access by name is clearer
than access by index, *note collections.namedtuple(): 229. may be a more
appropriate choice than a simple tuple object.


File: python.info,  Node: Ranges,  Prev: Tuples,  Up: Sequence Types --- list tuple range

5.4.6.6 Ranges
..............

The *note range: 5e0. type represents an immutable sequence of numbers
and is commonly used for looping a specific number of times in *note
for: 895. loops.

 -- Class: range (stop)

 -- Class: range (start, stop[, step])

     The arguments to the range constructor must be integers (either
     built-in *note int: 227. or any object that implements the
     ‘__index__’ special method).  If the `step' argument is omitted, it
     defaults to ‘1’.  If the `start' argument is omitted, it defaults
     to ‘0’.  If `step' is zero, *note ValueError: 19c. is raised.

     For a positive `step', the contents of a range ‘r’ are determined
     by the formula ‘r[i] = start + step*i’ where ‘i >= 0’ and ‘r[i] <
     stop’.

     For a negative `step', the contents of the range are still
     determined by the formula ‘r[i] = start + step*i’, but the
     constraints are ‘i >= 0’ and ‘r[i] > stop’.

     A range object will be empty if ‘r[0]’ does not meet the value
     constraint.  Ranges do support negative indices, but these are
     interpreted as indexing from the end of the sequence determined by
     the positive indices.

     Ranges containing absolute values larger than *note sys.maxsize:
     78c. are permitted but some features (such as *note len(): 5a8.)
     may raise *note OverflowError: 578.

     Range examples:

          >>> list(range(10))
          [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
          >>> list(range(1, 11))
          [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
          >>> list(range(0, 30, 5))
          [0, 5, 10, 15, 20, 25]
          >>> list(range(0, 10, 3))
          [0, 3, 6, 9]
          >>> list(range(0, -10, -1))
          [0, -1, -2, -3, -4, -5, -6, -7, -8, -9]
          >>> list(range(0))
          []
          >>> list(range(1, 0))
          []

     Ranges implement all of the *note common: fe6. sequence operations
     except concatenation and repetition (due to the fact that range
     objects can only represent sequences that follow a strict pattern
     and repetition and concatenation will usually violate that
     pattern).

      -- Attribute: start

          The value of the `start' parameter (or ‘0’ if the parameter
          was not supplied)

      -- Attribute: stop

          The value of the `stop' parameter

      -- Attribute: step

          The value of the `step' parameter (or ‘1’ if the parameter was
          not supplied)

The advantage of the *note range: 5e0. type over a regular *note list:
25d. or *note tuple: 25c. is that a *note range: 5e0. object will always
take the same (small) amount of memory, no matter the size of the range
it represents (as it only stores the ‘start’, ‘stop’ and ‘step’ values,
calculating individual items and subranges as needed).

Range objects implement the *note collections.abc.Sequence: fe7. ABC,
and provide features such as containment tests, element index lookup,
slicing and support for negative indices (see *note Sequence Types —
list, tuple, range: c32.):

     >>> r = range(0, 20, 2)
     >>> r
     range(0, 20, 2)
     >>> 11 in r
     False
     >>> 10 in r
     True
     >>> r.index(10)
     5
     >>> r[5]
     10
     >>> r[:5]
     range(0, 10, 2)
     >>> r[-1]
     18

Testing range objects for equality with ‘==’ and ‘!=’ compares them as
sequences.  That is, two range objects are considered equal if they
represent the same sequence of values.  (Note that two range objects
that compare equal might have different *note start: ff1, *note stop:
ff2. and *note step: ff3. attributes, for example ‘range(0) == range(2,
1, 3)’ or ‘range(0, 3, 2) == range(0, 4, 2)’.)

Changed in version 3.2: Implement the Sequence ABC. Support slicing and
negative indices.  Test *note int: 227. objects for membership in
constant time instead of iterating through all items.

Changed in version 3.3: Define ’==’ and ’!=’ to compare range objects
based on the sequence of values they define (instead of comparing based
on object identity).

New in version 3.3: The *note start: ff1, *note stop: ff2. and *note
step: ff3. attributes.


File: python.info,  Node: Text Sequence Type --- str,  Next: Binary Sequence Types --- bytes bytearray memoryview,  Prev: Sequence Types --- list tuple range,  Up: Built-in Types

5.4.7 Text Sequence Type — ‘str’
--------------------------------

Textual data in Python is handled with *note str: 25a. objects, or
`strings'.  Strings are immutable *note sequences: c32. of Unicode code
points.  String literals are written in a variety of ways:

   * Single quotes: ‘'allows embedded "double" quotes'’

   * Double quotes: ‘"allows embedded 'single' quotes"’.

   * Triple quoted: ‘'''Three single quotes'''’, ‘"""Three double
     quotes"""’

Triple quoted strings may span multiple lines - all associated
whitespace will be included in the string literal.

String literals that are part of a single expression and have only
whitespace between them will be implicitly converted to a single string
literal.  That is, ‘("spam " "eggs") == "spam eggs"’.

See *note String and Bytes literals: d9f. for more about the various
forms of string literal, including supported escape sequences, and the
‘r’ ("raw") prefix that disables most escape sequence processing.

Strings may also be created from other objects using the *note str: 25a.
constructor.

Since there is no separate "character" type, indexing a string produces
strings of length 1.  That is, for a non-empty string `s', ‘s[0] ==
s[0:1]’.

There is also no mutable string type, but *note str.join(): fe9. or
*note io.StringIO: 41e. can be used to efficiently construct strings
from multiple fragments.

Changed in version 3.3: For backwards compatibility with the Python 2
series, the ‘u’ prefix is once again permitted on string literals.  It
has no effect on the meaning of string literals and cannot be combined
with the ‘r’ prefix.

 -- Class: str (object='')

 -- Class: str (object=b'', encoding='utf-8', errors='strict')

     Return a *note string: bea. version of `object'.  If `object' is
     not provided, returns the empty string.  Otherwise, the behavior of
     ‘str()’ depends on whether `encoding' or `errors' is given, as
     follows.

     If neither `encoding' nor `errors' is given, ‘str(object)’ returns
     *note object.__str__(): ab9, which is the "informal" or nicely
     printable string representation of `object'.  For string objects,
     this is the string itself.  If `object' does not have a *note
     __str__(): ab9. method, then *note str(): 25a. falls back to
     returning *note repr(object): 3bb.

     If at least one of `encoding' or `errors' is given, `object' should
     be a *note bytes-like object: 36b. (e.g.  *note bytes: 1db. or
     *note bytearray: 1dc.).  In this case, if `object' is a *note
     bytes: 1db. (or *note bytearray: 1dc.) object, then ‘str(bytes,
     encoding, errors)’ is equivalent to *note bytes.decode(encoding,
     errors): 89e.  Otherwise, the bytes object underlying the buffer
     object is obtained before calling *note bytes.decode(): 89e.  See
     *note Binary Sequence Types — bytes, bytearray, memoryview: f9f.
     and *note Buffer Protocol: ff5. for information on buffer objects.

     Passing a *note bytes: 1db. object to *note str(): 25a. without the
     `encoding' or `errors' arguments falls under the first case of
     returning the informal string representation (see also the *note
     -b: 226. command-line option to Python).  For example:

          >>> str(b'Zoot!')
          "b'Zoot!'"

     For more information on the ‘str’ class and its methods, see *note
     Text Sequence Type — str: bea. and the *note String Methods: beb.
     section below.  To output formatted strings, see the *note
     Formatted string literals: 14f. and *note Format String Syntax:
     98a. sections.  In addition, see the *note Text Processing
     Services: ff6. section.

* Menu:

* String Methods: String Methods<2>. 
* printf-style String Formatting:: 


File: python.info,  Node: String Methods<2>,  Next: printf-style String Formatting,  Up: Text Sequence Type --- str

5.4.7.1 String Methods
......................

Strings implement all of the *note common: fe6. sequence operations,
along with the additional methods described below.

Strings also support two styles of string formatting, one providing a
large degree of flexibility and customization (see *note str.format():
14d, *note Format String Syntax: 98a. and *note Custom String
Formatting: ff8.) and the other based on C ‘printf’ style formatting
that handles a narrower range of types and is slightly harder to use
correctly, but is often faster for the cases it can handle (*note
printf-style String Formatting: bec.).

The *note Text Processing Services: ff9. section of the standard library
covers a number of other modules that provide various text related
utilities (including regular expression support in the *note re: db.
module).

 -- Method: str.capitalize ()

     Return a copy of the string with its first character capitalized
     and the rest lowercased.

 -- Method: str.casefold ()

     Return a casefolded copy of the string.  Casefolded strings may be
     used for caseless matching.

     Casefolding is similar to lowercasing but more aggressive because
     it is intended to remove all case distinctions in a string.  For
     example, the German lowercase letter ‘'ß'’ is equivalent to ‘"ss"’.
     Since it is already lowercase, *note lower(): ffb. would do nothing
     to ‘'ß'’; *note casefold(): 256. converts it to ‘"ss"’.

     The casefolding algorithm is described in section 3.13 of the
     Unicode Standard.

     New in version 3.3.

 -- Method: str.center (width[, fillchar])

     Return centered in a string of length `width'.  Padding is done
     using the specified `fillchar' (default is an ASCII space).  The
     original string is returned if `width' is less than or equal to
     ‘len(s)’.

 -- Method: str.count (sub[, start[, end]])

     Return the number of non-overlapping occurrences of substring `sub'
     in the range [`start', `end'].  Optional arguments `start' and
     `end' are interpreted as in slice notation.

 -- Method: str.encode (encoding="utf-8", errors="strict")

     Return an encoded version of the string as a bytes object.  Default
     encoding is ‘'utf-8'’.  `errors' may be given to set a different
     error handling scheme.  The default for `errors' is ‘'strict'’,
     meaning that encoding errors raise a *note UnicodeError: 8a2.
     Other possible values are ‘'ignore'’, ‘'replace'’,
     ‘'xmlcharrefreplace'’, ‘'backslashreplace'’ and any other name
     registered via *note codecs.register_error(): a74, see section
     *note Error Handlers: fb2.  For a list of possible encodings, see
     section *note Standard Encodings: 228.

     Changed in version 3.1: Support for keyword arguments added.

 -- Method: str.endswith (suffix[, start[, end]])

     Return ‘True’ if the string ends with the specified `suffix',
     otherwise return ‘False’.  `suffix' can also be a tuple of suffixes
     to look for.  With optional `start', test beginning at that
     position.  With optional `end', stop comparing at that position.

 -- Method: str.expandtabs (tabsize=8)

     Return a copy of the string where all tab characters are replaced
     by one or more spaces, depending on the current column and the
     given tab size.  Tab positions occur every `tabsize' characters
     (default is 8, giving tab positions at columns 0, 8, 16 and so on).
     To expand the string, the current column is set to zero and the
     string is examined character by character.  If the character is a
     tab (‘\t’), one or more space characters are inserted in the result
     until the current column is equal to the next tab position.  (The
     tab character itself is not copied.)  If the character is a newline
     (‘\n’) or return (‘\r’), it is copied and the current column is
     reset to zero.  Any other character is copied unchanged and the
     current column is incremented by one regardless of how the
     character is represented when printed.

          >>> '01\t012\t0123\t01234'.expandtabs()
          '01      012     0123    01234'
          >>> '01\t012\t0123\t01234'.expandtabs(4)
          '01  012 0123    01234'

 -- Method: str.find (sub[, start[, end]])

     Return the lowest index in the string where substring `sub' is
     found within the slice ‘s[start:end]’.  Optional arguments `start'
     and `end' are interpreted as in slice notation.  Return ‘-1’ if
     `sub' is not found.

          Note: The *note find(): 379. method should be used only if you
          need to know the position of `sub'.  To check if `sub' is a
          substring or not, use the *note in: 37d. operator:

               >>> 'Py' in 'Python'
               True

 -- Method: str.format (*args, **kwargs)

     Perform a string formatting operation.  The string on which this
     method is called can contain literal text or replacement fields
     delimited by braces ‘{}’.  Each replacement field contains either
     the numeric index of a positional argument, or the name of a
     keyword argument.  Returns a copy of the string where each
     replacement field is replaced with the string value of the
     corresponding argument.

          >>> "The sum of 1 + 2 is {0}".format(1+2)
          'The sum of 1 + 2 is 3'

     See *note Format String Syntax: 98a. for a description of the
     various formatting options that can be specified in format strings.

 -- Method: str.format_map (mapping)

     Similar to ‘str.format(**mapping)’, except that ‘mapping’ is used
     directly and not copied to a *note dict: 3b0.  This is useful if
     for example ‘mapping’ is a dict subclass:

          >>> class Default(dict):
          ...     def __missing__(self, key):
          ...         return key
          ...
          >>> '{name} was born in {country}'.format_map(Default(name='Guido'))
          'Guido was born in country'

     New in version 3.2.

 -- Method: str.index (sub[, start[, end]])

     Like *note find(): 379, but raise *note ValueError: 19c. when the
     substring is not found.

 -- Method: str.isalnum ()

     Return true if all characters in the string are alphanumeric and
     there is at least one character, false otherwise.  A character ‘c’
     is alphanumeric if one of the following returns ‘True’:
     ‘c.isalpha()’, ‘c.isdecimal()’, ‘c.isdigit()’, or ‘c.isnumeric()’.

 -- Method: str.isalpha ()

     Return true if all characters in the string are alphabetic and
     there is at least one character, false otherwise.  Alphabetic
     characters are those characters defined in the Unicode character
     database as "Letter", i.e., those with general category property
     being one of "Lm", "Lt", "Lu", "Ll", or "Lo".  Note that this is
     different from the "Alphabetic" property defined in the Unicode
     Standard.

 -- Method: str.isdecimal ()

     Return true if all characters in the string are decimal characters
     and there is at least one character, false otherwise.  Decimal
     characters are those from general category "Nd".  This category
     includes digit characters, and all characters that can be used to
     form decimal-radix numbers, e.g.  U+0660, ARABIC-INDIC DIGIT ZERO.

 -- Method: str.isdigit ()

     Return true if all characters in the string are digits and there is
     at least one character, false otherwise.  Digits include decimal
     characters and digits that need special handling, such as the
     compatibility superscript digits.  Formally, a digit is a character
     that has the property value Numeric_Type=Digit or
     Numeric_Type=Decimal.

 -- Method: str.isidentifier ()

     Return true if the string is a valid identifier according to the
     language definition, section *note Identifiers and keywords: d90.

     Use *note keyword.iskeyword(): 1004. to test for reserved
     identifiers such as *note def: a3a. and *note class: 8d6.

 -- Method: str.islower ()

     Return true if all cased characters (1) in the string are lowercase
     and there is at least one cased character, false otherwise.

 -- Method: str.isnumeric ()

     Return true if all characters in the string are numeric characters,
     and there is at least one character, false otherwise.  Numeric
     characters include digit characters, and all characters that have
     the Unicode numeric value property, e.g.  U+2155, VULGAR FRACTION
     ONE FIFTH. Formally, numeric characters are those with the property
     value Numeric_Type=Digit, Numeric_Type=Decimal or
     Numeric_Type=Numeric.

 -- Method: str.isprintable ()

     Return true if all characters in the string are printable or the
     string is empty, false otherwise.  Nonprintable characters are
     those characters defined in the Unicode character database as
     "Other" or "Separator", excepting the ASCII space (0x20) which is
     considered printable.  (Note that printable characters in this
     context are those which should not be escaped when *note repr():
     3bb. is invoked on a string.  It has no bearing on the handling of
     strings written to *note sys.stdout: 1ba. or *note sys.stderr:
     270.)

 -- Method: str.isspace ()

     Return true if there are only whitespace characters in the string
     and there is at least one character, false otherwise.  Whitespace
     characters are those characters defined in the Unicode character
     database as "Other" or "Separator" and those with bidirectional
     property being one of "WS", "B", or "S".

 -- Method: str.istitle ()

     Return true if the string is a titlecased string and there is at
     least one character, for example uppercase characters may only
     follow uncased characters and lowercase characters only cased ones.
     Return false otherwise.

 -- Method: str.isupper ()

     Return true if all cased characters (2) in the string are uppercase
     and there is at least one cased character, false otherwise.

 -- Method: str.join (iterable)

     Return a string which is the concatenation of the strings in the
     *note iterable: 80a. `iterable'.  A *note TypeError: 562. will be
     raised if there are any non-string values in `iterable', including
     *note bytes: 1db. objects.  The separator between elements is the
     string providing this method.

 -- Method: str.ljust (width[, fillchar])

     Return the string left justified in a string of length `width'.
     Padding is done using the specified `fillchar' (default is an ASCII
     space).  The original string is returned if `width' is less than or
     equal to ‘len(s)’.

 -- Method: str.lower ()

     Return a copy of the string with all the cased characters (3)
     converted to lowercase.

     The lowercasing algorithm used is described in section 3.13 of the
     Unicode Standard.

 -- Method: str.lstrip ([chars])

     Return a copy of the string with leading characters removed.  The
     `chars' argument is a string specifying the set of characters to be
     removed.  If omitted or ‘None’, the `chars' argument defaults to
     removing whitespace.  The `chars' argument is not a prefix; rather,
     all combinations of its values are stripped:

          >>> '   spacious   '.lstrip()
          'spacious   '
          >>> 'www.example.com'.lstrip('cmowz.')
          'example.com'

 -- Static Method: str.maketrans (x[, y[, z]])

     This static method returns a translation table usable for *note
     str.translate(): 100b.

     If there is only one argument, it must be a dictionary mapping
     Unicode ordinals (integers) or characters (strings of length 1) to
     Unicode ordinals, strings (of arbitrary lengths) or None.
     Character keys will then be converted to ordinals.

     If there are two arguments, they must be strings of equal length,
     and in the resulting dictionary, each character in x will be mapped
     to the character at the same position in y.  If there is a third
     argument, it must be a string, whose characters will be mapped to
     None in the result.

 -- Method: str.partition (sep)

     Split the string at the first occurrence of `sep', and return a
     3-tuple containing the part before the separator, the separator
     itself, and the part after the separator.  If the separator is not
     found, return a 3-tuple containing the string itself, followed by
     two empty strings.

 -- Method: str.replace (old, new[, count])

     Return a copy of the string with all occurrences of substring `old'
     replaced by `new'.  If the optional argument `count' is given, only
     the first `count' occurrences are replaced.

 -- Method: str.rfind (sub[, start[, end]])

     Return the highest index in the string where substring `sub' is
     found, such that `sub' is contained within ‘s[start:end]’.
     Optional arguments `start' and `end' are interpreted as in slice
     notation.  Return ‘-1’ on failure.

 -- Method: str.rindex (sub[, start[, end]])

     Like *note rfind(): 37a. but raises *note ValueError: 19c. when the
     substring `sub' is not found.

 -- Method: str.rjust (width[, fillchar])

     Return the string right justified in a string of length `width'.
     Padding is done using the specified `fillchar' (default is an ASCII
     space).  The original string is returned if `width' is less than or
     equal to ‘len(s)’.

 -- Method: str.rpartition (sep)

     Split the string at the last occurrence of `sep', and return a
     3-tuple containing the part before the separator, the separator
     itself, and the part after the separator.  If the separator is not
     found, return a 3-tuple containing two empty strings, followed by
     the string itself.

 -- Method: str.rsplit (sep=None, maxsplit=-1)

     Return a list of the words in the string, using `sep' as the
     delimiter string.  If `maxsplit' is given, at most `maxsplit'
     splits are done, the `rightmost' ones.  If `sep' is not specified
     or ‘None’, any whitespace string is a separator.  Except for
     splitting from the right, *note rsplit(): 100f. behaves like *note
     split(): 37b. which is described in detail below.

 -- Method: str.rstrip ([chars])

     Return a copy of the string with trailing characters removed.  The
     `chars' argument is a string specifying the set of characters to be
     removed.  If omitted or ‘None’, the `chars' argument defaults to
     removing whitespace.  The `chars' argument is not a suffix; rather,
     all combinations of its values are stripped:

          >>> '   spacious   '.rstrip()
          '   spacious'
          >>> 'mississippi'.rstrip('ipz')
          'mississ'

 -- Method: str.split (sep=None, maxsplit=-1)

     Return a list of the words in the string, using `sep' as the
     delimiter string.  If `maxsplit' is given, at most `maxsplit'
     splits are done (thus, the list will have at most ‘maxsplit+1’
     elements).  If `maxsplit' is not specified or ‘-1’, then there is
     no limit on the number of splits (all possible splits are made).

     If `sep' is given, consecutive delimiters are not grouped together
     and are deemed to delimit empty strings (for example,
     ‘'1,,2'.split(',')’ returns ‘['1', '', '2']’).  The `sep' argument
     may consist of multiple characters (for example,
     ‘'1<>2<>3'.split('<>')’ returns ‘['1', '2', '3']’).  Splitting an
     empty string with a specified separator returns ‘['']’.

     For example:

          >>> '1,2,3'.split(',')
          ['1', '2', '3']
          >>> '1,2,3'.split(',', maxsplit=1)
          ['1', '2,3']
          >>> '1,2,,3,'.split(',')
          ['1', '2', '', '3', '']

     If `sep' is not specified or is ‘None’, a different splitting
     algorithm is applied: runs of consecutive whitespace are regarded
     as a single separator, and the result will contain no empty strings
     at the start or end if the string has leading or trailing
     whitespace.  Consequently, splitting an empty string or a string
     consisting of just whitespace with a ‘None’ separator returns ‘[]’.

     For example:

          >>> '1 2 3'.split()
          ['1', '2', '3']
          >>> '1 2 3'.split(maxsplit=1)
          ['1', '2 3']
          >>> '   1   2   3   '.split()
          ['1', '2', '3']

 -- Method: str.splitlines ([keepends])

     Return a list of the lines in the string, breaking at line
     boundaries.  Line breaks are not included in the resulting list
     unless `keepends' is given and true.

     This method splits on the following line boundaries.  In
     particular, the boundaries are a superset of *note universal
     newlines: 994.

     Representation              Description
                                 
     --------------------------------------------------------------
                                 
     ‘\n’                        Line Feed
                                 
                                 
     ‘\r’                        Carriage Return
                                 
                                 
     ‘\r\n’                      Carriage Return + Line Feed
                                 
                                 
     ‘\v’ or ‘\x0b’              Line Tabulation
                                 
                                 
     ‘\f’ or ‘\x0c’              Form Feed
                                 
                                 
     ‘\x1c’                      File Separator
                                 
                                 
     ‘\x1d’                      Group Separator
                                 
                                 
     ‘\x1e’                      Record Separator
                                 
                                 
     ‘\x85’                      Next Line (C1 Control Code)
                                 
                                 
     ‘\u2028’                    Line Separator
                                 
                                 
     ‘\u2029’                    Paragraph Separator
                                 

     Changed in version 3.2: ‘\v’ and ‘\f’ added to list of line
     boundaries.

     For example:

          >>> 'ab c\n\nde fg\rkl\r\n'.splitlines()
          ['ab c', '', 'de fg', 'kl']
          >>> 'ab c\n\nde fg\rkl\r\n'.splitlines(keepends=True)
          ['ab c\n', '\n', 'de fg\r', 'kl\r\n']

     Unlike *note split(): 37b. when a delimiter string `sep' is given,
     this method returns an empty list for the empty string, and a
     terminal line break does not result in an extra line:

          >>> "".splitlines()
          []
          >>> "One line\n".splitlines()
          ['One line']

     For comparison, ‘split('\n')’ gives:

          >>> ''.split('\n')
          ['']
          >>> 'Two lines\n'.split('\n')
          ['Two lines', '']

 -- Method: str.startswith (prefix[, start[, end]])

     Return ‘True’ if string starts with the `prefix', otherwise return
     ‘False’.  `prefix' can also be a tuple of prefixes to look for.
     With optional `start', test string beginning at that position.
     With optional `end', stop comparing string at that position.

 -- Method: str.strip ([chars])

     Return a copy of the string with the leading and trailing
     characters removed.  The `chars' argument is a string specifying
     the set of characters to be removed.  If omitted or ‘None’, the
     `chars' argument defaults to removing whitespace.  The `chars'
     argument is not a prefix or suffix; rather, all combinations of its
     values are stripped:

          >>> '   spacious   '.strip()
          'spacious'
          >>> 'www.example.com'.strip('cmowz.')
          'example'

     The outermost leading and trailing `chars' argument values are
     stripped from the string.  Characters are removed from the leading
     end until reaching a string character that is not contained in the
     set of characters in `chars'.  A similar action takes place on the
     trailing end.  For example:

          >>> comment_string = '#....... Section 3.2.1 Issue #32 .......'
          >>> comment_string.strip('.#! ')
          'Section 3.2.1 Issue #32'

 -- Method: str.swapcase ()

     Return a copy of the string with uppercase characters converted to
     lowercase and vice versa.  Note that it is not necessarily true
     that ‘s.swapcase().swapcase() == s’.

 -- Method: str.title ()

     Return a titlecased version of the string where words start with an
     uppercase character and the remaining characters are lowercase.

     For example:

          >>> 'Hello world'.title()
          'Hello World'

     The algorithm uses a simple language-independent definition of a
     word as groups of consecutive letters.  The definition works in
     many contexts but it means that apostrophes in contractions and
     possessives form word boundaries, which may not be the desired
     result:

          >>> "they're bill's friends from the UK".title()
          "They'Re Bill'S Friends From The Uk"

     A workaround for apostrophes can be constructed using regular
     expressions:

          >>> import re
          >>> def titlecase(s):
          ...     return re.sub(r"[A-Za-z]+('[A-Za-z]+)?",
          ...                   lambda mo: mo.group(0)[0].upper() +
          ...                              mo.group(0)[1:].lower(),
          ...                   s)
          ...
          >>> titlecase("they're bill's friends.")
          "They're Bill's Friends."

 -- Method: str.translate (table)

     Return a copy of the string in which each character has been mapped
     through the given translation table.  The table must be an object
     that implements indexing via *note __getitem__(): a84, typically a
     *note mapping: 77c. or *note sequence: bef.  When indexed by a
     Unicode ordinal (an integer), the table object can do any of the
     following: return a Unicode ordinal or a string, to map the
     character to one or more other characters; return ‘None’, to delete
     the character from the return string; or raise a *note LookupError:
     1015. exception, to map the character to itself.

     You can use *note str.maketrans(): 259. to create a translation map
     from character-to-character mappings in different formats.

     See also the *note codecs: 1c. module for a more flexible approach
     to custom character mappings.

 -- Method: str.upper ()

     Return a copy of the string with all the cased characters (4)
     converted to uppercase.  Note that ‘str.upper().isupper()’ might be
     ‘False’ if ‘s’ contains uncased characters or if the Unicode
     category of the resulting character(s) is not "Lu" (Letter,
     uppercase), but e.g.  "Lt" (Letter, titlecase).

     The uppercasing algorithm used is described in section 3.13 of the
     Unicode Standard.

 -- Method: str.zfill (width)

     Return a copy of the string left filled with ASCII ‘'0'’ digits to
     make a string of length `width'.  A leading sign prefix
     (‘'+'’/‘'-'’) is handled by inserting the padding `after' the sign
     character rather than before.  The original string is returned if
     `width' is less than or equal to ‘len(s)’.

     For example:

          >>> "42".zfill(5)
          '00042'
          >>> "-42".zfill(5)
          '-0042'

   ---------- Footnotes ----------

   (1) Cased characters are those with general category property being
one of "Lu" (Letter, uppercase), "Ll" (Letter, lowercase), or "Lt"
(Letter, titlecase).

   (2) Cased characters are those with general category property being
one of "Lu" (Letter, uppercase), "Ll" (Letter, lowercase), or "Lt"
(Letter, titlecase).

   (3) Cased characters are those with general category property being
one of "Lu" (Letter, uppercase), "Ll" (Letter, lowercase), or "Lt"
(Letter, titlecase).

   (4) Cased characters are those with general category property being
one of "Lu" (Letter, uppercase), "Ll" (Letter, lowercase), or "Lt"
(Letter, titlecase).


File: python.info,  Node: printf-style String Formatting,  Prev: String Methods<2>,  Up: Text Sequence Type --- str

5.4.7.2 ‘printf’-style String Formatting
........................................

     Note: The formatting operations described here exhibit a variety of
     quirks that lead to a number of common errors (such as failing to
     display tuples and dictionaries correctly).  Using the newer *note
     formatted string literals: 14f. or the *note str.format(): 14d.
     interface helps avoid these errors.  These alternatives also
     provide more powerful, flexible and extensible approaches to
     formatting text.

String objects have one unique built-in operation: the ‘%’ operator
(modulo).  This is also known as the string `formatting' or
`interpolation' operator.  Given ‘format % values’ (where `format' is a
string), ‘%’ conversion specifications in `format' are replaced with
zero or more elements of `values'.  The effect is similar to using the
‘sprintf()’ in the C language.

If `format' requires a single argument, `values' may be a single
non-tuple object.  (1) Otherwise, `values' must be a tuple with exactly
the number of items specified by the format string, or a single mapping
object (for example, a dictionary).

A conversion specifier contains two or more characters and has the
following components, which must occur in this order:

  1. The ‘'%'’ character, which marks the start of the specifier.

  2. Mapping key (optional), consisting of a parenthesised sequence of
     characters (for example, ‘(somename)’).

  3. Conversion flags (optional), which affect the result of some
     conversion types.

  4. Minimum field width (optional).  If specified as an ‘'*'’
     (asterisk), the actual width is read from the next element of the
     tuple in `values', and the object to convert comes after the
     minimum field width and optional precision.

  5. Precision (optional), given as a ‘'.'’ (dot) followed by the
     precision.  If specified as ‘'*'’ (an asterisk), the actual
     precision is read from the next element of the tuple in `values',
     and the value to convert comes after the precision.

  6. Length modifier (optional).

  7. Conversion type.

When the right argument is a dictionary (or other mapping type), then
the formats in the string `must' include a parenthesised mapping key
into that dictionary inserted immediately after the ‘'%'’ character.
The mapping key selects the value to be formatted from the mapping.  For
example:

     >>> print('%(language)s has %(number)03d quote types.' %
     ...       {'language': "Python", "number": 2})
     Python has 002 quote types.

In this case no ‘*’ specifiers may occur in a format (since they require
a sequential parameter list).

The conversion flag characters are:

Flag          Meaning
              
----------------------------------------------------------------------------------------
              
‘'#'’         The value conversion will use the "alternate form" (where defined
              below).
              
              
‘'0'’         The conversion will be zero padded for numeric values.
              
              
‘'-'’         The converted value is left adjusted (overrides the ‘'0'’ conversion if
              both are given).
              
              
‘' '’         (a space) A blank should be left before a positive number (or empty
              string) produced by a signed conversion.
              
              
‘'+'’         A sign character (‘'+'’ or ‘'-'’) will precede the conversion
              (overrides a "space" flag).
              

A length modifier (‘h’, ‘l’, or ‘L’) may be present, but is ignored as
it is not necessary for Python – so e.g.  ‘%ld’ is identical to ‘%d’.

The conversion types are:

Conversion       Meaning                                                   Notes
                                                                           
---------------------------------------------------------------------------------------
                                                                           
‘'d'’            Signed integer decimal.
                 
                                                                           
‘'i'’            Signed integer decimal.
                 
                                                                           
‘'o'’            Signed octal value.                                       (1)
                                                                           
                                                                           
‘'u'’            Obsolete type – it is identical to ‘'d'’.                 (7)
                                                                           
                                                                           
‘'x'’            Signed hexadecimal (lowercase).                           (2)
                                                                           
                                                                           
‘'X'’            Signed hexadecimal (uppercase).                           (2)
                                                                           
                                                                           
‘'e'’            Floating point exponential format (lowercase).            (3)
                                                                           
                                                                           
‘'E'’            Floating point exponential format (uppercase).            (3)
                                                                           
                                                                           
‘'f'’            Floating point decimal format.                            (3)
                                                                           
                                                                           
‘'F'’            Floating point decimal format.                            (3)
                                                                           
                                                                           
‘'g'’            Floating point format.  Uses lowercase exponential        (4)
                 format if exponent is less than -4 or not less than       
                 precision, decimal format otherwise.
                 
                                                                           
‘'G'’            Floating point format.  Uses uppercase exponential        (4)
                 format if exponent is less than -4 or not less than       
                 precision, decimal format otherwise.
                 
                                                                           
‘'c'’            Single character (accepts integer or single character
                 string).
                 
                                                                           
‘'r'’            String (converts any Python object using                  (5)
                 *note repr(): 3bb.).                                      
                 
                                                                           
‘'s'’            String (converts any Python object using                  (5)
                 *note str(): 25a.).                                       
                 
                                                                           
‘'a'’            String (converts any Python object using                  (5)
                 *note ascii(): 9c3.).                                     
                 
                                                                           
‘'%'’            No argument is converted, results in a ‘'%'’ character
                 in the result.
                 

Notes:

  1. The alternate form causes a leading zero (‘'0'’) to be inserted
     between left-hand padding and the formatting of the number if the
     leading character of the result is not already a zero.

  2. The alternate form causes a leading ‘'0x'’ or ‘'0X'’ (depending on
     whether the ‘'x'’ or ‘'X'’ format was used) to be inserted between
     left-hand padding and the formatting of the number if the leading
     character of the result is not already a zero.

  3. The alternate form causes the result to always contain a decimal
     point, even if no digits follow it.

     The precision determines the number of digits after the decimal
     point and defaults to 6.

  4. The alternate form causes the result to always contain a decimal
     point, and trailing zeroes are not removed as they would otherwise
     be.

     The precision determines the number of significant digits before
     and after the decimal point and defaults to 6.

  5. If precision is ‘N’, the output is truncated to ‘N’ characters.

  7. See PEP 237(2).

Since Python strings have an explicit length, ‘%s’ conversions do not
assume that ‘'\0'’ is the end of the string.

Changed in version 3.1: ‘%f’ conversions for numbers whose absolute
value is over 1e50 are no longer replaced by ‘%g’ conversions.

   ---------- Footnotes ----------

   (1) To format only a tuple you should therefore provide a singleton
tuple whose only element is the tuple to be formatted.

   (2) https://www.python.org/dev/peps/pep-0237


File: python.info,  Node: Binary Sequence Types --- bytes bytearray memoryview,  Next: Set Types --- set frozenset,  Prev: Text Sequence Type --- str,  Up: Built-in Types

5.4.8 Binary Sequence Types — ‘bytes’, ‘bytearray’, ‘memoryview’
----------------------------------------------------------------

The core built-in types for manipulating binary data are *note bytes:
1db. and *note bytearray: 1dc.  They are supported by *note memoryview:
1b7. which uses the *note buffer protocol: ff5. to access the memory of
other binary objects without needing to make a copy.

The *note array: 7. module supports efficient storage of basic data
types like 32-bit integers and IEEE754 double-precision floating values.

* Menu:

* Bytes:: 
* Bytearray Objects:: 
* Bytes and Bytearray Operations:: 
* printf-style Bytes Formatting:: 
* Memory Views:: 


File: python.info,  Node: Bytes,  Next: Bytearray Objects,  Up: Binary Sequence Types --- bytes bytearray memoryview

5.4.8.1 Bytes
.............

Bytes objects are immutable sequences of single bytes.  Since many major
binary protocols are based on the ASCII text encoding, bytes objects
offer several methods that are only valid when working with ASCII
compatible data and are closely related to string objects in a variety
of other ways.

Firstly, the syntax for bytes literals is largely the same as that for
string literals, except that a ‘b’ prefix is added:

   * Single quotes: ‘b'still allows embedded "double" quotes'’

   * Double quotes: ‘b"still allows embedded 'single' quotes"’.

   * Triple quoted: ‘b'''3 single quotes'''’, ‘b"""3 double quotes"""’

Only ASCII characters are permitted in bytes literals (regardless of the
declared source code encoding).  Any binary values over 127 must be
entered into bytes literals using the appropriate escape sequence.

As with string literals, bytes literals may also use a ‘r’ prefix to
disable processing of escape sequences.  See *note String and Bytes
literals: d9f. for more about the various forms of bytes literal,
including supported escape sequences.

While bytes literals and representations are based on ASCII text, bytes
objects actually behave like immutable sequences of integers, with each
value in the sequence restricted such that ‘0 <= x < 256’ (attempts to
violate this restriction will trigger *note ValueError: 19c.  This is
done deliberately to emphasise that while many binary formats include
ASCII based elements and can be usefully manipulated with some
text-oriented algorithms, this is not generally the case for arbitrary
binary data (blindly applying text processing algorithms to binary data
formats that are not ASCII compatible will usually lead to data
corruption).

In addition to the literal forms, bytes objects can be created in a
number of other ways:

   * A zero-filled bytes object of a specified length: ‘bytes(10)’

   * From an iterable of integers: ‘bytes(range(20))’

   * Copying existing binary data via the buffer protocol: ‘bytes(obj)’

Also see the *note bytes: fa1. built-in.

Since 2 hexadecimal digits correspond precisely to a single byte,
hexadecimal numbers are a commonly used format for describing binary
data.  Accordingly, the bytes type has an additional class method to
read data in that format:

 -- Class Method: bytes.fromhex (string)

     This *note bytes: 1db. class method returns a bytes object,
     decoding the given string object.  The string must contain two
     hexadecimal digits per byte, with ASCII spaces being ignored.

          >>> bytes.fromhex('2Ef0 F1f2  ')
          b'.\xf0\xf1\xf2'

A reverse conversion function exists to transform a bytes object into
its hexadecimal representation.

 -- Method: bytes.hex ()

     Return a string object containing two hexadecimal digits for each
     byte in the instance.

          >>> b'\xf0\xf1\xf2'.hex()
          'f0f1f2'

     New in version 3.5.

Since bytes objects are sequences of integers (akin to a tuple), for a
bytes object `b', ‘b[0]’ will be an integer, while ‘b[0:1]’ will be a
bytes object of length 1.  (This contrasts with text strings, where both
indexing and slicing will produce a string of length 1)

The representation of bytes objects uses the literal format (‘b'...'’)
since it is often more useful than e.g.  ‘bytes([46, 46, 46])’.  You can
always convert a bytes object into a list of integers using ‘list(b)’.

     Note: For Python 2.x users: In the Python 2.x series, a variety of
     implicit conversions between 8-bit strings (the closest thing 2.x
     offers to a built-in binary data type) and Unicode strings were
     permitted.  This was a backwards compatibility workaround to
     account for the fact that Python originally only supported 8-bit
     text, and Unicode text was a later addition.  In Python 3.x, those
     implicit conversions are gone - conversions between 8-bit binary
     data and Unicode text must be explicit, and bytes and string
     objects will always compare unequal.


File: python.info,  Node: Bytearray Objects,  Next: Bytes and Bytearray Operations,  Prev: Bytes,  Up: Binary Sequence Types --- bytes bytearray memoryview

5.4.8.2 Bytearray Objects
.........................

*note bytearray: 1dc. objects are a mutable counterpart to *note bytes:
1db. objects.  There is no dedicated literal syntax for bytearray
objects, instead they are always created by calling the constructor:

   * Creating an empty instance: ‘bytearray()’

   * Creating a zero-filled instance with a given length:
     ‘bytearray(10)’

   * From an iterable of integers: ‘bytearray(range(20))’

   * Copying existing binary data via the buffer protocol:
     ‘bytearray(b'Hi!')’

As bytearray objects are mutable, they support the *note mutable: f9d.
sequence operations in addition to the common bytes and bytearray
operations described in *note Bytes and Bytearray Operations: f9e.

Also see the *note bytearray: f9c. built-in.

Since 2 hexadecimal digits correspond precisely to a single byte,
hexadecimal numbers are a commonly used format for describing binary
data.  Accordingly, the bytearray type has an additional class method to
read data in that format:

 -- Class Method: bytearray.fromhex (string)

     This *note bytearray: 1dc. class method returns bytearray object,
     decoding the given string object.  The string must contain two
     hexadecimal digits per byte, with ASCII spaces being ignored.

          >>> bytearray.fromhex('2Ef0 F1f2  ')
          bytearray(b'.\xf0\xf1\xf2')

A reverse conversion function exists to transform a bytearray object
into its hexadecimal representation.

 -- Method: bytearray.hex ()

     Return a string object containing two hexadecimal digits for each
     byte in the instance.

          >>> bytearray(b'\xf0\xf1\xf2').hex()
          'f0f1f2'

     New in version 3.5.

Since bytearray objects are sequences of integers (akin to a list), for
a bytearray object `b', ‘b[0]’ will be an integer, while ‘b[0:1]’ will
be a bytearray object of length 1.  (This contrasts with text strings,
where both indexing and slicing will produce a string of length 1)

The representation of bytearray objects uses the bytes literal format
(‘bytearray(b'...')’) since it is often more useful than e.g.
‘bytearray([46, 46, 46])’.  You can always convert a bytearray object
into a list of integers using ‘list(b)’.


File: python.info,  Node: Bytes and Bytearray Operations,  Next: printf-style Bytes Formatting,  Prev: Bytearray Objects,  Up: Binary Sequence Types --- bytes bytearray memoryview

5.4.8.3 Bytes and Bytearray Operations
......................................

Both bytes and bytearray objects support the *note common: fe6. sequence
operations.  They interoperate not just with operands of the same type,
but with any *note bytes-like object: 36b.  Due to this flexibility,
they can be freely mixed in operations without causing errors.  However,
the return type of the result may depend on the order of operands.

     Note: The methods on bytes and bytearray objects don’t accept
     strings as their arguments, just as the methods on strings don’t
     accept bytes as their arguments.  For example, you have to write:

          a = "abc"
          b = a.replace("a", "f")

     and:

          a = b"abc"
          b = a.replace(b"a", b"f")

Some bytes and bytearray operations assume the use of ASCII compatible
binary formats, and hence should be avoided when working with arbitrary
binary data.  These restrictions are covered below.

     Note: Using these ASCII based operations to manipulate binary data
     that is not stored in an ASCII based format may lead to data
     corruption.

The following methods on bytes and bytearray objects can be used with
arbitrary binary data.

 -- Method: bytes.count (sub[, start[, end]])
 -- Method: bytearray.count (sub[, start[, end]])

     Return the number of non-overlapping occurrences of subsequence
     `sub' in the range [`start', `end'].  Optional arguments `start'
     and `end' are interpreted as in slice notation.

     The subsequence to search for may be any *note bytes-like object:
     36b. or an integer in the range 0 to 255.

     Changed in version 3.3: Also accept an integer in the range 0 to
     255 as the subsequence.

 -- Method: bytes.decode (encoding="utf-8", errors="strict")
 -- Method: bytearray.decode (encoding="utf-8", errors="strict")

     Return a string decoded from the given bytes.  Default encoding is
     ‘'utf-8'’.  `errors' may be given to set a different error handling
     scheme.  The default for `errors' is ‘'strict'’, meaning that
     encoding errors raise a *note UnicodeError: 8a2.  Other possible
     values are ‘'ignore'’, ‘'replace'’ and any other name registered
     via *note codecs.register_error(): a74, see section *note Error
     Handlers: fb2.  For a list of possible encodings, see section *note
     Standard Encodings: 228.

          Note: Passing the `encoding' argument to *note str: 25a.
          allows decoding any *note bytes-like object: 36b. directly,
          without needing to make a temporary bytes or bytearray object.

     Changed in version 3.1: Added support for keyword arguments.

 -- Method: bytes.endswith (suffix[, start[, end]])
 -- Method: bytearray.endswith (suffix[, start[, end]])

     Return ‘True’ if the binary data ends with the specified `suffix',
     otherwise return ‘False’.  `suffix' can also be a tuple of suffixes
     to look for.  With optional `start', test beginning at that
     position.  With optional `end', stop comparing at that position.

     The suffix(es) to search for may be any *note bytes-like object:
     36b.

 -- Method: bytes.find (sub[, start[, end]])
 -- Method: bytearray.find (sub[, start[, end]])

     Return the lowest index in the data where the subsequence `sub' is
     found, such that `sub' is contained in the slice ‘s[start:end]’.
     Optional arguments `start' and `end' are interpreted as in slice
     notation.  Return ‘-1’ if `sub' is not found.

     The subsequence to search for may be any *note bytes-like object:
     36b. or an integer in the range 0 to 255.

          Note: The *note find(): 1021. method should be used only if
          you need to know the position of `sub'.  To check if `sub' is
          a substring or not, use the *note in: 37d. operator:

               >>> b'Py' in b'Python'
               True

     Changed in version 3.3: Also accept an integer in the range 0 to
     255 as the subsequence.

 -- Method: bytes.index (sub[, start[, end]])
 -- Method: bytearray.index (sub[, start[, end]])

     Like *note find(): 1021, but raise *note ValueError: 19c. when the
     subsequence is not found.

     The subsequence to search for may be any *note bytes-like object:
     36b. or an integer in the range 0 to 255.

     Changed in version 3.3: Also accept an integer in the range 0 to
     255 as the subsequence.

 -- Method: bytes.join (iterable)
 -- Method: bytearray.join (iterable)

     Return a bytes or bytearray object which is the concatenation of
     the binary data sequences in the *note iterable: 80a. `iterable'.
     A *note TypeError: 562. will be raised if there are any values in
     `iterable' that are not *note bytes-like objects: 36b, including
     *note str: 25a. objects.  The separator between elements is the
     contents of the bytes or bytearray object providing this method.

 -- Static Method: bytes.maketrans (from, to)
 -- Static Method: bytearray.maketrans (from, to)

     This static method returns a translation table usable for *note
     bytes.translate(): 1026. that will map each character in `from'
     into the character at the same position in `to'; `from' and `to'
     must both be *note bytes-like objects: 36b. and have the same
     length.

     New in version 3.1.

 -- Method: bytes.partition (sep)
 -- Method: bytearray.partition (sep)

     Split the sequence at the first occurrence of `sep', and return a
     3-tuple containing the part before the separator, the separator,
     and the part after the separator.  If the separator is not found,
     return a 3-tuple containing a copy of the original sequence,
     followed by two empty bytes or bytearray objects.

     The separator to search for may be any *note bytes-like object:
     36b.

 -- Method: bytes.replace (old, new[, count])
 -- Method: bytearray.replace (old, new[, count])

     Return a copy of the sequence with all occurrences of subsequence
     `old' replaced by `new'.  If the optional argument `count' is
     given, only the first `count' occurrences are replaced.

     The subsequence to search for and its replacement may be any *note
     bytes-like object: 36b.

          Note: The bytearray version of this method does `not' operate
          in place - it always produces a new object, even if no changes
          were made.

 -- Method: bytes.rfind (sub[, start[, end]])
 -- Method: bytearray.rfind (sub[, start[, end]])

     Return the highest index in the sequence where the subsequence
     `sub' is found, such that `sub' is contained within ‘s[start:end]’.
     Optional arguments `start' and `end' are interpreted as in slice
     notation.  Return ‘-1’ on failure.

     The subsequence to search for may be any *note bytes-like object:
     36b. or an integer in the range 0 to 255.

     Changed in version 3.3: Also accept an integer in the range 0 to
     255 as the subsequence.

 -- Method: bytes.rindex (sub[, start[, end]])
 -- Method: bytearray.rindex (sub[, start[, end]])

     Like *note rfind(): 102b. but raises *note ValueError: 19c. when
     the subsequence `sub' is not found.

     The subsequence to search for may be any *note bytes-like object:
     36b. or an integer in the range 0 to 255.

     Changed in version 3.3: Also accept an integer in the range 0 to
     255 as the subsequence.

 -- Method: bytes.rpartition (sep)
 -- Method: bytearray.rpartition (sep)

     Split the sequence at the last occurrence of `sep', and return a
     3-tuple containing the part before the separator, the separator,
     and the part after the separator.  If the separator is not found,
     return a 3-tuple containing a copy of the original sequence,
     followed by two empty bytes or bytearray objects.

     The separator to search for may be any *note bytes-like object:
     36b.

 -- Method: bytes.startswith (prefix[, start[, end]])
 -- Method: bytearray.startswith (prefix[, start[, end]])

     Return ‘True’ if the binary data starts with the specified
     `prefix', otherwise return ‘False’.  `prefix' can also be a tuple
     of prefixes to look for.  With optional `start', test beginning at
     that position.  With optional `end', stop comparing at that
     position.

     The prefix(es) to search for may be any *note bytes-like object:
     36b.

 -- Method: bytes.translate (table[, delete])
 -- Method: bytearray.translate (table[, delete])

     Return a copy of the bytes or bytearray object where all bytes
     occurring in the optional argument `delete' are removed, and the
     remaining bytes have been mapped through the given translation
     table, which must be a bytes object of length 256.

     You can use the *note bytes.maketrans(): 86a. method to create a
     translation table.

     Set the `table' argument to ‘None’ for translations that only
     delete characters:

          >>> b'read this short text'.translate(None, b'aeiou')
          b'rd ths shrt txt'

The following methods on bytes and bytearray objects have default
behaviours that assume the use of ASCII compatible binary formats, but
can still be used with arbitrary binary data by passing appropriate
arguments.  Note that all of the bytearray methods in this section do
`not' operate in place, and instead produce new objects.

 -- Method: bytes.center (width[, fillbyte])
 -- Method: bytearray.center (width[, fillbyte])

     Return a copy of the object centered in a sequence of length
     `width'.  Padding is done using the specified `fillbyte' (default
     is an ASCII space).  For *note bytes: 1db. objects, the original
     sequence is returned if `width' is less than or equal to ‘len(s)’.

          Note: The bytearray version of this method does `not' operate
          in place - it always produces a new object, even if no changes
          were made.

 -- Method: bytes.ljust (width[, fillbyte])
 -- Method: bytearray.ljust (width[, fillbyte])

     Return a copy of the object left justified in a sequence of length
     `width'.  Padding is done using the specified `fillbyte' (default
     is an ASCII space).  For *note bytes: 1db. objects, the original
     sequence is returned if `width' is less than or equal to ‘len(s)’.

          Note: The bytearray version of this method does `not' operate
          in place - it always produces a new object, even if no changes
          were made.

 -- Method: bytes.lstrip ([chars])
 -- Method: bytearray.lstrip ([chars])

     Return a copy of the sequence with specified leading bytes removed.
     The `chars' argument is a binary sequence specifying the set of
     byte values to be removed - the name refers to the fact this method
     is usually used with ASCII characters.  If omitted or ‘None’, the
     `chars' argument defaults to removing ASCII whitespace.  The
     `chars' argument is not a prefix; rather, all combinations of its
     values are stripped:

          >>> b'   spacious   '.lstrip()
          b'spacious   '
          >>> b'www.example.com'.lstrip(b'cmowz.')
          b'example.com'

     The binary sequence of byte values to remove may be any *note
     bytes-like object: 36b.

          Note: The bytearray version of this method does `not' operate
          in place - it always produces a new object, even if no changes
          were made.

 -- Method: bytes.rjust (width[, fillbyte])
 -- Method: bytearray.rjust (width[, fillbyte])

     Return a copy of the object right justified in a sequence of length
     `width'.  Padding is done using the specified `fillbyte' (default
     is an ASCII space).  For *note bytes: 1db. objects, the original
     sequence is returned if `width' is less than or equal to ‘len(s)’.

          Note: The bytearray version of this method does `not' operate
          in place - it always produces a new object, even if no changes
          were made.

 -- Method: bytes.rsplit (sep=None, maxsplit=-1)
 -- Method: bytearray.rsplit (sep=None, maxsplit=-1)

     Split the binary sequence into subsequences of the same type, using
     `sep' as the delimiter string.  If `maxsplit' is given, at most
     `maxsplit' splits are done, the `rightmost' ones.  If `sep' is not
     specified or ‘None’, any subsequence consisting solely of ASCII
     whitespace is a separator.  Except for splitting from the right,
     *note rsplit(): 103c. behaves like *note split(): 103d. which is
     described in detail below.

 -- Method: bytes.rstrip ([chars])
 -- Method: bytearray.rstrip ([chars])

     Return a copy of the sequence with specified trailing bytes
     removed.  The `chars' argument is a binary sequence specifying the
     set of byte values to be removed - the name refers to the fact this
     method is usually used with ASCII characters.  If omitted or
     ‘None’, the `chars' argument defaults to removing ASCII whitespace.
     The `chars' argument is not a suffix; rather, all combinations of
     its values are stripped:

          >>> b'   spacious   '.rstrip()
          b'   spacious'
          >>> b'mississippi'.rstrip(b'ipz')
          b'mississ'

     The binary sequence of byte values to remove may be any *note
     bytes-like object: 36b.

          Note: The bytearray version of this method does `not' operate
          in place - it always produces a new object, even if no changes
          were made.

 -- Method: bytes.split (sep=None, maxsplit=-1)
 -- Method: bytearray.split (sep=None, maxsplit=-1)

     Split the binary sequence into subsequences of the same type, using
     `sep' as the delimiter string.  If `maxsplit' is given and
     non-negative, at most `maxsplit' splits are done (thus, the list
     will have at most ‘maxsplit+1’ elements).  If `maxsplit' is not
     specified or is ‘-1’, then there is no limit on the number of
     splits (all possible splits are made).

     If `sep' is given, consecutive delimiters are not grouped together
     and are deemed to delimit empty subsequences (for example,
     ‘b'1,,2'.split(b',')’ returns ‘[b'1', b'', b'2']’).  The `sep'
     argument may consist of a multibyte sequence (for example,
     ‘b'1<>2<>3'.split(b'<>')’ returns ‘[b'1', b'2', b'3']’).  Splitting
     an empty sequence with a specified separator returns ‘[b'']’ or
     ‘[bytearray(b'')]’ depending on the type of object being split.
     The `sep' argument may be any *note bytes-like object: 36b.

     For example:

          >>> b'1,2,3'.split(b',')
          [b'1', b'2', b'3']
          >>> b'1,2,3'.split(b',', maxsplit=1)
          [b'1', b'2,3']
          >>> b'1,2,,3,'.split(b',')
          [b'1', b'2', b'', b'3', b'']

     If `sep' is not specified or is ‘None’, a different splitting
     algorithm is applied: runs of consecutive ASCII whitespace are
     regarded as a single separator, and the result will contain no
     empty strings at the start or end if the sequence has leading or
     trailing whitespace.  Consequently, splitting an empty sequence or
     a sequence consisting solely of ASCII whitespace without a
     specified separator returns ‘[]’.

     For example:

          >>> b'1 2 3'.split()
          [b'1', b'2', b'3']
          >>> b'1 2 3'.split(maxsplit=1)
          [b'1', b'2 3']
          >>> b'   1   2   3   '.split()
          [b'1', b'2', b'3']

 -- Method: bytes.strip ([chars])
 -- Method: bytearray.strip ([chars])

     Return a copy of the sequence with specified leading and trailing
     bytes removed.  The `chars' argument is a binary sequence
     specifying the set of byte values to be removed - the name refers
     to the fact this method is usually used with ASCII characters.  If
     omitted or ‘None’, the `chars' argument defaults to removing ASCII
     whitespace.  The `chars' argument is not a prefix or suffix;
     rather, all combinations of its values are stripped:

          >>> b'   spacious   '.strip()
          b'spacious'
          >>> b'www.example.com'.strip(b'cmowz.')
          b'example'

     The binary sequence of byte values to remove may be any *note
     bytes-like object: 36b.

          Note: The bytearray version of this method does `not' operate
          in place - it always produces a new object, even if no changes
          were made.

The following methods on bytes and bytearray objects assume the use of
ASCII compatible binary formats and should not be applied to arbitrary
binary data.  Note that all of the bytearray methods in this section do
`not' operate in place, and instead produce new objects.

 -- Method: bytes.capitalize ()
 -- Method: bytearray.capitalize ()

     Return a copy of the sequence with each byte interpreted as an
     ASCII character, and the first byte capitalized and the rest
     lowercased.  Non-ASCII byte values are passed through unchanged.

          Note: The bytearray version of this method does `not' operate
          in place - it always produces a new object, even if no changes
          were made.

 -- Method: bytes.expandtabs (tabsize=8)
 -- Method: bytearray.expandtabs (tabsize=8)

     Return a copy of the sequence where all ASCII tab characters are
     replaced by one or more ASCII spaces, depending on the current
     column and the given tab size.  Tab positions occur every `tabsize'
     bytes (default is 8, giving tab positions at columns 0, 8, 16 and
     so on).  To expand the sequence, the current column is set to zero
     and the sequence is examined byte by byte.  If the byte is an ASCII
     tab character (‘b'\t'’), one or more space characters are inserted
     in the result until the current column is equal to the next tab
     position.  (The tab character itself is not copied.)  If the
     current byte is an ASCII newline (‘b'\n'’) or carriage return
     (‘b'\r'’), it is copied and the current column is reset to zero.
     Any other byte value is copied unchanged and the current column is
     incremented by one regardless of how the byte value is represented
     when printed:

          >>> b'01\t012\t0123\t01234'.expandtabs()
          b'01      012     0123    01234'
          >>> b'01\t012\t0123\t01234'.expandtabs(4)
          b'01  012 0123    01234'

          Note: The bytearray version of this method does `not' operate
          in place - it always produces a new object, even if no changes
          were made.

 -- Method: bytes.isalnum ()
 -- Method: bytearray.isalnum ()

     Return true if all bytes in the sequence are alphabetical ASCII
     characters or ASCII decimal digits and the sequence is not empty,
     false otherwise.  Alphabetic ASCII characters are those byte values
     in the sequence
     ‘b'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ'’.  ASCII
     decimal digits are those byte values in the sequence
     ‘b'0123456789'’.

     For example:

          >>> b'ABCabc1'.isalnum()
          True
          >>> b'ABC abc1'.isalnum()
          False

 -- Method: bytes.isalpha ()
 -- Method: bytearray.isalpha ()

     Return true if all bytes in the sequence are alphabetic ASCII
     characters and the sequence is not empty, false otherwise.
     Alphabetic ASCII characters are those byte values in the sequence
     ‘b'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ'’.

     For example:

          >>> b'ABCabc'.isalpha()
          True
          >>> b'ABCabc1'.isalpha()
          False

 -- Method: bytes.isdigit ()
 -- Method: bytearray.isdigit ()

     Return true if all bytes in the sequence are ASCII decimal digits
     and the sequence is not empty, false otherwise.  ASCII decimal
     digits are those byte values in the sequence ‘b'0123456789'’.

     For example:

          >>> b'1234'.isdigit()
          True
          >>> b'1.23'.isdigit()
          False

 -- Method: bytes.islower ()
 -- Method: bytearray.islower ()

     Return true if there is at least one lowercase ASCII character in
     the sequence and no uppercase ASCII characters, false otherwise.

     For example:

          >>> b'hello world'.islower()
          True
          >>> b'Hello world'.islower()
          False

     Lowercase ASCII characters are those byte values in the sequence
     ‘b'abcdefghijklmnopqrstuvwxyz'’.  Uppercase ASCII characters are
     those byte values in the sequence ‘b'ABCDEFGHIJKLMNOPQRSTUVWXYZ'’.

 -- Method: bytes.isspace ()
 -- Method: bytearray.isspace ()

     Return true if all bytes in the sequence are ASCII whitespace and
     the sequence is not empty, false otherwise.  ASCII whitespace
     characters are those byte values in the sequence ‘b' \t\n\r\x0b\f'’
     (space, tab, newline, carriage return, vertical tab, form feed).

 -- Method: bytes.istitle ()
 -- Method: bytearray.istitle ()

     Return true if the sequence is ASCII titlecase and the sequence is
     not empty, false otherwise.  See *note bytes.title(): 1053. for
     more details on the definition of "titlecase".

     For example:

          >>> b'Hello World'.istitle()
          True
          >>> b'Hello world'.istitle()
          False

 -- Method: bytes.isupper ()
 -- Method: bytearray.isupper ()

     Return true if there is at least one uppercase alphabetic ASCII
     character in the sequence and no lowercase ASCII characters, false
     otherwise.

     For example:

          >>> b'HELLO WORLD'.isupper()
          True
          >>> b'Hello world'.isupper()
          False

     Lowercase ASCII characters are those byte values in the sequence
     ‘b'abcdefghijklmnopqrstuvwxyz'’.  Uppercase ASCII characters are
     those byte values in the sequence ‘b'ABCDEFGHIJKLMNOPQRSTUVWXYZ'’.

 -- Method: bytes.lower ()
 -- Method: bytearray.lower ()

     Return a copy of the sequence with all the uppercase ASCII
     characters converted to their corresponding lowercase counterpart.

     For example:

          >>> b'Hello World'.lower()
          b'hello world'

     Lowercase ASCII characters are those byte values in the sequence
     ‘b'abcdefghijklmnopqrstuvwxyz'’.  Uppercase ASCII characters are
     those byte values in the sequence ‘b'ABCDEFGHIJKLMNOPQRSTUVWXYZ'’.

          Note: The bytearray version of this method does `not' operate
          in place - it always produces a new object, even if no changes
          were made.

 -- Method: bytes.splitlines (keepends=False)
 -- Method: bytearray.splitlines (keepends=False)

     Return a list of the lines in the binary sequence, breaking at
     ASCII line boundaries.  This method uses the *note universal
     newlines: 994. approach to splitting lines.  Line breaks are not
     included in the resulting list unless `keepends' is given and true.

     For example:

          >>> b'ab c\n\nde fg\rkl\r\n'.splitlines()
          [b'ab c', b'', b'de fg', b'kl']
          >>> b'ab c\n\nde fg\rkl\r\n'.splitlines(keepends=True)
          [b'ab c\n', b'\n', b'de fg\r', b'kl\r\n']

     Unlike *note split(): 1040. when a delimiter string `sep' is given,
     this method returns an empty list for the empty string, and a
     terminal line break does not result in an extra line:

          >>> b"".split(b'\n'), b"Two lines\n".split(b'\n')
          ([b''], [b'Two lines', b''])
          >>> b"".splitlines(), b"One line\n".splitlines()
          ([], [b'One line'])

 -- Method: bytes.swapcase ()
 -- Method: bytearray.swapcase ()

     Return a copy of the sequence with all the lowercase ASCII
     characters converted to their corresponding uppercase counterpart
     and vice-versa.

     For example:

          >>> b'Hello World'.swapcase()
          b'hELLO wORLD'

     Lowercase ASCII characters are those byte values in the sequence
     ‘b'abcdefghijklmnopqrstuvwxyz'’.  Uppercase ASCII characters are
     those byte values in the sequence ‘b'ABCDEFGHIJKLMNOPQRSTUVWXYZ'’.

     Unlike *note str.swapcase(): 1013, it is always the case that
     ‘bin.swapcase().swapcase() == bin’ for the binary versions.  Case
     conversions are symmetrical in ASCII, even though that is not
     generally true for arbitrary Unicode code points.

          Note: The bytearray version of this method does `not' operate
          in place - it always produces a new object, even if no changes
          were made.

 -- Method: bytes.title ()
 -- Method: bytearray.title ()

     Return a titlecased version of the binary sequence where words
     start with an uppercase ASCII character and the remaining
     characters are lowercase.  Uncased byte values are left unmodified.

     For example:

          >>> b'Hello world'.title()
          b'Hello World'

     Lowercase ASCII characters are those byte values in the sequence
     ‘b'abcdefghijklmnopqrstuvwxyz'’.  Uppercase ASCII characters are
     those byte values in the sequence ‘b'ABCDEFGHIJKLMNOPQRSTUVWXYZ'’.
     All other byte values are uncased.

     The algorithm uses a simple language-independent definition of a
     word as groups of consecutive letters.  The definition works in
     many contexts but it means that apostrophes in contractions and
     possessives form word boundaries, which may not be the desired
     result:

          >>> b"they're bill's friends from the UK".title()
          b"They'Re Bill'S Friends From The Uk"

     A workaround for apostrophes can be constructed using regular
     expressions:

          >>> import re
          >>> def titlecase(s):
          ...     return re.sub(rb"[A-Za-z]+('[A-Za-z]+)?",
          ...                   lambda mo: mo.group(0)[0:1].upper() +
          ...                              mo.group(0)[1:].lower(),
          ...                   s)
          ...
          >>> titlecase(b"they're bill's friends.")
          b"They're Bill's Friends."

          Note: The bytearray version of this method does `not' operate
          in place - it always produces a new object, even if no changes
          were made.

 -- Method: bytes.upper ()
 -- Method: bytearray.upper ()

     Return a copy of the sequence with all the lowercase ASCII
     characters converted to their corresponding uppercase counterpart.

     For example:

          >>> b'Hello World'.upper()
          b'HELLO WORLD'

     Lowercase ASCII characters are those byte values in the sequence
     ‘b'abcdefghijklmnopqrstuvwxyz'’.  Uppercase ASCII characters are
     those byte values in the sequence ‘b'ABCDEFGHIJKLMNOPQRSTUVWXYZ'’.

          Note: The bytearray version of this method does `not' operate
          in place - it always produces a new object, even if no changes
          were made.

 -- Method: bytes.zfill (width)
 -- Method: bytearray.zfill (width)

     Return a copy of the sequence left filled with ASCII ‘b'0'’ digits
     to make a sequence of length `width'.  A leading sign prefix
     (‘b'+'’/ ‘b'-'’ is handled by inserting the padding `after' the
     sign character rather than before.  For *note bytes: 1db. objects,
     the original sequence is returned if `width' is less than or equal
     to ‘len(seq)’.

     For example:

          >>> b"42".zfill(5)
          b'00042'
          >>> b"-42".zfill(5)
          b'-0042'

          Note: The bytearray version of this method does `not' operate
          in place - it always produces a new object, even if no changes
          were made.


File: python.info,  Node: printf-style Bytes Formatting,  Next: Memory Views,  Prev: Bytes and Bytearray Operations,  Up: Binary Sequence Types --- bytes bytearray memoryview

5.4.8.4 ‘printf’-style Bytes Formatting
.......................................

     Note: The formatting operations described here exhibit a variety of
     quirks that lead to a number of common errors (such as failing to
     display tuples and dictionaries correctly).  If the value being
     printed may be a tuple or dictionary, wrap it in a tuple.

Bytes objects (‘bytes’/‘bytearray’) have one unique built-in operation:
the ‘%’ operator (modulo).  This is also known as the bytes `formatting'
or `interpolation' operator.  Given ‘format % values’ (where `format' is
a bytes object), ‘%’ conversion specifications in `format' are replaced
with zero or more elements of `values'.  The effect is similar to using
the ‘sprintf()’ in the C language.

If `format' requires a single argument, `values' may be a single
non-tuple object.  (1) Otherwise, `values' must be a tuple with exactly
the number of items specified by the format bytes object, or a single
mapping object (for example, a dictionary).

A conversion specifier contains two or more characters and has the
following components, which must occur in this order:

  1. The ‘'%'’ character, which marks the start of the specifier.

  2. Mapping key (optional), consisting of a parenthesised sequence of
     characters (for example, ‘(somename)’).

  3. Conversion flags (optional), which affect the result of some
     conversion types.

  4. Minimum field width (optional).  If specified as an ‘'*'’
     (asterisk), the actual width is read from the next element of the
     tuple in `values', and the object to convert comes after the
     minimum field width and optional precision.

  5. Precision (optional), given as a ‘'.'’ (dot) followed by the
     precision.  If specified as ‘'*'’ (an asterisk), the actual
     precision is read from the next element of the tuple in `values',
     and the value to convert comes after the precision.

  6. Length modifier (optional).

  7. Conversion type.

When the right argument is a dictionary (or other mapping type), then
the formats in the bytes object `must' include a parenthesised mapping
key into that dictionary inserted immediately after the ‘'%'’ character.
The mapping key selects the value to be formatted from the mapping.  For
example:

     >>> print(b'%(language)s has %(number)03d quote types.' %
     ...       {b'language': b"Python", b"number": 2})
     b'Python has 002 quote types.'

In this case no ‘*’ specifiers may occur in a format (since they require
a sequential parameter list).

The conversion flag characters are:

Flag          Meaning
              
----------------------------------------------------------------------------------------
              
‘'#'’         The value conversion will use the "alternate form" (where defined
              below).
              
              
‘'0'’         The conversion will be zero padded for numeric values.
              
              
‘'-'’         The converted value is left adjusted (overrides the ‘'0'’ conversion if
              both are given).
              
              
‘' '’         (a space) A blank should be left before a positive number (or empty
              string) produced by a signed conversion.
              
              
‘'+'’         A sign character (‘'+'’ or ‘'-'’) will precede the conversion
              (overrides a "space" flag).
              

A length modifier (‘h’, ‘l’, or ‘L’) may be present, but is ignored as
it is not necessary for Python – so e.g.  ‘%ld’ is identical to ‘%d’.

The conversion types are:

Conversion       Meaning                                                   Notes
                                                                           
---------------------------------------------------------------------------------------
                                                                           
‘'d'’            Signed integer decimal.
                 
                                                                           
‘'i'’            Signed integer decimal.
                 
                                                                           
‘'o'’            Signed octal value.                                       (1)
                                                                           
                                                                           
‘'u'’            Obsolete type – it is identical to ‘'d'’.                 (8)
                                                                           
                                                                           
‘'x'’            Signed hexadecimal (lowercase).                           (2)
                                                                           
                                                                           
‘'X'’            Signed hexadecimal (uppercase).                           (2)
                                                                           
                                                                           
‘'e'’            Floating point exponential format (lowercase).            (3)
                                                                           
                                                                           
‘'E'’            Floating point exponential format (uppercase).            (3)
                                                                           
                                                                           
‘'f'’            Floating point decimal format.                            (3)
                                                                           
                                                                           
‘'F'’            Floating point decimal format.                            (3)
                                                                           
                                                                           
‘'g'’            Floating point format.  Uses lowercase exponential        (4)
                 format if exponent is less than -4 or not less than       
                 precision, decimal format otherwise.
                 
                                                                           
‘'G'’            Floating point format.  Uses uppercase exponential        (4)
                 format if exponent is less than -4 or not less than       
                 precision, decimal format otherwise.
                 
                                                                           
‘'c'’            Single byte (accepts integer or single byte objects).
                 
                                                                           
‘'b'’            Bytes (any object that follows the                        (5)
                 *note buffer protocol: ff5. or has                        
                 *note __bytes__(): dfb.).
                 
                                                                           
‘'s'’            ‘'s'’ is an alias for ‘'b'’ and should only be used for   (6)
                 Python2/3 code bases.                                     
                 
                                                                           
‘'a'’            Bytes (converts any Python object using                   (5)
                 ‘repr(obj).encode('ascii','backslashreplace)’).           
                 
                                                                           
‘'r'’            ‘'r'’ is an alias for ‘'a'’ and should only be used for   (7)
                 Python2/3 code bases.                                     
                 
                                                                           
‘'%'’            No argument is converted, results in a ‘'%'’ character
                 in the result.
                 

Notes:

  1. The alternate form causes a leading zero (‘'0'’) to be inserted
     between left-hand padding and the formatting of the number if the
     leading character of the result is not already a zero.

  2. The alternate form causes a leading ‘'0x'’ or ‘'0X'’ (depending on
     whether the ‘'x'’ or ‘'X'’ format was used) to be inserted between
     left-hand padding and the formatting of the number if the leading
     character of the result is not already a zero.

  3. The alternate form causes the result to always contain a decimal
     point, even if no digits follow it.

     The precision determines the number of digits after the decimal
     point and defaults to 6.

  4. The alternate form causes the result to always contain a decimal
     point, and trailing zeroes are not removed as they would otherwise
     be.

     The precision determines the number of significant digits before
     and after the decimal point and defaults to 6.

  5. If precision is ‘N’, the output is truncated to ‘N’ characters.

  6. ‘b'%s'’ is deprecated, but will not be removed during the 3.x
     series.

  7. ‘b'%r'’ is deprecated, but will not be removed during the 3.x
     series.

  8. See PEP 237(2).

     Note: The bytearray version of this method does `not' operate in
     place - it always produces a new object, even if no changes were
     made.

See also
........

PEP 461(3).

New in version 3.5.

   ---------- Footnotes ----------

   (1) To format only a tuple you should therefore provide a singleton
tuple whose only element is the tuple to be formatted.

   (2) https://www.python.org/dev/peps/pep-0237

   (3) https://www.python.org/dev/peps/pep-0461


File: python.info,  Node: Memory Views,  Prev: printf-style Bytes Formatting,  Up: Binary Sequence Types --- bytes bytearray memoryview

5.4.8.5 Memory Views
....................

*note memoryview: 1b7. objects allow Python code to access the internal
data of an object that supports the *note buffer protocol: ff5. without
copying.

 -- Class: memoryview (obj)

     Create a *note memoryview: 1b7. that references `obj'.  `obj' must
     support the buffer protocol.  Built-in objects that support the
     buffer protocol include *note bytes: 1db. and *note bytearray: 1dc.

     A *note memoryview: 1b7. has the notion of an `element', which is
     the atomic memory unit handled by the originating object `obj'.
     For many simple types such as *note bytes: 1db. and *note
     bytearray: 1dc, an element is a single byte, but other types such
     as *note array.array: 8c4. may have bigger elements.

     ‘len(view)’ is equal to the length of *note tolist: 1063.  If
     ‘view.ndim = 0’, the length is 1.  If ‘view.ndim = 1’, the length
     is equal to the number of elements in the view.  For higher
     dimensions, the length is equal to the length of the nested list
     representation of the view.  The *note itemsize: 1064. attribute
     will give you the number of bytes in a single element.

     A *note memoryview: 1b7. supports slicing and indexing to expose
     its data.  One-dimensional slicing will result in a subview:

          >>> v = memoryview(b'abcefg')
          >>> v[1]
          98
          >>> v[-1]
          103
          >>> v[1:4]
          <memory at 0x7f3ddc9f4350>
          >>> bytes(v[1:4])
          b'bce'

     If *note format: 1065. is one of the native format specifiers from
     the *note struct: f6. module, indexing with an integer or a tuple
     of integers is also supported and returns a single `element' with
     the correct type.  One-dimensional memoryviews can be indexed with
     an integer or a one-integer tuple.  Multi-dimensional memoryviews
     can be indexed with tuples of exactly `ndim' integers where `ndim'
     is the number of dimensions.  Zero-dimensional memoryviews can be
     indexed with the empty tuple.

     Here is an example with a non-byte format:

          >>> import array
          >>> a = array.array('l', [-11111111, 22222222, -33333333, 44444444])
          >>> m = memoryview(a)
          >>> m[0]
          -11111111
          >>> m[-1]
          44444444
          >>> m[::2].tolist()
          [-11111111, -33333333]

     If the underlying object is writable, the memoryview supports
     one-dimensional slice assignment.  Resizing is not allowed:

          >>> data = bytearray(b'abcefg')
          >>> v = memoryview(data)
          >>> v.readonly
          False
          >>> v[0] = ord(b'z')
          >>> data
          bytearray(b'zbcefg')
          >>> v[1:4] = b'123'
          >>> data
          bytearray(b'z123fg')
          >>> v[2:3] = b'spam'
          Traceback (most recent call last):
            File "<stdin>", line 1, in <module>
          ValueError: memoryview assignment: lvalue and rvalue have different structures
          >>> v[2:6] = b'spam'
          >>> data
          bytearray(b'z1spam')

     One-dimensional memoryviews of hashable (read-only) types with
     formats ’B’, ’b’ or ’c’ are also hashable.  The hash is defined as
     ‘hash(m) == hash(m.tobytes())’:

          >>> v = memoryview(b'abcefg')
          >>> hash(v) == hash(b'abcefg')
          True
          >>> hash(v[2:4]) == hash(b'ce')
          True
          >>> hash(v[::-2]) == hash(b'abcefg'[::-2])
          True

     Changed in version 3.3: One-dimensional memoryviews can now be
     sliced.  One-dimensional memoryviews with formats ’B’, ’b’ or ’c’
     are now hashable.

     Changed in version 3.4: memoryview is now registered automatically
     with *note collections.abc.Sequence: fe7.

     Changed in version 3.5: memoryviews can now be indexed with tuple
     of integers.

     *note memoryview: 1b7. has several methods:

      -- Method: __eq__ (exporter)

          A memoryview and a PEP 3118(1) exporter are equal if their
          shapes are equivalent and if all corresponding values are
          equal when the operands’ respective format codes are
          interpreted using *note struct: f6. syntax.

          For the subset of *note struct: f6. format strings currently
          supported by *note tolist(): 1063, ‘v’ and ‘w’ are equal if
          ‘v.tolist() == w.tolist()’:

               >>> import array
               >>> a = array.array('I', [1, 2, 3, 4, 5])
               >>> b = array.array('d', [1.0, 2.0, 3.0, 4.0, 5.0])
               >>> c = array.array('b', [5, 3, 1])
               >>> x = memoryview(a)
               >>> y = memoryview(b)
               >>> x == a == y == b
               True
               >>> x.tolist() == a.tolist() == y.tolist() == b.tolist()
               True
               >>> z = y[::-2]
               >>> z == c
               True
               >>> z.tolist() == c.tolist()
               True

          If either format string is not supported by the *note struct:
          f6. module, then the objects will always compare as unequal
          (even if the format strings and buffer contents are
          identical):

               >>> from ctypes import BigEndianStructure, c_long
               >>> class BEPoint(BigEndianStructure):
               ...     _fields_ = [("x", c_long), ("y", c_long)]
               ...
               >>> point = BEPoint(100, 200)
               >>> a = memoryview(point)
               >>> b = memoryview(point)
               >>> a == point
               False
               >>> a == b
               False

          Note that, as with floating point numbers, ‘v is w’ does `not'
          imply ‘v == w’ for memoryview objects.

          Changed in version 3.3: Previous versions compared the raw
          memory disregarding the item format and the logical array
          structure.

      -- Method: tobytes ()

          Return the data in the buffer as a bytestring.  This is
          equivalent to calling the *note bytes: 1db. constructor on the
          memoryview.

               >>> m = memoryview(b"abc")
               >>> m.tobytes()
               b'abc'
               >>> bytes(m)
               b'abc'

          For non-contiguous arrays the result is equal to the flattened
          list representation with all elements converted to bytes.
          *note tobytes(): 1067. supports all format strings, including
          those that are not in *note struct: f6. module syntax.

      -- Method: hex ()

          Return a string object containing two hexadecimal digits for
          each byte in the buffer.

               >>> m = memoryview(b"abc")
               >>> m.hex()
               '616263'

          New in version 3.5.

      -- Method: tolist ()

          Return the data in the buffer as a list of elements.

               >>> memoryview(b'abc').tolist()
               [97, 98, 99]
               >>> import array
               >>> a = array.array('d', [1.1, 2.2, 3.3])
               >>> m = memoryview(a)
               >>> m.tolist()
               [1.1, 2.2, 3.3]

          Changed in version 3.3: *note tolist(): 1063. now supports all
          single character native formats in *note struct: f6. module
          syntax as well as multi-dimensional representations.

      -- Method: release ()

          Release the underlying buffer exposed by the memoryview
          object.  Many objects take special actions when a view is held
          on them (for example, a *note bytearray: 1dc. would
          temporarily forbid resizing); therefore, calling release() is
          handy to remove these restrictions (and free any dangling
          resources) as soon as possible.

          After this method has been called, any further operation on
          the view raises a *note ValueError: 19c. (except *note
          release(): 784. itself which can be called multiple times):

               >>> m = memoryview(b'abc')
               >>> m.release()
               >>> m[0]
               Traceback (most recent call last):
                 File "<stdin>", line 1, in <module>
               ValueError: operation forbidden on released memoryview object

          The context management protocol can be used for a similar
          effect, using the ‘with’ statement:

               >>> with memoryview(b'abc') as m:
               ...     m[0]
               ...
               97
               >>> m[0]
               Traceback (most recent call last):
                 File "<stdin>", line 1, in <module>
               ValueError: operation forbidden on released memoryview object

          New in version 3.2.

      -- Method: cast (format[, shape])

          Cast a memoryview to a new format or shape.  `shape' defaults
          to ‘[byte_length//new_itemsize]’, which means that the result
          view will be one-dimensional.  The return value is a new
          memoryview, but the buffer itself is not copied.  Supported
          casts are 1D -> C-*note contiguous: 1069. and C-contiguous ->
          1D.

          The destination format is restricted to a single element
          native format in *note struct: f6. syntax.  One of the formats
          must be a byte format (’B’, ’b’ or ’c’).  The byte length of
          the result must be the same as the original length.

          Cast 1D/long to 1D/unsigned bytes:

               >>> import array
               >>> a = array.array('l', [1,2,3])
               >>> x = memoryview(a)
               >>> x.format
               'l'
               >>> x.itemsize
               8
               >>> len(x)
               3
               >>> x.nbytes
               24
               >>> y = x.cast('B')
               >>> y.format
               'B'
               >>> y.itemsize
               1
               >>> len(y)
               24
               >>> y.nbytes
               24

          Cast 1D/unsigned bytes to 1D/char:

               >>> b = bytearray(b'zyz')
               >>> x = memoryview(b)
               >>> x[0] = b'a'
               Traceback (most recent call last):
                 File "<stdin>", line 1, in <module>
               ValueError: memoryview: invalid value for format "B"
               >>> y = x.cast('c')
               >>> y[0] = b'a'
               >>> b
               bytearray(b'ayz')

          Cast 1D/bytes to 3D/ints to 1D/signed char:

               >>> import struct
               >>> buf = struct.pack("i"*12, *list(range(12)))
               >>> x = memoryview(buf)
               >>> y = x.cast('i', shape=[2,2,3])
               >>> y.tolist()
               [[[0, 1, 2], [3, 4, 5]], [[6, 7, 8], [9, 10, 11]]]
               >>> y.format
               'i'
               >>> y.itemsize
               4
               >>> len(y)
               2
               >>> y.nbytes
               48
               >>> z = y.cast('b')
               >>> z.format
               'b'
               >>> z.itemsize
               1
               >>> len(z)
               48
               >>> z.nbytes
               48

          Cast 1D/unsigned char to 2D/unsigned long:

               >>> buf = struct.pack("L"*6, *list(range(6)))
               >>> x = memoryview(buf)
               >>> y = x.cast('L', shape=[2,3])
               >>> len(y)
               2
               >>> y.nbytes
               48
               >>> y.tolist()
               [[0, 1, 2], [3, 4, 5]]

          New in version 3.3.

          Changed in version 3.5: The source format is no longer
          restricted when casting to a byte view.

     There are also several readonly attributes available:

      -- Attribute: obj

          The underlying object of the memoryview:

               >>> b  = bytearray(b'xyz')
               >>> m = memoryview(b)
               >>> m.obj is b
               True

          New in version 3.3.

      -- Attribute: nbytes

          ‘nbytes == product(shape) * itemsize == len(m.tobytes())’.
          This is the amount of space in bytes that the array would use
          in a contiguous representation.  It is not necessarily equal
          to len(m):

               >>> import array
               >>> a = array.array('i', [1,2,3,4,5])
               >>> m = memoryview(a)
               >>> len(m)
               5
               >>> m.nbytes
               20
               >>> y = m[::2]
               >>> len(y)
               3
               >>> y.nbytes
               12
               >>> len(y.tobytes())
               12

          Multi-dimensional arrays:

               >>> import struct
               >>> buf = struct.pack("d"*12, *[1.5*x for x in range(12)])
               >>> x = memoryview(buf)
               >>> y = x.cast('d', shape=[3,4])
               >>> y.tolist()
               [[0.0, 1.5, 3.0, 4.5], [6.0, 7.5, 9.0, 10.5], [12.0, 13.5, 15.0, 16.5]]
               >>> len(y)
               3
               >>> y.nbytes
               96

          New in version 3.3.

      -- Attribute: readonly

          A bool indicating whether the memory is read only.

      -- Attribute: format

          A string containing the format (in *note struct: f6. module
          style) for each element in the view.  A memoryview can be
          created from exporters with arbitrary format strings, but some
          methods (e.g.  *note tolist(): 1063.) are restricted to native
          single element formats.

          Changed in version 3.3: format ‘'B'’ is now handled according
          to the struct module syntax.  This means that
          ‘memoryview(b'abc')[0] == b'abc'[0] == 97’.

      -- Attribute: itemsize

          The size in bytes of each element of the memoryview:

               >>> import array, struct
               >>> m = memoryview(array.array('H', [32000, 32001, 32002]))
               >>> m.itemsize
               2
               >>> m[0]
               32000
               >>> struct.calcsize('H') == m.itemsize
               True

      -- Attribute: ndim

          An integer indicating how many dimensions of a
          multi-dimensional array the memory represents.

      -- Attribute: shape

          A tuple of integers the length of *note ndim: 106d. giving the
          shape of the memory as an N-dimensional array.

          Changed in version 3.3: An empty tuple instead of None when
          ndim = 0.

      -- Attribute: strides

          A tuple of integers the length of *note ndim: 106d. giving the
          size in bytes to access each element for each dimension of the
          array.

          Changed in version 3.3: An empty tuple instead of None when
          ndim = 0.

      -- Attribute: suboffsets

          Used internally for PIL-style arrays.  The value is
          informational only.

      -- Attribute: c_contiguous

          A bool indicating whether the memory is C-*note contiguous:
          1069.

          New in version 3.3.

      -- Attribute: f_contiguous

          A bool indicating whether the memory is Fortran *note
          contiguous: 1069.

          New in version 3.3.

      -- Attribute: contiguous

          A bool indicating whether the memory is *note contiguous:
          1069.

          New in version 3.3.

   ---------- Footnotes ----------

   (1) https://www.python.org/dev/peps/pep-3118


File: python.info,  Node: Set Types --- set frozenset,  Next: Mapping Types --- dict,  Prev: Binary Sequence Types --- bytes bytearray memoryview,  Up: Built-in Types

5.4.9 Set Types — ‘set’, ‘frozenset’
------------------------------------

A `set' object is an unordered collection of distinct *note hashable:
de9. objects.  Common uses include membership testing, removing
duplicates from a sequence, and computing mathematical operations such
as intersection, union, difference, and symmetric difference.  (For
other containers see the built-in *note dict: 3b0, *note list: 25d, and
*note tuple: 25c. classes, and the *note collections: 1e. module.)

Like other collections, sets support ‘x in set’, ‘len(set)’, and ‘for x
in set’.  Being an unordered collection, sets do not record element
position or order of insertion.  Accordingly, sets do not support
indexing, slicing, or other sequence-like behavior.

There are currently two built-in set types, *note set: 7be. and *note
frozenset: 84c.  The *note set: 7be. type is mutable — the contents can
be changed using methods like *note add(): de8. and *note remove():
1075.  Since it is mutable, it has no hash value and cannot be used as
either a dictionary key or as an element of another set.  The *note
frozenset: 84c. type is immutable and *note hashable: de9. — its
contents cannot be altered after it is created; it can therefore be used
as a dictionary key or as an element of another set.

Non-empty sets (not frozensets) can be created by placing a
comma-separated list of elements within braces, for example: ‘{'jack',
'sjoerd'}’, in addition to the *note set: 7be. constructor.

The constructors for both classes work the same:

 -- Class: set ([iterable])
 -- Class: frozenset ([iterable])

     Return a new set or frozenset object whose elements are taken from
     `iterable'.  The elements of a set must be *note hashable: de9.  To
     represent sets of sets, the inner sets must be *note frozenset:
     84c. objects.  If `iterable' is not specified, a new empty set is
     returned.

     Instances of *note set: 7be. and *note frozenset: 84c. provide the
     following operations:

      -- Describe: len(s)

          Return the number of elements in set `s' (cardinality of `s').

      -- Describe: x in s

          Test `x' for membership in `s'.

      -- Describe: x not in s

          Test `x' for non-membership in `s'.

      -- Method: isdisjoint (other)

          Return ‘True’ if the set has no elements in common with
          `other'.  Sets are disjoint if and only if their intersection
          is the empty set.

      -- Method: issubset (other)

      -- Method: set <= other

          Test whether every element in the set is in `other'.

      -- Method: set < other

          Test whether the set is a proper subset of `other', that is,
          ‘set <= other and set != other’.

      -- Method: issuperset (other)

      -- Method: set >= other

          Test whether every element in `other' is in the set.

      -- Method: set > other

          Test whether the set is a proper superset of `other', that is,
          ‘set >= other and set != other’.

      -- Method: union (other, ...)

      -- Method: set | other | ...

          Return a new set with elements from the set and all others.

      -- Method: intersection (other, ...)

      -- Method: set & other & ...

          Return a new set with elements common to the set and all
          others.

      -- Method: difference (other, ...)

      -- Method: set - other - ...

          Return a new set with elements in the set that are not in the
          others.

      -- Method: symmetric_difference (other)

      -- Method: set ^ other

          Return a new set with elements in either the set or `other'
          but not both.

      -- Method: copy ()

          Return a new set with a shallow copy of `s'.

     Note, the non-operator versions of *note union(): 1079, *note
     intersection(): 107a, *note difference(): 107b, and *note
     symmetric_difference(): 107c, *note issubset(): 1077, and *note
     issuperset(): 1078. methods will accept any iterable as an
     argument.  In contrast, their operator based counterparts require
     their arguments to be sets.  This precludes error-prone
     constructions like ‘set('abc') & 'cbs'’ in favor of the more
     readable ‘set('abc').intersection('cbs')’.

     Both *note set: 7be. and *note frozenset: 84c. support set to set
     comparisons.  Two sets are equal if and only if every element of
     each set is contained in the other (each is a subset of the other).
     A set is less than another set if and only if the first set is a
     proper subset of the second set (is a subset, but is not equal).  A
     set is greater than another set if and only if the first set is a
     proper superset of the second set (is a superset, but is not
     equal).

     Instances of *note set: 7be. are compared to instances of *note
     frozenset: 84c. based on their members.  For example, ‘set('abc')
     == frozenset('abc')’ returns ‘True’ and so does ‘set('abc') in
     set([frozenset('abc')])’.

     The subset and equality comparisons do not generalize to a total
     ordering function.  For example, any two nonempty disjoint sets are
     not equal and are not subsets of each other, so `all' of the
     following return ‘False’: ‘a<b’, ‘a==b’, or ‘a>b’.

     Since sets only define partial ordering (subset relationships), the
     output of the *note list.sort(): 84d. method is undefined for lists
     of sets.

     Set elements, like dictionary keys, must be *note hashable: de9.

     Binary operations that mix *note set: 7be. instances with *note
     frozenset: 84c. return the type of the first operand.  For example:
     ‘frozenset('ab') | set('bc')’ returns an instance of *note
     frozenset: 84c.

     The following table lists operations available for *note set: 7be.
     that do not apply to immutable instances of *note frozenset: 84c.:

      -- Method: update (other, ...)

      -- Method: set |= other | ...

          Update the set, adding elements from all others.

      -- Method: intersection_update (other, ...)

      -- Method: set &= other & ...

          Update the set, keeping only elements found in it and all
          others.

      -- Method: difference_update (other, ...)

      -- Method: set -= other | ...

          Update the set, removing elements found in others.

      -- Method: symmetric_difference_update (other)

      -- Method: set ^= other

          Update the set, keeping only elements found in either set, but
          not in both.

      -- Method: add (elem)

          Add element `elem' to the set.

      -- Method: remove (elem)

          Remove element `elem' from the set.  Raises *note KeyError:
          1a7. if `elem' is not contained in the set.

      -- Method: discard (elem)

          Remove element `elem' from the set if it is present.

      -- Method: pop ()

          Remove and return an arbitrary element from the set.  Raises
          *note KeyError: 1a7. if the set is empty.

      -- Method: clear ()

          Remove all elements from the set.

     Note, the non-operator versions of the *note update(): 107e, *note
     intersection_update(): 107f, *note difference_update(): 1080, and
     *note symmetric_difference_update(): 1081. methods will accept any
     iterable as an argument.

     Note, the `elem' argument to the *note __contains__(): 99c, *note
     remove(): 1075, and *note discard(): 1082. methods may be a set.
     To support searching for an equivalent frozenset, the `elem' set is
     temporarily mutated during the search and then restored.  During
     the search, the `elem' set should not be read or mutated since it
     does not have a meaningful value.


File: python.info,  Node: Mapping Types --- dict,  Next: Context Manager Types,  Prev: Set Types --- set frozenset,  Up: Built-in Types

5.4.10 Mapping Types — ‘dict’
-----------------------------

A *note mapping: 77c. object maps *note hashable: de9. values to
arbitrary objects.  Mappings are mutable objects.  There is currently
only one standard mapping type, the `dictionary'.  (For other containers
see the built-in *note list: 25d, *note set: 7be, and *note tuple: 25c.
classes, and the *note collections: 1e. module.)

A dictionary’s keys are `almost' arbitrary values.  Values that are not
*note hashable: de9, that is, values containing lists, dictionaries or
other mutable types (that are compared by value rather than by object
identity) may not be used as keys.  Numeric types used for keys obey the
normal rules for numeric comparison: if two numbers compare equal (such
as ‘1’ and ‘1.0’) then they can be used interchangeably to index the
same dictionary entry.  (Note however, that since computers store
floating-point numbers as approximations it is usually unwise to use
them as dictionary keys.)

Dictionaries can be created by placing a comma-separated list of ‘key:
value’ pairs within braces, for example: ‘{'jack': 4098, 'sjoerd':
4127}’ or ‘{4098: 'jack', 4127: 'sjoerd'}’, or by the *note dict: 3b0.
constructor.

 -- Class: dict (**kwarg)

 -- Class: dict (mapping, **kwarg)

 -- Class: dict (iterable, **kwarg)

     Return a new dictionary initialized from an optional positional
     argument and a possibly empty set of keyword arguments.

     If no positional argument is given, an empty dictionary is created.
     If a positional argument is given and it is a mapping object, a
     dictionary is created with the same key-value pairs as the mapping
     object.  Otherwise, the positional argument must be an *note
     iterable: 80a. object.  Each item in the iterable must itself be an
     iterable with exactly two objects.  The first object of each item
     becomes a key in the new dictionary, and the second object the
     corresponding value.  If a key occurs more than once, the last
     value for that key becomes the corresponding value in the new
     dictionary.

     If keyword arguments are given, the keyword arguments and their
     values are added to the dictionary created from the positional
     argument.  If a key being added is already present, the value from
     the keyword argument replaces the value from the positional
     argument.

     To illustrate, the following examples all return a dictionary equal
     to ‘{"one": 1, "two": 2, "three": 3}’:

          >>> a = dict(one=1, two=2, three=3)
          >>> b = {'one': 1, 'two': 2, 'three': 3}
          >>> c = dict(zip(['one', 'two', 'three'], [1, 2, 3]))
          >>> d = dict([('two', 2), ('one', 1), ('three', 3)])
          >>> e = dict({'three': 3, 'one': 1, 'two': 2})
          >>> a == b == c == d == e
          True

     Providing keyword arguments as in the first example only works for
     keys that are valid Python identifiers.  Otherwise, any valid keys
     can be used.

     These are the operations that dictionaries support (and therefore,
     custom mapping types should support too):

      -- Describe: len(d)

          Return the number of items in the dictionary `d'.

      -- Describe: d[key]

          Return the item of `d' with key `key'.  Raises a *note
          KeyError: 1a7. if `key' is not in the map.

          If a subclass of dict defines a method *note __missing__():
          77e. and `key' is not present, the ‘d[key]’ operation calls
          that method with the key `key' as argument.  The ‘d[key]’
          operation then returns or raises whatever is returned or
          raised by the ‘__missing__(key)’ call.  No other operations or
          methods invoke *note __missing__(): 77e.  If *note
          __missing__(): 77e. is not defined, *note KeyError: 1a7. is
          raised.  *note __missing__(): 77e. must be a method; it cannot
          be an instance variable:

               >>> class Counter(dict):
               ...     def __missing__(self, key):
               ...         return 0
               >>> c = Counter()
               >>> c['red']
               0
               >>> c['red'] += 1
               >>> c['red']
               1

          The example above shows part of the implementation of *note
          collections.Counter: 602.  A different ‘__missing__’ method is
          used by *note collections.defaultdict: 77d.

      -- Describe: d[key] = value

          Set ‘d[key]’ to `value'.

      -- Describe: del d[key]

          Remove ‘d[key]’ from `d'.  Raises a *note KeyError: 1a7. if
          `key' is not in the map.

      -- Describe: key in d

          Return ‘True’ if `d' has a key `key', else ‘False’.

      -- Describe: key not in d

          Equivalent to ‘not key in d’.

      -- Describe: iter(d)

          Return an iterator over the keys of the dictionary.  This is a
          shortcut for ‘iter(d.keys())’.

      -- Method: clear ()

          Remove all items from the dictionary.

      -- Method: copy ()

          Return a shallow copy of the dictionary.

      -- Class Method: fromkeys (seq[, value])

          Create a new dictionary with keys from `seq' and values set to
          `value'.

          *note fromkeys(): 1088. is a class method that returns a new
          dictionary.  `value' defaults to ‘None’.

      -- Method: get (key[, default])

          Return the value for `key' if `key' is in the dictionary, else
          `default'.  If `default' is not given, it defaults to ‘None’,
          so that this method never raises a *note KeyError: 1a7.

      -- Method: items ()

          Return a new view of the dictionary’s items (‘(key, value)’
          pairs).  See the *note documentation of view objects: 108a.

      -- Method: keys ()

          Return a new view of the dictionary’s keys.  See the *note
          documentation of view objects: 108a.

      -- Method: pop (key[, default])

          If `key' is in the dictionary, remove it and return its value,
          else return `default'.  If `default' is not given and `key' is
          not in the dictionary, a *note KeyError: 1a7. is raised.

      -- Method: popitem ()

          Remove and return an arbitrary ‘(key, value)’ pair from the
          dictionary.

          *note popitem(): 108c. is useful to destructively iterate over
          a dictionary, as often used in set algorithms.  If the
          dictionary is empty, calling *note popitem(): 108c. raises a
          *note KeyError: 1a7.

      -- Method: setdefault (key[, default])

          If `key' is in the dictionary, return its value.  If not,
          insert `key' with a value of `default' and return `default'.
          `default' defaults to ‘None’.

      -- Method: update ([other])

          Update the dictionary with the key/value pairs from `other',
          overwriting existing keys.  Return ‘None’.

          *note update(): a45. accepts either another dictionary object
          or an iterable of key/value pairs (as tuples or other
          iterables of length two).  If keyword arguments are specified,
          the dictionary is then updated with those key/value pairs:
          ‘d.update(red=1, blue=2)’.

      -- Method: values ()

          Return a new view of the dictionary’s values.  See the *note
          documentation of view objects: 108a.

     Dictionaries compare equal if and only if they have the same ‘(key,
     value)’ pairs.  Order comparisons (’<’, ’<=’, ’>=’, ’>’) raise
     *note TypeError: 562.

See also
........

*note types.MappingProxyType: 6f2. can be used to create a read-only
view of a *note dict: 3b0.

* Menu:

* Dictionary view objects:: 

