This is python.info, produced by makeinfo version 6.0 from python.texi.

     Python 3.6.0a0, May 06, 2016

     Georg Brandl

     Copyright © 2001-2016, Python Software Foundation

INFO-DIR-SECTION Documentation tools
START-INFO-DIR-ENTRY
* Python: (python.info). The Python Programming Language
END-INFO-DIR-ENTRY


   Generated by Sphinx 1.4.1.


File: python.info,  Node: Arbitrary Argument Lists,  Next: Unpacking Argument Lists,  Prev: Keyword Arguments,  Up: More on Defining Functions

2.4.7.3 Arbitrary Argument Lists
................................

Finally, the least frequently used option is to specify that a function
can be called with an arbitrary number of arguments.  These arguments
will be wrapped up in a tuple (see *note Tuples and Sequences: c16.).
Before the variable number of arguments, zero or more normal arguments
may occur.

     def write_multiple_items(file, separator, *args):
         file.write(separator.join(args))

Normally, these ‘variadic’ arguments will be last in the list of formal
parameters, because they scoop up all remaining input arguments that are
passed to the function.  Any formal parameters which occur after the
‘*args’ parameter are ’keyword-only’ arguments, meaning that they can
only be used as keywords rather than positional arguments.

     >>> def concat(*args, sep="/"):
     ...    return sep.join(args)
     ...
     >>> concat("earth", "mars", "venus")
     'earth/mars/venus'
     >>> concat("earth", "mars", "venus", sep=".")
     'earth.mars.venus'


File: python.info,  Node: Unpacking Argument Lists,  Next: Lambda Expressions,  Prev: Arbitrary Argument Lists,  Up: More on Defining Functions

2.4.7.4 Unpacking Argument Lists
................................

The reverse situation occurs when the arguments are already in a list or
tuple but need to be unpacked for a function call requiring separate
positional arguments.  For instance, the built-in *note range(): 5e0.
function expects separate `start' and `stop' arguments.  If they are not
available separately, write the function call with the ‘*’-operator to
unpack the arguments out of a list or tuple:

     >>> list(range(3, 6))            # normal call with separate arguments
     [3, 4, 5]
     >>> args = [3, 6]
     >>> list(range(*args))            # call with arguments unpacked from a list
     [3, 4, 5]

In the same fashion, dictionaries can deliver keyword arguments with the
‘**’-operator:

     >>> def parrot(voltage, state='a stiff', action='voom'):
     ...     print("-- This parrot wouldn't", action, end=' ')
     ...     print("if you put", voltage, "volts through it.", end=' ')
     ...     print("E's", state, "!")
     ...
     >>> d = {"voltage": "four million", "state": "bleedin' demised", "action": "VOOM"}
     >>> parrot(**d)
     -- This parrot wouldn't VOOM if you put four million volts through it. E's bleedin' demised !


File: python.info,  Node: Lambda Expressions,  Next: Documentation Strings,  Prev: Unpacking Argument Lists,  Up: More on Defining Functions

2.4.7.5 Lambda Expressions
..........................

Small anonymous functions can be created with the *note lambda: 894.
keyword.  This function returns the sum of its two arguments: ‘lambda a,
b: a+b’.  Lambda functions can be used wherever function objects are
required.  They are syntactically restricted to a single expression.
Semantically, they are just syntactic sugar for a normal function
definition.  Like nested function definitions, lambda functions can
reference variables from the containing scope:

     >>> def make_incrementor(n):
     ...     return lambda x: x + n
     ...
     >>> f = make_incrementor(42)
     >>> f(0)
     42
     >>> f(1)
     43

The above example uses a lambda expression to return a function.
Another use is to pass a small function as an argument:

     >>> pairs = [(1, 'one'), (2, 'two'), (3, 'three'), (4, 'four')]
     >>> pairs.sort(key=lambda pair: pair[1])
     >>> pairs
     [(4, 'four'), (1, 'one'), (3, 'three'), (2, 'two')]


File: python.info,  Node: Documentation Strings,  Next: Function Annotations,  Prev: Lambda Expressions,  Up: More on Defining Functions

2.4.7.6 Documentation Strings
.............................

Here are some conventions about the content and formatting of
documentation strings.

The first line should always be a short, concise summary of the object’s
purpose.  For brevity, it should not explicitly state the object’s name
or type, since these are available by other means (except if the name
happens to be a verb describing a function’s operation).  This line
should begin with a capital letter and end with a period.

If there are more lines in the documentation string, the second line
should be blank, visually separating the summary from the rest of the
description.  The following lines should be one or more paragraphs
describing the object’s calling conventions, its side effects, etc.

The Python parser does not strip indentation from multi-line string
literals in Python, so tools that process documentation have to strip
indentation if desired.  This is done using the following convention.
The first non-blank line `after' the first line of the string determines
the amount of indentation for the entire documentation string.  (We
can’t use the first line since it is generally adjacent to the string’s
opening quotes so its indentation is not apparent in the string
literal.)  Whitespace "equivalent" to this indentation is then stripped
from the start of all lines of the string.  Lines that are indented less
should not occur, but if they occur all their leading whitespace should
be stripped.  Equivalence of whitespace should be tested after expansion
of tabs (to 8 spaces, normally).

Here is an example of a multi-line docstring:

     >>> def my_function():
     ...     """Do nothing, but document it.
     ...
     ...     No, really, it doesn't do anything.
     ...     """
     ...     pass
     ...
     >>> print(my_function.__doc__)
     Do nothing, but document it.

         No, really, it doesn't do anything.


File: python.info,  Node: Function Annotations,  Prev: Documentation Strings,  Up: More on Defining Functions

2.4.7.7 Function Annotations
............................

*note Function annotations: c1e. are completely optional metadata
information about the types used by user-defined functions (see PEP
484(1) for more information).

Annotations are stored in the ‘__annotations__’ attribute of the
function as a dictionary and have no effect on any other part of the
function.  Parameter annotations are defined by a colon after the
parameter name, followed by an expression evaluating to the value of the
annotation.  Return annotations are defined by a literal ‘->’, followed
by an expression, between the parameter list and the colon denoting the
end of the *note def: a3a. statement.  The following example has a
positional argument, a keyword argument, and the return value annotated:

     >>> def f(ham: str, eggs: str = 'eggs') -> str:
     ...     print("Annotations:", f.__annotations__)
     ...     print("Arguments:", ham, eggs)
     ...     return ham + ' and ' + eggs
     ...
     >>> f('spam')
     Annotations: {'ham': <class 'str'>, 'return': <class 'str'>, 'eggs': <class 'str'>}
     Arguments: spam eggs
     'spam and eggs'

   ---------- Footnotes ----------

   (1) https://www.python.org/dev/peps/pep-0484


File: python.info,  Node: Intermezzo Coding Style,  Prev: More on Defining Functions,  Up: More Control Flow Tools

2.4.8 Intermezzo: Coding Style
------------------------------

Now that you are about to write longer, more complex pieces of Python,
it is a good time to talk about `coding style'.  Most languages can be
written (or more concise, `formatted') in different styles; some are
more readable than others.  Making it easy for others to read your code
is always a good idea, and adopting a nice coding style helps
tremendously for that.

For Python, PEP 8(1) has emerged as the style guide that most projects
adhere to; it promotes a very readable and eye-pleasing coding style.
Every Python developer should read it at some point; here are the most
important points extracted for you:

   * Use 4-space indentation, and no tabs.

     4 spaces are a good compromise between small indentation (allows
     greater nesting depth) and large indentation (easier to read).
     Tabs introduce confusion, and are best left out.

   * Wrap lines so that they don’t exceed 79 characters.

     This helps users with small displays and makes it possible to have
     several code files side-by-side on larger displays.

   * Use blank lines to separate functions and classes, and larger
     blocks of code inside functions.

   * When possible, put comments on a line of their own.

   * Use docstrings.

   * Use spaces around operators and after commas, but not directly
     inside bracketing constructs: ‘a = f(1, 2) + g(3, 4)’.

   * Name your classes and functions consistently; the convention is to
     use ‘CamelCase’ for classes and ‘lower_case_with_underscores’ for
     functions and methods.  Always use ‘self’ as the name for the first
     method argument (see *note A First Look at Classes: c21. for more
     on classes and methods).

   * Don’t use fancy encodings if your code is meant to be used in
     international environments.  Python’s default, UTF-8, or even plain
     ASCII work best in any case.

   * Likewise, don’t use non-ASCII characters in identifiers if there is
     only the slightest chance people speaking a different language will
     read or maintain the code.

   ---------- Footnotes ----------

   (1) https://www.python.org/dev/peps/pep-0008


File: python.info,  Node: Data Structures,  Next: Modules,  Prev: More Control Flow Tools,  Up: The Python Tutorial

2.5 Data Structures
===================

This chapter describes some things you’ve learned about already in more
detail, and adds some new things as well.

* Menu:

* More on Lists:: 
* The del statement:: 
* Tuples and Sequences:: 
* Sets:: 
* Dictionaries:: 
* Looping Techniques:: 
* More on Conditions:: 
* Comparing Sequences and Other Types:: 


File: python.info,  Node: More on Lists,  Next: The del statement,  Up: Data Structures

2.5.1 More on Lists
-------------------

The list data type has some more methods.  Here are all of the methods
of list objects:

 -- Method: list.append (x)

     Add an item to the end of the list.  Equivalent to ‘a[len(a):] =
     [x]’.

 -- Method: list.extend (L)

     Extend the list by appending all the items in the given list.
     Equivalent to ‘a[len(a):] = L’.

 -- Method: list.insert (i, x)

     Insert an item at a given position.  The first argument is the
     index of the element before which to insert, so ‘a.insert(0, x)’
     inserts at the front of the list, and ‘a.insert(len(a), x)’ is
     equivalent to ‘a.append(x)’.

 -- Method: list.remove (x)

     Remove the first item from the list whose value is `x'.  It is an
     error if there is no such item.

 -- Method: list.pop ([i])

     Remove the item at the given position in the list, and return it.
     If no index is specified, ‘a.pop()’ removes and returns the last
     item in the list.  (The square brackets around the `i' in the
     method signature denote that the parameter is optional, not that
     you should type square brackets at that position.  You will see
     this notation frequently in the Python Library Reference.)

 -- Method: list.clear ()

     Remove all items from the list.  Equivalent to ‘del a[:]’.

 -- Method: list.index (x)

     Return the index in the list of the first item whose value is `x'.
     It is an error if there is no such item.

 -- Method: list.count (x)

     Return the number of times `x' appears in the list.

 -- Method: list.sort (key=None, reverse=False)

     Sort the items of the list in place (the arguments can be used for
     sort customization, see *note sorted(): 84e. for their
     explanation).

 -- Method: list.reverse ()

     Reverse the elements of the list in place.

 -- Method: list.copy ()

     Return a shallow copy of the list.  Equivalent to ‘a[:]’.

An example that uses most of the list methods:

     >>> a = [66.25, 333, 333, 1, 1234.5]
     >>> print(a.count(333), a.count(66.25), a.count('x'))
     2 1 0
     >>> a.insert(2, -1)
     >>> a.append(333)
     >>> a
     [66.25, 333, -1, 333, 1, 1234.5, 333]
     >>> a.index(333)
     1
     >>> a.remove(333)
     >>> a
     [66.25, -1, 333, 1, 1234.5, 333]
     >>> a.reverse()
     >>> a
     [333, 1234.5, 1, 333, -1, 66.25]
     >>> a.sort()
     >>> a
     [-1, 1, 66.25, 333, 333, 1234.5]
     >>> a.pop()
     1234.5
     >>> a
     [-1, 1, 66.25, 333, 333]

You might have noticed that methods like ‘insert’, ‘remove’ or ‘sort’
that only modify the list have no return value printed – they return the
default ‘None’.  (1) This is a design principle for all mutable data
structures in Python.

* Menu:

* Using Lists as Stacks:: 
* Using Lists as Queues:: 
* List Comprehensions: List Comprehensions<2>. 
* Nested List Comprehensions:: 

   ---------- Footnotes ----------

   (1) Other languages may return the mutated object, which allows
method chaining, such as ‘d->insert("a")->remove("b")->sort();’.


File: python.info,  Node: Using Lists as Stacks,  Next: Using Lists as Queues,  Up: More on Lists

2.5.1.1 Using Lists as Stacks
.............................

The list methods make it very easy to use a list as a stack, where the
last element added is the first element retrieved ("last-in,
first-out").  To add an item to the top of the stack, use ‘append()’.
To retrieve an item from the top of the stack, use ‘pop()’ without an
explicit index.  For example:

     >>> stack = [3, 4, 5]
     >>> stack.append(6)
     >>> stack.append(7)
     >>> stack
     [3, 4, 5, 6, 7]
     >>> stack.pop()
     7
     >>> stack
     [3, 4, 5, 6]
     >>> stack.pop()
     6
     >>> stack.pop()
     5
     >>> stack
     [3, 4]


File: python.info,  Node: Using Lists as Queues,  Next: List Comprehensions<2>,  Prev: Using Lists as Stacks,  Up: More on Lists

2.5.1.2 Using Lists as Queues
.............................

It is also possible to use a list as a queue, where the first element
added is the first element retrieved ("first-in, first-out"); however,
lists are not efficient for this purpose.  While appends and pops from
the end of list are fast, doing inserts or pops from the beginning of a
list is slow (because all of the other elements have to be shifted by
one).

To implement a queue, use *note collections.deque: 24e. which was
designed to have fast appends and pops from both ends.  For example:

     >>> from collections import deque
     >>> queue = deque(["Eric", "John", "Michael"])
     >>> queue.append("Terry")           # Terry arrives
     >>> queue.append("Graham")          # Graham arrives
     >>> queue.popleft()                 # The first to arrive now leaves
     'Eric'
     >>> queue.popleft()                 # The second to arrive now leaves
     'John'
     >>> queue                           # Remaining queue in order of arrival
     deque(['Michael', 'Terry', 'Graham'])


File: python.info,  Node: List Comprehensions<2>,  Next: Nested List Comprehensions,  Prev: Using Lists as Queues,  Up: More on Lists

2.5.1.3 List Comprehensions
...........................

List comprehensions provide a concise way to create lists.  Common
applications are to make new lists where each element is the result of
some operations applied to each member of another sequence or iterable,
or to create a subsequence of those elements that satisfy a certain
condition.

For example, assume we want to create a list of squares, like:

     >>> squares = []
     >>> for x in range(10):
     ...     squares.append(x**2)
     ...
     >>> squares
     [0, 1, 4, 9, 16, 25, 36, 49, 64, 81]

Note that this creates (or overwrites) a variable named ‘x’ that still
exists after the loop completes.  We can calculate the list of squares
without any side effects using:

     squares = list(map(lambda x: x**2, range(10)))

or, equivalently:

     squares = [x**2 for x in range(10)]

which is more concise and readable.

A list comprehension consists of brackets containing an expression
followed by a *note for: 895. clause, then zero or more *note for: 895.
or *note if: a65. clauses.  The result will be a new list resulting from
evaluating the expression in the context of the *note for: 895. and
*note if: a65. clauses which follow it.  For example, this listcomp
combines the elements of two lists if they are not equal:

     >>> [(x, y) for x in [1,2,3] for y in [3,1,4] if x != y]
     [(1, 3), (1, 4), (2, 3), (2, 1), (2, 4), (3, 1), (3, 4)]

and it’s equivalent to:

     >>> combs = []
     >>> for x in [1,2,3]:
     ...     for y in [3,1,4]:
     ...         if x != y:
     ...             combs.append((x, y))
     ...
     >>> combs
     [(1, 3), (1, 4), (2, 3), (2, 1), (2, 4), (3, 1), (3, 4)]

Note how the order of the *note for: 895. and *note if: a65. statements
is the same in both these snippets.

If the expression is a tuple (e.g.  the ‘(x, y)’ in the previous
example), it must be parenthesized.

     >>> vec = [-4, -2, 0, 2, 4]
     >>> # create a new list with the values doubled
     >>> [x*2 for x in vec]
     [-8, -4, 0, 4, 8]
     >>> # filter the list to exclude negative numbers
     >>> [x for x in vec if x >= 0]
     [0, 2, 4]
     >>> # apply a function to all the elements
     >>> [abs(x) for x in vec]
     [4, 2, 0, 2, 4]
     >>> # call a method on each element
     >>> freshfruit = ['  banana', '  loganberry ', 'passion fruit  ']
     >>> [weapon.strip() for weapon in freshfruit]
     ['banana', 'loganberry', 'passion fruit']
     >>> # create a list of 2-tuples like (number, square)
     >>> [(x, x**2) for x in range(6)]
     [(0, 0), (1, 1), (2, 4), (3, 9), (4, 16), (5, 25)]
     >>> # the tuple must be parenthesized, otherwise an error is raised
     >>> [x, x**2 for x in range(6)]
       File "<stdin>", line 1, in ?
         [x, x**2 for x in range(6)]
                    ^
     SyntaxError: invalid syntax
     >>> # flatten a list using a listcomp with two 'for'
     >>> vec = [[1,2,3], [4,5,6], [7,8,9]]
     >>> [num for elem in vec for num in elem]
     [1, 2, 3, 4, 5, 6, 7, 8, 9]

List comprehensions can contain complex expressions and nested
functions:

     >>> from math import pi
     >>> [str(round(pi, i)) for i in range(1, 6)]
     ['3.1', '3.14', '3.142', '3.1416', '3.14159']


File: python.info,  Node: Nested List Comprehensions,  Prev: List Comprehensions<2>,  Up: More on Lists

2.5.1.4 Nested List Comprehensions
..................................

The initial expression in a list comprehension can be any arbitrary
expression, including another list comprehension.

Consider the following example of a 3x4 matrix implemented as a list of
3 lists of length 4:

     >>> matrix = [
     ...     [1, 2, 3, 4],
     ...     [5, 6, 7, 8],
     ...     [9, 10, 11, 12],
     ... ]

The following list comprehension will transpose rows and columns:

     >>> [[row[i] for row in matrix] for i in range(4)]
     [[1, 5, 9], [2, 6, 10], [3, 7, 11], [4, 8, 12]]

As we saw in the previous section, the nested listcomp is evaluated in
the context of the *note for: 895. that follows it, so this example is
equivalent to:

     >>> transposed = []
     >>> for i in range(4):
     ...     transposed.append([row[i] for row in matrix])
     ...
     >>> transposed
     [[1, 5, 9], [2, 6, 10], [3, 7, 11], [4, 8, 12]]

which, in turn, is the same as:

     >>> transposed = []
     >>> for i in range(4):
     ...     # the following 3 lines implement the nested listcomp
     ...     transposed_row = []
     ...     for row in matrix:
     ...         transposed_row.append(row[i])
     ...     transposed.append(transposed_row)
     ...
     >>> transposed
     [[1, 5, 9], [2, 6, 10], [3, 7, 11], [4, 8, 12]]

In the real world, you should prefer built-in functions to complex flow
statements.  The *note zip(): 897. function would do a great job for
this use case:

     >>> list(zip(*matrix))
     [(1, 5, 9), (2, 6, 10), (3, 7, 11), (4, 8, 12)]

See *note Unpacking Argument Lists: c17. for details on the asterisk in
this line.


File: python.info,  Node: The del statement,  Next: Tuples and Sequences,  Prev: More on Lists,  Up: Data Structures

2.5.2 The ‘del’ statement
-------------------------

There is a way to remove an item from a list given its index instead of
its value: the *note del: c30. statement.  This differs from the ‘pop()’
method which returns a value.  The *note del: c30. statement can also be
used to remove slices from a list or clear the entire list (which we did
earlier by assignment of an empty list to the slice).  For example:

     >>> a = [-1, 1, 66.25, 333, 333, 1234.5]
     >>> del a[0]
     >>> a
     [1, 66.25, 333, 333, 1234.5]
     >>> del a[2:4]
     >>> a
     [1, 66.25, 1234.5]
     >>> del a[:]
     >>> a
     []

*note del: c30. can also be used to delete entire variables:

     >>> del a

Referencing the name ‘a’ hereafter is an error (at least until another
value is assigned to it).  We’ll find other uses for *note del: c30.
later.


File: python.info,  Node: Tuples and Sequences,  Next: Sets,  Prev: The del statement,  Up: Data Structures

2.5.3 Tuples and Sequences
--------------------------

We saw that lists and strings have many common properties, such as
indexing and slicing operations.  They are two examples of `sequence'
data types (see *note Sequence Types — list, tuple, range: c32.).  Since
Python is an evolving language, other sequence data types may be added.
There is also another standard sequence data type: the `tuple'.

A tuple consists of a number of values separated by commas, for
instance:

     >>> t = 12345, 54321, 'hello!'
     >>> t[0]
     12345
     >>> t
     (12345, 54321, 'hello!')
     >>> # Tuples may be nested:
     ... u = t, (1, 2, 3, 4, 5)
     >>> u
     ((12345, 54321, 'hello!'), (1, 2, 3, 4, 5))
     >>> # Tuples are immutable:
     ... t[0] = 88888
     Traceback (most recent call last):
       File "<stdin>", line 1, in <module>
     TypeError: 'tuple' object does not support item assignment
     >>> # but they can contain mutable objects:
     ... v = ([1, 2, 3], [3, 2, 1])
     >>> v
     ([1, 2, 3], [3, 2, 1])

As you see, on output tuples are always enclosed in parentheses, so that
nested tuples are interpreted correctly; they may be input with or
without surrounding parentheses, although often parentheses are
necessary anyway (if the tuple is part of a larger expression).  It is
not possible to assign to the individual items of a tuple, however it is
possible to create tuples which contain mutable objects, such as lists.

Though tuples may seem similar to lists, they are often used in
different situations and for different purposes.  Tuples are *note
immutable: be9, and usually contain a heterogeneous sequence of elements
that are accessed via unpacking (see later in this section) or indexing
(or even by attribute in the case of *note namedtuples: 229.).  Lists
are *note mutable: bf0, and their elements are usually homogeneous and
are accessed by iterating over the list.

A special problem is the construction of tuples containing 0 or 1 items:
the syntax has some extra quirks to accommodate these.  Empty tuples are
constructed by an empty pair of parentheses; a tuple with one item is
constructed by following a value with a comma (it is not sufficient to
enclose a single value in parentheses).  Ugly, but effective.  For
example:

     >>> empty = ()
     >>> singleton = 'hello',    # <-- note trailing comma
     >>> len(empty)
     0
     >>> len(singleton)
     1
     >>> singleton
     ('hello',)

The statement ‘t = 12345, 54321, 'hello!'’ is an example of `tuple
packing': the values ‘12345’, ‘54321’ and ‘'hello!'’ are packed together
in a tuple.  The reverse operation is also possible:

     >>> x, y, z = t

This is called, appropriately enough, `sequence unpacking' and works for
any sequence on the right-hand side.  Sequence unpacking requires that
there are as many variables on the left side of the equals sign as there
are elements in the sequence.  Note that multiple assignment is really
just a combination of tuple packing and sequence unpacking.


File: python.info,  Node: Sets,  Next: Dictionaries,  Prev: Tuples and Sequences,  Up: Data Structures

2.5.4 Sets
----------

Python also includes a data type for `sets'.  A set is an unordered
collection with no duplicate elements.  Basic uses include membership
testing and eliminating duplicate entries.  Set objects also support
mathematical operations like union, intersection, difference, and
symmetric difference.

Curly braces or the *note set(): 7be. function can be used to create
sets.  Note: to create an empty set you have to use ‘set()’, not ‘{}’;
the latter creates an empty dictionary, a data structure that we discuss
in the next section.

Here is a brief demonstration:

     >>> basket = {'apple', 'orange', 'apple', 'pear', 'orange', 'banana'}
     >>> print(basket)                      # show that duplicates have been removed
     {'orange', 'banana', 'pear', 'apple'}
     >>> 'orange' in basket                 # fast membership testing
     True
     >>> 'crabgrass' in basket
     False

     >>> # Demonstrate set operations on unique letters from two words
     ...
     >>> a = set('abracadabra')
     >>> b = set('alacazam')
     >>> a                                  # unique letters in a
     {'a', 'r', 'b', 'c', 'd'}
     >>> a - b                              # letters in a but not in b
     {'r', 'd', 'b'}
     >>> a | b                              # letters in either a or b
     {'a', 'c', 'r', 'd', 'b', 'm', 'z', 'l'}
     >>> a & b                              # letters in both a and b
     {'a', 'c'}
     >>> a ^ b                              # letters in a or b but not both
     {'r', 'd', 'b', 'm', 'z', 'l'}

Similarly to *note list comprehensions: c2b, set comprehensions are also
supported:

     >>> a = {x for x in 'abracadabra' if x not in 'abc'}
     >>> a
     {'r', 'd'}


File: python.info,  Node: Dictionaries,  Next: Looping Techniques,  Prev: Sets,  Up: Data Structures

2.5.5 Dictionaries
------------------

Another useful data type built into Python is the `dictionary' (see
*note Mapping Types — dict: c13.).  Dictionaries are sometimes found in
other languages as "associative memories" or "associative arrays".
Unlike sequences, which are indexed by a range of numbers, dictionaries
are indexed by `keys', which can be any immutable type; strings and
numbers can always be keys.  Tuples can be used as keys if they contain
only strings, numbers, or tuples; if a tuple contains any mutable object
either directly or indirectly, it cannot be used as a key.  You can’t
use lists as keys, since lists can be modified in place using index
assignments, slice assignments, or methods like ‘append()’ and
‘extend()’.

It is best to think of a dictionary as an unordered set of `key: value'
pairs, with the requirement that the keys are unique (within one
dictionary).  A pair of braces creates an empty dictionary: ‘{}’.
Placing a comma-separated list of key:value pairs within the braces adds
initial key:value pairs to the dictionary; this is also the way
dictionaries are written on output.

The main operations on a dictionary are storing a value with some key
and extracting the value given the key.  It is also possible to delete a
key:value pair with ‘del’.  If you store using a key that is already in
use, the old value associated with that key is forgotten.  It is an
error to extract a value using a non-existent key.

Performing ‘list(d.keys())’ on a dictionary returns a list of all the
keys used in the dictionary, in arbitrary order (if you want it sorted,
just use ‘sorted(d.keys())’ instead).  (1) To check whether a single key
is in the dictionary, use the *note in: 37d. keyword.

Here is a small example using a dictionary:

     >>> tel = {'jack': 4098, 'sape': 4139}
     >>> tel['guido'] = 4127
     >>> tel
     {'sape': 4139, 'guido': 4127, 'jack': 4098}
     >>> tel['jack']
     4098
     >>> del tel['sape']
     >>> tel['irv'] = 4127
     >>> tel
     {'guido': 4127, 'irv': 4127, 'jack': 4098}
     >>> list(tel.keys())
     ['irv', 'guido', 'jack']
     >>> sorted(tel.keys())
     ['guido', 'irv', 'jack']
     >>> 'guido' in tel
     True
     >>> 'jack' not in tel
     False

The *note dict(): 3b0. constructor builds dictionaries directly from
sequences of key-value pairs:

     >>> dict([('sape', 4139), ('guido', 4127), ('jack', 4098)])
     {'sape': 4139, 'jack': 4098, 'guido': 4127}

In addition, dict comprehensions can be used to create dictionaries from
arbitrary key and value expressions:

     >>> {x: x**2 for x in (2, 4, 6)}
     {2: 4, 4: 16, 6: 36}

When the keys are simple strings, it is sometimes easier to specify
pairs using keyword arguments:

     >>> dict(sape=4139, guido=4127, jack=4098)
     {'sape': 4139, 'jack': 4098, 'guido': 4127}

   ---------- Footnotes ----------

   (1) Calling ‘d.keys()’ will return a `dictionary view' object.  It
supports operations like membership test and iteration, but its contents
are not independent of the original dictionary – it is only a `view'.


File: python.info,  Node: Looping Techniques,  Next: More on Conditions,  Prev: Dictionaries,  Up: Data Structures

2.5.6 Looping Techniques
------------------------

When looping through dictionaries, the key and corresponding value can
be retrieved at the same time using the ‘items()’ method.

     >>> knights = {'gallahad': 'the pure', 'robin': 'the brave'}
     >>> for k, v in knights.items():
     ...     print(k, v)
     ...
     gallahad the pure
     robin the brave

When looping through a sequence, the position index and corresponding
value can be retrieved at the same time using the *note enumerate():
a61. function.

     >>> for i, v in enumerate(['tic', 'tac', 'toe']):
     ...     print(i, v)
     ...
     0 tic
     1 tac
     2 toe

To loop over two or more sequences at the same time, the entries can be
paired with the *note zip(): 897. function.

     >>> questions = ['name', 'quest', 'favorite color']
     >>> answers = ['lancelot', 'the holy grail', 'blue']
     >>> for q, a in zip(questions, answers):
     ...     print('What is your {0}?  It is {1}.'.format(q, a))
     ...
     What is your name?  It is lancelot.
     What is your quest?  It is the holy grail.
     What is your favorite color?  It is blue.

To loop over a sequence in reverse, first specify the sequence in a
forward direction and then call the *note reversed(): 24d. function.

     >>> for i in reversed(range(1, 10, 2)):
     ...     print(i)
     ...
     9
     7
     5
     3
     1

To loop over a sequence in sorted order, use the *note sorted(): 84e.
function which returns a new sorted list while leaving the source
unaltered.

     >>> basket = ['apple', 'orange', 'apple', 'pear', 'orange', 'banana']
     >>> for f in sorted(set(basket)):
     ...     print(f)
     ...
     apple
     banana
     orange
     pear

It is sometimes tempting to change a list while you are looping over it;
however, it is often simpler and safer to create a new list instead.

     >>> import math
     >>> raw_data = [56.2, float('NaN'), 51.7, 55.3, 52.5, float('NaN'), 47.8]
     >>> filtered_data = []
     >>> for value in raw_data:
     ...     if not math.isnan(value):
     ...         filtered_data.append(value)
     ...
     >>> filtered_data
     [56.2, 51.7, 55.3, 52.5, 47.8]


File: python.info,  Node: More on Conditions,  Next: Comparing Sequences and Other Types,  Prev: Looping Techniques,  Up: Data Structures

2.5.7 More on Conditions
------------------------

The conditions used in ‘while’ and ‘if’ statements can contain any
operators, not just comparisons.

The comparison operators ‘in’ and ‘not in’ check whether a value occurs
(does not occur) in a sequence.  The operators ‘is’ and ‘is not’ compare
whether two objects are really the same object; this only matters for
mutable objects like lists.  All comparison operators have the same
priority, which is lower than that of all numerical operators.

Comparisons can be chained.  For example, ‘a < b == c’ tests whether ‘a’
is less than ‘b’ and moreover ‘b’ equals ‘c’.

Comparisons may be combined using the Boolean operators ‘and’ and ‘or’,
and the outcome of a comparison (or of any other Boolean expression) may
be negated with ‘not’.  These have lower priorities than comparison
operators; between them, ‘not’ has the highest priority and ‘or’ the
lowest, so that ‘A and not B or C’ is equivalent to ‘(A and (not B)) or
C’.  As always, parentheses can be used to express the desired
composition.

The Boolean operators ‘and’ and ‘or’ are so-called `short-circuit'
operators: their arguments are evaluated from left to right, and
evaluation stops as soon as the outcome is determined.  For example, if
‘A’ and ‘C’ are true but ‘B’ is false, ‘A and B and C’ does not evaluate
the expression ‘C’.  When used as a general value and not as a Boolean,
the return value of a short-circuit operator is the last evaluated
argument.

It is possible to assign the result of a comparison or other Boolean
expression to a variable.  For example,

     >>> string1, string2, string3 = '', 'Trondheim', 'Hammer Dance'
     >>> non_null = string1 or string2 or string3
     >>> non_null
     'Trondheim'

Note that in Python, unlike C, assignment cannot occur inside
expressions.  C programmers may grumble about this, but it avoids a
common class of problems encountered in C programs: typing ‘=’ in an
expression when ‘==’ was intended.


File: python.info,  Node: Comparing Sequences and Other Types,  Prev: More on Conditions,  Up: Data Structures

2.5.8 Comparing Sequences and Other Types
-----------------------------------------

Sequence objects may be compared to other objects with the same sequence
type.  The comparison uses `lexicographical' ordering: first the first
two items are compared, and if they differ this determines the outcome
of the comparison; if they are equal, the next two items are compared,
and so on, until either sequence is exhausted.  If two items to be
compared are themselves sequences of the same type, the lexicographical
comparison is carried out recursively.  If all items of two sequences
compare equal, the sequences are considered equal.  If one sequence is
an initial sub-sequence of the other, the shorter sequence is the
smaller (lesser) one.  Lexicographical ordering for strings uses the
Unicode code point number to order individual characters.  Some examples
of comparisons between sequences of the same type:

     (1, 2, 3)              < (1, 2, 4)
     [1, 2, 3]              < [1, 2, 4]
     'ABC' < 'C' < 'Pascal' < 'Python'
     (1, 2, 3, 4)           < (1, 2, 4)
     (1, 2)                 < (1, 2, -1)
     (1, 2, 3)             == (1.0, 2.0, 3.0)
     (1, 2, ('aa', 'ab'))   < (1, 2, ('abc', 'a'), 4)

Note that comparing objects of different types with ‘<’ or ‘>’ is legal
provided that the objects have appropriate comparison methods.  For
example, mixed numeric types are compared according to their numeric
value, so 0 equals 0.0, etc.  Otherwise, rather than providing an
arbitrary ordering, the interpreter will raise a *note TypeError: 562.
exception.


File: python.info,  Node: Modules,  Next: Input and Output,  Prev: Data Structures,  Up: The Python Tutorial

2.6 Modules
===========

If you quit from the Python interpreter and enter it again, the
definitions you have made (functions and variables) are lost.
Therefore, if you want to write a somewhat longer program, you are
better off using a text editor to prepare the input for the interpreter
and running it with that file as input instead.  This is known as
creating a `script'.  As your program gets longer, you may want to split
it into several files for easier maintenance.  You may also want to use
a handy function that you’ve written in several programs without copying
its definition into each program.

To support this, Python has a way to put definitions in a file and use
them in a script or in an interactive instance of the interpreter.  Such
a file is called a `module'; definitions from a module can be `imported'
into other modules or into the `main' module (the collection of
variables that you have access to in a script executed at the top level
and in calculator mode).

A module is a file containing Python definitions and statements.  The
file name is the module name with the suffix ‘.py’ appended.  Within a
module, the module’s name (as a string) is available as the value of the
global variable ‘__name__’.  For instance, use your favorite text editor
to create a file called ‘fibo.py’ in the current directory with the
following contents:

     # Fibonacci numbers module

     def fib(n):    # write Fibonacci series up to n
         a, b = 0, 1
         while b < n:
             print(b, end=' ')
             a, b = b, a+b
         print()

     def fib2(n): # return Fibonacci series up to n
         result = []
         a, b = 0, 1
         while b < n:
             result.append(b)
             a, b = b, a+b
         return result

Now enter the Python interpreter and import this module with the
following command:

     >>> import fibo

This does not enter the names of the functions defined in ‘fibo’
directly in the current symbol table; it only enters the module name
‘fibo’ there.  Using the module name you can access the functions:

     >>> fibo.fib(1000)
     1 1 2 3 5 8 13 21 34 55 89 144 233 377 610 987
     >>> fibo.fib2(100)
     [1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89]
     >>> fibo.__name__
     'fibo'

If you intend to use a function often you can assign it to a local name:

     >>> fib = fibo.fib
     >>> fib(500)
     1 1 2 3 5 8 13 21 34 55 89 144 233 377

* Menu:

* More on Modules:: 
* Standard Modules:: 
* The dir() Function: The dir Function. 
* Packages:: 


File: python.info,  Node: More on Modules,  Next: Standard Modules,  Up: Modules

2.6.1 More on Modules
---------------------

A module can contain executable statements as well as function
definitions.  These statements are intended to initialize the module.
They are executed only the `first' time the module name is encountered
in an import statement.  (1) (They are also run if the file is executed
as a script.)

Each module has its own private symbol table, which is used as the
global symbol table by all functions defined in the module.  Thus, the
author of a module can use global variables in the module without
worrying about accidental clashes with a user’s global variables.  On
the other hand, if you know what you are doing you can touch a module’s
global variables with the same notation used to refer to its functions,
‘modname.itemname’.

Modules can import other modules.  It is customary but not required to
place all *note import: 881. statements at the beginning of a module (or
script, for that matter).  The imported module names are placed in the
importing module’s global symbol table.

There is a variant of the *note import: 881. statement that imports
names from a module directly into the importing module’s symbol table.
For example:

     >>> from fibo import fib, fib2
     >>> fib(500)
     1 1 2 3 5 8 13 21 34 55 89 144 233 377

This does not introduce the module name from which the imports are taken
in the local symbol table (so in the example, ‘fibo’ is not defined).

There is even a variant to import all names that a module defines:

     >>> from fibo import *
     >>> fib(500)
     1 1 2 3 5 8 13 21 34 55 89 144 233 377

This imports all names except those beginning with an underscore (‘_’).
In most cases Python programmers do not use this facility since it
introduces an unknown set of names into the interpreter, possibly hiding
some things you have already defined.

Note that in general the practice of importing ‘*’ from a module or
package is frowned upon, since it often causes poorly readable code.
However, it is okay to use it to save typing in interactive sessions.

     Note: For efficiency reasons, each module is only imported once per
     interpreter session.  Therefore, if you change your modules, you
     must restart the interpreter – or, if it’s just one module you want
     to test interactively, use *note importlib.reload(): 457, e.g.
     ‘import importlib; importlib.reload(modulename)’.

* Menu:

* Executing modules as scripts:: 
* The Module Search Path:: 
* "Compiled" Python files:: 

   ---------- Footnotes ----------

   (1) In fact function definitions are also ’statements’ that are
’executed’; the execution of a module-level function definition enters
the function name in the module’s global symbol table.


File: python.info,  Node: Executing modules as scripts,  Next: The Module Search Path,  Up: More on Modules

2.6.1.1 Executing modules as scripts
....................................

When you run a Python module with

     python fibo.py <arguments>

the code in the module will be executed, just as if you imported it, but
with the ‘__name__’ set to ‘"__main__"’.  That means that by adding this
code at the end of your module:

     if __name__ == "__main__":
         import sys
         fib(int(sys.argv[1]))

you can make the file usable as a script as well as an importable
module, because the code that parses the command line only runs if the
module is executed as the "main" file:

     $ python fibo.py 50
     1 1 2 3 5 8 13 21 34

If the module is imported, the code is not run:

     >>> import fibo
     >>>

This is often used either to provide a convenient user interface to a
module, or for testing purposes (running the module as a script executes
a test suite).


File: python.info,  Node: The Module Search Path,  Next: "Compiled" Python files,  Prev: Executing modules as scripts,  Up: More on Modules

2.6.1.2 The Module Search Path
..............................

When a module named ‘spam’ is imported, the interpreter first searches
for a built-in module with that name.  If not found, it then searches
for a file named ‘spam.py’ in a list of directories given by the
variable *note sys.path: 16c.  *note sys.path: 16c. is initialized from
these locations:

   * The directory containing the input script (or the current directory
     when no file is specified).

   * *note PYTHONPATH: 567. (a list of directory names, with the same
     syntax as the shell variable ‘PATH’).

   * The installation-dependent default.

     Note: On file systems which support symlinks, the directory
     containing the input script is calculated after the symlink is
     followed.  In other words the directory containing the symlink is
     `not' added to the module search path.

After initialization, Python programs can modify *note sys.path: 16c.
The directory containing the script being run is placed at the beginning
of the search path, ahead of the standard library path.  This means that
scripts in that directory will be loaded instead of modules of the same
name in the library directory.  This is an error unless the replacement
is intended.  See section *note Standard Modules: c45. for more
information.


File: python.info,  Node: "Compiled" Python files,  Prev: The Module Search Path,  Up: More on Modules

2.6.1.3 "Compiled" Python files
...............................

To speed up loading modules, Python caches the compiled version of each
module in the ‘__pycache__’ directory under the name
‘module.`version'.pyc’, where the version encodes the format of the
compiled file; it generally contains the Python version number.  For
example, in CPython release 3.3 the compiled version of spam.py would be
cached as ‘__pycache__/spam.cpython-33.pyc’.  This naming convention
allows compiled modules from different releases and different versions
of Python to coexist.

Python checks the modification date of the source against the compiled
version to see if it’s out of date and needs to be recompiled.  This is
a completely automatic process.  Also, the compiled modules are
platform-independent, so the same library can be shared among systems
with different architectures.

Python does not check the cache in two circumstances.  First, it always
recompiles and does not store the result for the module that’s loaded
directly from the command line.  Second, it does not check the cache if
there is no source module.  To support a non-source (compiled only)
distribution, the compiled module must be in the source directory, and
there must not be a source module.

Some tips for experts:

   * You can use the *note -O: 221. or *note -OO: 222. switches on the
     Python command to reduce the size of a compiled module.  The ‘-O’
     switch removes assert statements, the ‘-OO’ switch removes both
     assert statements and __doc__ strings.  Since some programs may
     rely on having these available, you should only use this option if
     you know what you’re doing.  "Optimized" modules have an ‘opt-’ tag
     and are usually smaller.  Future releases may change the effects of
     optimization.

   * A program doesn’t run any faster when it is read from a ‘.pyc’ file
     than when it is read from a ‘.py’ file; the only thing that’s
     faster about ‘.pyc’ files is the speed with which they are loaded.

   * The module *note compileall: 21. can create .pyc files for all
     modules in a directory.

   * There is more detail on this process, including a flow chart of the
     decisions, in PEP 3147.


File: python.info,  Node: Standard Modules,  Next: The dir Function,  Prev: More on Modules,  Up: Modules

2.6.2 Standard Modules
----------------------

Python comes with a library of standard modules, described in a separate
document, the Python Library Reference ("Library Reference" hereafter).
Some modules are built into the interpreter; these provide access to
operations that are not part of the core of the language but are
nevertheless built in, either for efficiency or to provide access to
operating system primitives such as system calls.  The set of such
modules is a configuration option which also depends on the underlying
platform.  For example, the *note winreg: 127. module is only provided
on Windows systems.  One particular module deserves some attention:
*note sys: fb, which is built into every Python interpreter.  The
variables ‘sys.ps1’ and ‘sys.ps2’ define the strings used as primary and
secondary prompts:

     >>> import sys
     >>> sys.ps1
     '>>> '
     >>> sys.ps2
     '... '
     >>> sys.ps1 = 'C> '
     C> print('Yuck!')
     Yuck!
     C>

These two variables are only defined if the interpreter is in
interactive mode.

The variable ‘sys.path’ is a list of strings that determines the
interpreter’s search path for modules.  It is initialized to a default
path taken from the environment variable *note PYTHONPATH: 567, or from
a built-in default if *note PYTHONPATH: 567. is not set.  You can modify
it using standard list operations:

     >>> import sys
     >>> sys.path.append('/ufs/guido/lib/python')


File: python.info,  Node: The dir Function,  Next: Packages,  Prev: Standard Modules,  Up: Modules

2.6.3 The ‘dir()’ Function
--------------------------

The built-in function *note dir(): 16a. is used to find out which names
a module defines.  It returns a sorted list of strings:

     >>> import fibo, sys
     >>> dir(fibo)
     ['__name__', 'fib', 'fib2']
     >>> dir(sys)  # doctest: +NORMALIZE_WHITESPACE
     ['__displayhook__', '__doc__', '__excepthook__', '__loader__', '__name__',
      '__package__', '__stderr__', '__stdin__', '__stdout__',
      '_clear_type_cache', '_current_frames', '_debugmallocstats', '_getframe',
      '_home', '_mercurial', '_xoptions', 'abiflags', 'api_version', 'argv',
      'base_exec_prefix', 'base_prefix', 'builtin_module_names', 'byteorder',
      'call_tracing', 'callstats', 'copyright', 'displayhook',
      'dont_write_bytecode', 'exc_info', 'excepthook', 'exec_prefix',
      'executable', 'exit', 'flags', 'float_info', 'float_repr_style',
      'getcheckinterval', 'getdefaultencoding', 'getdlopenflags',
      'getfilesystemencoding', 'getobjects', 'getprofile', 'getrecursionlimit',
      'getrefcount', 'getsizeof', 'getswitchinterval', 'gettotalrefcount',
      'gettrace', 'hash_info', 'hexversion', 'implementation', 'int_info',
      'intern', 'maxsize', 'maxunicode', 'meta_path', 'modules', 'path',
      'path_hooks', 'path_importer_cache', 'platform', 'prefix', 'ps1',
      'setcheckinterval', 'setdlopenflags', 'setprofile', 'setrecursionlimit',
      'setswitchinterval', 'settrace', 'stderr', 'stdin', 'stdout',
      'thread_info', 'version', 'version_info', 'warnoptions']

Without arguments, *note dir(): 16a. lists the names you have defined
currently:

     >>> a = [1, 2, 3, 4, 5]
     >>> import fibo
     >>> fib = fibo.fib
     >>> dir()
     ['__builtins__', '__name__', 'a', 'fib', 'fibo', 'sys']

Note that it lists all types of names: variables, modules, functions,
etc.

*note dir(): 16a. does not list the names of built-in functions and
variables.  If you want a list of those, they are defined in the
standard module *note builtins: 13.:

     >>> import builtins
     >>> dir(builtins)  # doctest: +NORMALIZE_WHITESPACE
     ['ArithmeticError', 'AssertionError', 'AttributeError', 'BaseException',
      'BlockingIOError', 'BrokenPipeError', 'BufferError', 'BytesWarning',
      'ChildProcessError', 'ConnectionAbortedError', 'ConnectionError',
      'ConnectionRefusedError', 'ConnectionResetError', 'DeprecationWarning',
      'EOFError', 'Ellipsis', 'EnvironmentError', 'Exception', 'False',
      'FileExistsError', 'FileNotFoundError', 'FloatingPointError',
      'FutureWarning', 'GeneratorExit', 'IOError', 'ImportError',
      'ImportWarning', 'IndentationError', 'IndexError', 'InterruptedError',
      'IsADirectoryError', 'KeyError', 'KeyboardInterrupt', 'LookupError',
      'MemoryError', 'NameError', 'None', 'NotADirectoryError', 'NotImplemented',
      'NotImplementedError', 'OSError', 'OverflowError',
      'PendingDeprecationWarning', 'PermissionError', 'ProcessLookupError',
      'ReferenceError', 'ResourceWarning', 'RuntimeError', 'RuntimeWarning',
      'StopIteration', 'SyntaxError', 'SyntaxWarning', 'SystemError',
      'SystemExit', 'TabError', 'TimeoutError', 'True', 'TypeError',
      'UnboundLocalError', 'UnicodeDecodeError', 'UnicodeEncodeError',
      'UnicodeError', 'UnicodeTranslateError', 'UnicodeWarning', 'UserWarning',
      'ValueError', 'Warning', 'ZeroDivisionError', '_', '__build_class__',
      '__debug__', '__doc__', '__import__', '__name__', '__package__', 'abs',
      'all', 'any', 'ascii', 'bin', 'bool', 'bytearray', 'bytes', 'callable',
      'chr', 'classmethod', 'compile', 'complex', 'copyright', 'credits',
      'delattr', 'dict', 'dir', 'divmod', 'enumerate', 'eval', 'exec', 'exit',
      'filter', 'float', 'format', 'frozenset', 'getattr', 'globals', 'hasattr',
      'hash', 'help', 'hex', 'id', 'input', 'int', 'isinstance', 'issubclass',
      'iter', 'len', 'license', 'list', 'locals', 'map', 'max', 'memoryview',
      'min', 'next', 'object', 'oct', 'open', 'ord', 'pow', 'print', 'property',
      'quit', 'range', 'repr', 'reversed', 'round', 'set', 'setattr', 'slice',
      'sorted', 'staticmethod', 'str', 'sum', 'super', 'tuple', 'type', 'vars',
      'zip']


File: python.info,  Node: Packages,  Prev: The dir Function,  Up: Modules

2.6.4 Packages
--------------

Packages are a way of structuring Python’s module namespace by using
"dotted module names".  For example, the module name ‘A.B’ designates a
submodule named ‘B’ in a package named ‘A’.  Just like the use of
modules saves the authors of different modules from having to worry
about each other’s global variable names, the use of dotted module names
saves the authors of multi-module packages like NumPy or the Python
Imaging Library from having to worry about each other’s module names.

Suppose you want to design a collection of modules (a "package") for the
uniform handling of sound files and sound data.  There are many
different sound file formats (usually recognized by their extension, for
example: ‘.wav’, ‘.aiff’, ‘.au’), so you may need to create and maintain
a growing collection of modules for the conversion between the various
file formats.  There are also many different operations you might want
to perform on sound data (such as mixing, adding echo, applying an
equalizer function, creating an artificial stereo effect), so in
addition you will be writing a never-ending stream of modules to perform
these operations.  Here’s a possible structure for your package
(expressed in terms of a hierarchical filesystem):

     sound/                          Top-level package
           __init__.py               Initialize the sound package
           formats/                  Subpackage for file format conversions
                   __init__.py
                   wavread.py
                   wavwrite.py
                   aiffread.py
                   aiffwrite.py
                   auread.py
                   auwrite.py
                   ...
           effects/                  Subpackage for sound effects
                   __init__.py
                   echo.py
                   surround.py
                   reverse.py
                   ...
           filters/                  Subpackage for filters
                   __init__.py
                   equalizer.py
                   vocoder.py
                   karaoke.py
                   ...

When importing the package, Python searches through the directories on
‘sys.path’ looking for the package subdirectory.

The ‘__init__.py’ files are required to make Python treat the
directories as containing packages; this is done to prevent directories
with a common name, such as ‘string’, from unintentionally hiding valid
modules that occur later on the module search path.  In the simplest
case, ‘__init__.py’ can just be an empty file, but it can also execute
initialization code for the package or set the ‘__all__’ variable,
described later.

Users of the package can import individual modules from the package, for
example:

     import sound.effects.echo

This loads the submodule ‘sound.effects.echo’.  It must be referenced
with its full name.

     sound.effects.echo.echofilter(input, output, delay=0.7, atten=4)

An alternative way of importing the submodule is:

     from sound.effects import echo

This also loads the submodule ‘echo’, and makes it available without its
package prefix, so it can be used as follows:

     echo.echofilter(input, output, delay=0.7, atten=4)

Yet another variation is to import the desired function or variable
directly:

     from sound.effects.echo import echofilter

Again, this loads the submodule ‘echo’, but this makes its function
‘echofilter()’ directly available:

     echofilter(input, output, delay=0.7, atten=4)

Note that when using ‘from package import item’, the item can be either
a submodule (or subpackage) of the package, or some other name defined
in the package, like a function, class or variable.  The ‘import’
statement first tests whether the item is defined in the package; if
not, it assumes it is a module and attempts to load it.  If it fails to
find it, an *note ImportError: 19f. exception is raised.

Contrarily, when using syntax like ‘import item.subitem.subsubitem’,
each item except for the last must be a package; the last item can be a
module or a package but can’t be a class or function or variable defined
in the previous item.

* Menu:

* Importing * From a Package:: 
* Intra-package References:: 
* Packages in Multiple Directories:: 


File: python.info,  Node: Importing * From a Package,  Next: Intra-package References,  Up: Packages

2.6.4.1 Importing * From a Package
..................................

Now what happens when the user writes ‘from sound.effects import *’?
Ideally, one would hope that this somehow goes out to the filesystem,
finds which submodules are present in the package, and imports them all.
This could take a long time and importing sub-modules might have
unwanted side-effects that should only happen when the sub-module is
explicitly imported.

The only solution is for the package author to provide an explicit index
of the package.  The *note import: 881. statement uses the following
convention: if a package’s ‘__init__.py’ code defines a list named
‘__all__’, it is taken to be the list of module names that should be
imported when ‘from package import *’ is encountered.  It is up to the
package author to keep this list up-to-date when a new version of the
package is released.  Package authors may also decide not to support it,
if they don’t see a use for importing * from their package.  For
example, the file ‘sound/effects/__init__.py’ could contain the
following code:

     __all__ = ["echo", "surround", "reverse"]

This would mean that ‘from sound.effects import *’ would import the
three named submodules of the ‘sound’ package.

If ‘__all__’ is not defined, the statement ‘from sound.effects import *’
does `not' import all submodules from the package ‘sound.effects’ into
the current namespace; it only ensures that the package ‘sound.effects’
has been imported (possibly running any initialization code in
‘__init__.py’) and then imports whatever names are defined in the
package.  This includes any names defined (and submodules explicitly
loaded) by ‘__init__.py’.  It also includes any submodules of the
package that were explicitly loaded by previous *note import: 881.
statements.  Consider this code:

     import sound.effects.echo
     import sound.effects.surround
     from sound.effects import *

In this example, the ‘echo’ and ‘surround’ modules are imported in the
current namespace because they are defined in the ‘sound.effects’
package when the ‘from...import’ statement is executed.  (This also
works when ‘__all__’ is defined.)

Although certain modules are designed to export only names that follow
certain patterns when you use ‘import *’, it is still considered bad
practise in production code.

Remember, there is nothing wrong with using ‘from Package import
specific_submodule’!  In fact, this is the recommended notation unless
the importing module needs to use submodules with the same name from
different packages.


File: python.info,  Node: Intra-package References,  Next: Packages in Multiple Directories,  Prev: Importing * From a Package,  Up: Packages

2.6.4.2 Intra-package References
................................

When packages are structured into subpackages (as with the ‘sound’
package in the example), you can use absolute imports to refer to
submodules of siblings packages.  For example, if the module
‘sound.filters.vocoder’ needs to use the ‘echo’ module in the
‘sound.effects’ package, it can use ‘from sound.effects import echo’.

You can also write relative imports, with the ‘from module import name’
form of import statement.  These imports use leading dots to indicate
the current and parent packages involved in the relative import.  From
the ‘surround’ module for example, you might use:

     from . import echo
     from .. import formats
     from ..filters import equalizer

Note that relative imports are based on the name of the current module.
Since the name of the main module is always ‘"__main__"’, modules
intended for use as the main module of a Python application must always
use absolute imports.


File: python.info,  Node: Packages in Multiple Directories,  Prev: Intra-package References,  Up: Packages

2.6.4.3 Packages in Multiple Directories
........................................

Packages support one more special attribute, *note __path__: c50.  This
is initialized to be a list containing the name of the directory holding
the package’s ‘__init__.py’ before the code in that file is executed.
This variable can be modified; doing so affects future searches for
modules and subpackages contained in the package.

While this feature is not often needed, it can be used to extend the set
of modules found in a package.


File: python.info,  Node: Input and Output,  Next: Errors and Exceptions,  Prev: Modules,  Up: The Python Tutorial

2.7 Input and Output
====================

There are several ways to present the output of a program; data can be
printed in a human-readable form, or written to a file for future use.
This chapter will discuss some of the possibilities.

* Menu:

* Fancier Output Formatting:: 
* Reading and Writing Files:: 


File: python.info,  Node: Fancier Output Formatting,  Next: Reading and Writing Files,  Up: Input and Output

2.7.1 Fancier Output Formatting
-------------------------------

So far we’ve encountered two ways of writing values: `expression
statements' and the *note print(): 481. function.  (A third way is using
the ‘write()’ method of file objects; the standard output file can be
referenced as ‘sys.stdout’.  See the Library Reference for more
information on this.)

Often you’ll want more control over the formatting of your output than
simply printing space-separated values.  There are two ways to format
your output; the first way is to do all the string handling yourself;
using string slicing and concatenation operations you can create any
layout you can imagine.  The string type has some methods that perform
useful operations for padding strings to a given column width; these
will be discussed shortly.  The second way is to use *note formatted
string literals: 14f, or the *note str.format(): 14d. method.

The *note string: f4. module contains a *note Template: 7c4. class which
offers yet another way to substitute values into strings.

One question remains, of course: how do you convert values to strings?
Luckily, Python has ways to convert any value to a string: pass it to
the *note repr(): 3bb. or *note str(): 25a. functions.

The *note str(): 25a. function is meant to return representations of
values which are fairly human-readable, while *note repr(): 3bb. is
meant to generate representations which can be read by the interpreter
(or will force a *note SyntaxError: 3a6. if there is no equivalent
syntax).  For objects which don’t have a particular representation for
human consumption, *note str(): 25a. will return the same value as *note
repr(): 3bb.  Many values, such as numbers or structures like lists and
dictionaries, have the same representation using either function.
Strings, in particular, have two distinct representations.

Some examples:

     >>> s = 'Hello, world.'
     >>> str(s)
     'Hello, world.'
     >>> repr(s)
     "'Hello, world.'"
     >>> str(1/7)
     '0.14285714285714285'
     >>> x = 10 * 3.25
     >>> y = 200 * 200
     >>> s = 'The value of x is ' + repr(x) + ', and y is ' + repr(y) + '...'
     >>> print(s)
     The value of x is 32.5, and y is 40000...
     >>> # The repr() of a string adds string quotes and backslashes:
     ... hello = 'hello, world\n'
     >>> hellos = repr(hello)
     >>> print(hellos)
     'hello, world\n'
     >>> # The argument to repr() may be any Python object:
     ... repr((x, y, ('spam', 'eggs')))
     "(32.5, 40000, ('spam', 'eggs'))"

Here are two ways to write a table of squares and cubes:

     >>> for x in range(1, 11):
     ...     print(repr(x).rjust(2), repr(x*x).rjust(3), end=' ')
     ...     # Note use of 'end' on previous line
     ...     print(repr(x*x*x).rjust(4))
     ...
      1   1    1
      2   4    8
      3   9   27
      4  16   64
      5  25  125
      6  36  216
      7  49  343
      8  64  512
      9  81  729
     10 100 1000

     >>> for x in range(1, 11):
     ...     print('{0:2d} {1:3d} {2:4d}'.format(x, x*x, x*x*x))
     ...
      1   1    1
      2   4    8
      3   9   27
      4  16   64
      5  25  125
      6  36  216
      7  49  343
      8  64  512
      9  81  729
     10 100 1000

(Note that in the first example, one space between each column was added
by the way *note print(): 481. works: it always adds spaces between its
arguments.)

This example demonstrates the *note str.rjust(): c56. method of string
objects, which right-justifies a string in a field of a given width by
padding it with spaces on the left.  There are similar methods *note
str.ljust(): c57. and *note str.center(): c58.  These methods do not
write anything, they just return a new string.  If the input string is
too long, they don’t truncate it, but return it unchanged; this will
mess up your column lay-out but that’s usually better than the
alternative, which would be lying about a value.  (If you really want
truncation you can always add a slice operation, as in
‘x.ljust(n)[:n]’.)

There is another method, *note str.zfill(): c59, which pads a numeric
string on the left with zeros.  It understands about plus and minus
signs:

     >>> '12'.zfill(5)
     '00012'
     >>> '-3.14'.zfill(7)
     '-003.14'
     >>> '3.14159265359'.zfill(5)
     '3.14159265359'

Basic usage of the *note str.format(): 14d. method looks like this:

     >>> print('We are the {} who say "{}!"'.format('knights', 'Ni'))
     We are the knights who say "Ni!"

The brackets and characters within them (called format fields) are
replaced with the objects passed into the *note str.format(): 14d.
method.  A number in the brackets can be used to refer to the position
of the object passed into the *note str.format(): 14d. method.

     >>> print('{0} and {1}'.format('spam', 'eggs'))
     spam and eggs
     >>> print('{1} and {0}'.format('spam', 'eggs'))
     eggs and spam

If keyword arguments are used in the *note str.format(): 14d. method,
their values are referred to by using the name of the argument.

     >>> print('This {food} is {adjective}.'.format(
     ...       food='spam', adjective='absolutely horrible'))
     This spam is absolutely horrible.

Positional and keyword arguments can be arbitrarily combined:

     >>> print('The story of {0}, {1}, and {other}.'.format('Bill', 'Manfred',
                                                            other='Georg'))
     The story of Bill, Manfred, and Georg.

‘'!a'’ (apply *note ascii(): 9c3.), ‘'!s'’ (apply *note str(): 25a.) and
‘'!r'’ (apply *note repr(): 3bb.) can be used to convert the value
before it is formatted:

     >>> contents = 'eels'
     >>> print('My hovercraft is full of {}.'.format(contents))
     My hovercraft is full of eels.
     >>> print('My hovercraft is full of {!r}.'.format(contents))
     My hovercraft is full of 'eels'.

An optional ‘':'’ and format specifier can follow the field name.  This
allows greater control over how the value is formatted.  The following
example rounds Pi to three places after the decimal.

     >>> import math
     >>> print('The value of PI is approximately {0:.3f}.'.format(math.pi))
     The value of PI is approximately 3.142.

Passing an integer after the ‘':'’ will cause that field to be a minimum
number of characters wide.  This is useful for making tables pretty.

     >>> table = {'Sjoerd': 4127, 'Jack': 4098, 'Dcab': 7678}
     >>> for name, phone in table.items():
     ...     print('{0:10} ==> {1:10d}'.format(name, phone))
     ...
     Jack       ==>       4098
     Dcab       ==>       7678
     Sjoerd     ==>       4127

If you have a really long format string that you don’t want to split up,
it would be nice if you could reference the variables to be formatted by
name instead of by position.  This can be done by simply passing the
dict and using square brackets ‘'[]'’ to access the keys

     >>> table = {'Sjoerd': 4127, 'Jack': 4098, 'Dcab': 8637678}
     >>> print('Jack: {0[Jack]:d}; Sjoerd: {0[Sjoerd]:d}; '
     ...       'Dcab: {0[Dcab]:d}'.format(table))
     Jack: 4098; Sjoerd: 4127; Dcab: 8637678

This could also be done by passing the table as keyword arguments with
the ’**’ notation.

     >>> table = {'Sjoerd': 4127, 'Jack': 4098, 'Dcab': 8637678}
     >>> print('Jack: {Jack:d}; Sjoerd: {Sjoerd:d}; Dcab: {Dcab:d}'.format(**table))
     Jack: 4098; Sjoerd: 4127; Dcab: 8637678

This is particularly useful in combination with the built-in function
*note vars(): c5a, which returns a dictionary containing all local
variables.

For a complete overview of string formatting with *note str.format():
14d, see *note Format String Syntax: 98a.

* Menu:

* Old string formatting:: 


File: python.info,  Node: Old string formatting,  Up: Fancier Output Formatting

2.7.1.1 Old string formatting
.............................

The ‘%’ operator can also be used for string formatting.  It interprets
the left argument much like a ‘sprintf()’-style format string to be
applied to the right argument, and returns the string resulting from
this formatting operation.  For example:

     >>> import math
     >>> print('The value of PI is approximately %5.3f.' % math.pi)
     The value of PI is approximately 3.142.

More information can be found in the *note printf-style String
Formatting: bec. section.


File: python.info,  Node: Reading and Writing Files,  Prev: Fancier Output Formatting,  Up: Input and Output

2.7.2 Reading and Writing Files
-------------------------------

*note open(): 1e8. returns a *note file object: 78b, and is most
commonly used with two arguments: ‘open(filename, mode)’.

     >>> f = open('workfile', 'w')

The first argument is a string containing the filename.  The second
argument is another string containing a few characters describing the
way in which the file will be used.  `mode' can be ‘'r'’ when the file
will only be read, ‘'w'’ for only writing (an existing file with the
same name will be erased), and ‘'a'’ opens the file for appending; any
data written to the file is automatically added to the end.  ‘'r+'’
opens the file for both reading and writing.  The `mode' argument is
optional; ‘'r'’ will be assumed if it’s omitted.

Normally, files are opened in `text mode', that means, you read and
write strings from and to the file, which are encoded in a specific
encoding.  If encoding is not specified, the default is platform
dependent (see *note open(): 1e8.).  ‘'b'’ appended to the mode opens
the file in `binary mode': now the data is read and written in the form
of bytes objects.  This mode should be used for all files that don’t
contain text.

In text mode, the default when reading is to convert platform-specific
line endings (‘\n’ on Unix, ‘\r\n’ on Windows) to just ‘\n’.  When
writing in text mode, the default is to convert occurrences of ‘\n’ back
to platform-specific line endings.  This behind-the-scenes modification
to file data is fine for text files, but will corrupt binary data like
that in ‘JPEG’ or ‘EXE’ files.  Be very careful to use binary mode when
reading and writing such files.

* Menu:

* Methods of File Objects:: 
* Saving structured data with json:: 


File: python.info,  Node: Methods of File Objects,  Next: Saving structured data with json,  Up: Reading and Writing Files

2.7.2.1 Methods of File Objects
...............................

The rest of the examples in this section will assume that a file object
called ‘f’ has already been created.

To read a file’s contents, call ‘f.read(size)’, which reads some
quantity of data and returns it as a string (in text mode) or bytes
object (in binary mode).  `size' is an optional numeric argument.  When
`size' is omitted or negative, the entire contents of the file will be
read and returned; it’s your problem if the file is twice as large as
your machine’s memory.  Otherwise, at most `size' bytes are read and
returned.  If the end of the file has been reached, ‘f.read()’ will
return an empty string (‘''’).

     >>> f.read()
     'This is the entire file.\n'
     >>> f.read()
     ''

‘f.readline()’ reads a single line from the file; a newline character
(‘\n’) is left at the end of the string, and is only omitted on the last
line of the file if the file doesn’t end in a newline.  This makes the
return value unambiguous; if ‘f.readline()’ returns an empty string, the
end of the file has been reached, while a blank line is represented by
‘'\n'’, a string containing only a single newline.

     >>> f.readline()
     'This is the first line of the file.\n'
     >>> f.readline()
     'Second line of the file\n'
     >>> f.readline()
     ''

For reading lines from a file, you can loop over the file object.  This
is memory efficient, fast, and leads to simple code:

     >>> for line in f:
     ...     print(line, end='')
     ...
     This is the first line of the file.
     Second line of the file

If you want to read all the lines of a file in a list you can also use
‘list(f)’ or ‘f.readlines()’.

‘f.write(string)’ writes the contents of `string' to the file, returning
the number of characters written.

     >>> f.write('This is a test\n')
     15

Other types of objects need to be converted – either to a string (in
text mode) or a bytes object (in binary mode) – before writing them:

     >>> value = ('the answer', 42)
     >>> s = str(value)  # convert the tuple to string
     >>> f.write(s)
     18

‘f.tell()’ returns an integer giving the file object’s current position
in the file represented as number of bytes from the beginning of the
file when in binary mode and an opaque number when in text mode.

To change the file object’s position, use ‘f.seek(offset, from_what)’.
The position is computed from adding `offset' to a reference point; the
reference point is selected by the `from_what' argument.  A `from_what'
value of 0 measures from the beginning of the file, 1 uses the current
file position, and 2 uses the end of the file as the reference point.
`from_what' can be omitted and defaults to 0, using the beginning of the
file as the reference point.

     >>> f = open('workfile', 'rb+')
     >>> f.write(b'0123456789abcdef')
     16
     >>> f.seek(5)     # Go to the 6th byte in the file
     5
     >>> f.read(1)
     b'5'
     >>> f.seek(-3, 2) # Go to the 3rd byte before the end
     13
     >>> f.read(1)
     b'd'

In text files (those opened without a ‘b’ in the mode string), only
seeks relative to the beginning of the file are allowed (the exception
being seeking to the very file end with ‘seek(0, 2)’) and the only valid
`offset' values are those returned from the ‘f.tell()’, or zero.  Any
other `offset' value produces undefined behaviour.

When you’re done with a file, call ‘f.close()’ to close it and free up
any system resources taken up by the open file.  After calling
‘f.close()’, attempts to use the file object will automatically fail.

     >>> f.close()
     >>> f.read()
     Traceback (most recent call last):
       File "<stdin>", line 1, in ?
     ValueError: I/O operation on closed file

It is good practice to use the *note with: 29d. keyword when dealing
with file objects.  This has the advantage that the file is properly
closed after its suite finishes, even if an exception is raised on the
way.  It is also much shorter than writing equivalent *note try:
9e9.-*note finally: 526. blocks:

     >>> with open('workfile', 'r') as f:
     ...     read_data = f.read()
     >>> f.closed
     True

File objects have some additional methods, such as ‘isatty()’ and
‘truncate()’ which are less frequently used; consult the Library
Reference for a complete guide to file objects.


File: python.info,  Node: Saving structured data with json,  Prev: Methods of File Objects,  Up: Reading and Writing Files

2.7.2.2 Saving structured data with ‘json’
..........................................

Strings can easily be written to and read from a file.  Numbers take a
bit more effort, since the ‘read()’ method only returns strings, which
will have to be passed to a function like *note int(): 227, which takes
a string like ‘'123'’ and returns its numeric value 123.  When you want
to save more complex data types like nested lists and dictionaries,
parsing and serializing by hand becomes complicated.

Rather than having users constantly writing and debugging code to save
complicated data types to files, Python allows you to use the popular
data interchange format called JSON (JavaScript Object Notation)(1).
The standard module called *note json: a2. can take Python data
hierarchies, and convert them to string representations; this process is
called `serializing'.  Reconstructing the data from the string
representation is called `deserializing'.  Between serializing and
deserializing, the string representing the object may have been stored
in a file or data, or sent over a network connection to some distant
machine.

     Note: The JSON format is commonly used by modern applications to
     allow for data exchange.  Many programmers are already familiar
     with it, which makes it a good choice for interoperability.

If you have an object ‘x’, you can view its JSON string representation
with a simple line of code:

     >>> json.dumps([1, 'simple', 'list'])
     '[1, "simple", "list"]'

Another variant of the *note dumps(): 373. function, called *note
dump(): 582, simply serializes the object to a *note text file: c62.  So
if ‘f’ is a *note text file: c62. object opened for writing, we can do
this:

     json.dump(x, f)

To decode the object again, if ‘f’ is a *note text file: c62. object
which has been opened for reading:

     x = json.load(f)

This simple serialization technique can handle lists and dictionaries,
but serializing arbitrary class instances in JSON requires a bit of
extra effort.  The reference for the *note json: a2. module contains an
explanation of this.

See also
........

*note pickle: c8. - the pickle module

Contrary to *note JSON: c61, `pickle' is a protocol which allows the
serialization of arbitrarily complex Python objects.  As such, it is
specific to Python and cannot be used to communicate with applications
written in other languages.  It is also insecure by default:
deserializing pickle data coming from an untrusted source can execute
arbitrary code, if the data was crafted by a skilled attacker.

   ---------- Footnotes ----------

   (1) http://json.org


File: python.info,  Node: Errors and Exceptions,  Next: Classes,  Prev: Input and Output,  Up: The Python Tutorial

2.8 Errors and Exceptions
=========================

Until now error messages haven’t been more than mentioned, but if you
have tried out the examples you have probably seen some.  There are (at
least) two distinguishable kinds of errors: `syntax errors' and
`exceptions'.

* Menu:

* Syntax Errors:: 
* Exceptions:: 
* Handling Exceptions:: 
* Raising Exceptions:: 
* User-defined Exceptions:: 
* Defining Clean-up Actions:: 
* Predefined Clean-up Actions:: 


File: python.info,  Node: Syntax Errors,  Next: Exceptions,  Up: Errors and Exceptions

2.8.1 Syntax Errors
-------------------

Syntax errors, also known as parsing errors, are perhaps the most common
kind of complaint you get while you are still learning Python:

     >>> while True print('Hello world')
       File "<stdin>", line 1, in ?
         while True print('Hello world')
                        ^
     SyntaxError: invalid syntax

The parser repeats the offending line and displays a little ’arrow’
pointing at the earliest point in the line where the error was detected.
The error is caused by (or at least detected at) the token `preceding'
the arrow: in the example, the error is detected at the function *note
print(): 481, since a colon (‘':'’) is missing before it.  File name and
line number are printed so you know where to look in case the input came
from a script.


File: python.info,  Node: Exceptions,  Next: Handling Exceptions,  Prev: Syntax Errors,  Up: Errors and Exceptions

2.8.2 Exceptions
----------------

Even if a statement or expression is syntactically correct, it may cause
an error when an attempt is made to execute it.  Errors detected during
execution are called `exceptions' and are not unconditionally fatal: you
will soon learn how to handle them in Python programs.  Most exceptions
are not handled by programs, however, and result in error messages as
shown here:

     >>> 10 * (1/0)
     Traceback (most recent call last):
       File "<stdin>", line 1, in ?
     ZeroDivisionError: division by zero
     >>> 4 + spam*3
     Traceback (most recent call last):
       File "<stdin>", line 1, in ?
     NameError: name 'spam' is not defined
     >>> '2' + 2
     Traceback (most recent call last):
       File "<stdin>", line 1, in ?
     TypeError: Can't convert 'int' object to str implicitly

The last line of the error message indicates what happened.  Exceptions
come in different types, and the type is printed as part of the message:
the types in the example are *note ZeroDivisionError: c6a, *note
NameError: 9f2. and *note TypeError: 562.  The string printed as the
exception type is the name of the built-in exception that occurred.
This is true for all built-in exceptions, but need not be true for
user-defined exceptions (although it is a useful convention).  Standard
exception names are built-in identifiers (not reserved keywords).

The rest of the line provides detail based on the type of exception and
what caused it.

The preceding part of the error message shows the context where the
exception happened, in the form of a stack traceback.  In general it
contains a stack traceback listing source lines; however, it will not
display lines read from standard input.

*note Built-in Exceptions: c6b. lists the built-in exceptions and their
meanings.


File: python.info,  Node: Handling Exceptions,  Next: Raising Exceptions,  Prev: Exceptions,  Up: Errors and Exceptions

2.8.3 Handling Exceptions
-------------------------

It is possible to write programs that handle selected exceptions.  Look
at the following example, which asks the user for input until a valid
integer has been entered, but allows the user to interrupt the program
(using ‘Control-C’ or whatever the operating system supports); note that
a user-generated interruption is signalled by raising the *note
KeyboardInterrupt: 1a3. exception.

     >>> while True:
     ...     try:
     ...         x = int(input("Please enter a number: "))
     ...         break
     ...     except ValueError:
     ...         print("Oops!  That was no valid number.  Try again...")
     ...

The *note try: 9e9. statement works as follows.

   * First, the `try clause' (the statement(s) between the *note try:
     9e9. and *note except: 785. keywords) is executed.

   * If no exception occurs, the `except clause' is skipped and
     execution of the *note try: 9e9. statement is finished.

   * If an exception occurs during execution of the try clause, the rest
     of the clause is skipped.  Then if its type matches the exception
     named after the *note except: 785. keyword, the except clause is
     executed, and then execution continues after the *note try: 9e9.
     statement.

   * If an exception occurs which does not match the exception named in
     the except clause, it is passed on to outer *note try: 9e9.
     statements; if no handler is found, it is an `unhandled exception'
     and execution stops with a message as shown above.

A *note try: 9e9. statement may have more than one except clause, to
specify handlers for different exceptions.  At most one handler will be
executed.  Handlers only handle exceptions that occur in the
corresponding try clause, not in other handlers of the same *note try:
9e9. statement.  An except clause may name multiple exceptions as a
parenthesized tuple, for example:

     ... except (RuntimeError, TypeError, NameError):
     ...     pass

The last except clause may omit the exception name(s), to serve as a
wildcard.  Use this with extreme caution, since it is easy to mask a
real programming error in this way!  It can also be used to print an
error message and then re-raise the exception (allowing a caller to
handle the exception as well):

     import sys

     try:
         f = open('myfile.txt')
         s = f.readline()
         i = int(s.strip())
     except OSError as err:
         print("OS error: {0}".format(err))
     except ValueError:
         print("Could not convert data to an integer.")
     except:
         print("Unexpected error:", sys.exc_info()[0])
         raise

The *note try: 9e9. ...  *note except: 785. statement has an optional
`else clause', which, when present, must follow all except clauses.  It
is useful for code that must be executed if the try clause does not
raise an exception.  For example:

     for arg in sys.argv[1:]:
         try:
             f = open(arg, 'r')
         except IOError:
             print('cannot open', arg)
         else:
             print(arg, 'has', len(f.readlines()), 'lines')
             f.close()

The use of the *note else: bfa. clause is better than adding additional
code to the *note try: 9e9. clause because it avoids accidentally
catching an exception that wasn’t raised by the code being protected by
the *note try: 9e9. ...  *note except: 785. statement.

When an exception occurs, it may have an associated value, also known as
the exception’s `argument'.  The presence and type of the argument
depend on the exception type.

The except clause may specify a variable after the exception name.  The
variable is bound to an exception instance with the arguments stored in
‘instance.args’.  For convenience, the exception instance defines *note
__str__(): ab9. so the arguments can be printed directly without having
to reference ‘.args’.  One may also instantiate an exception first
before raising it and add any attributes to it as desired.

     >>> try:
     ...    raise Exception('spam', 'eggs')
     ... except Exception as inst:
     ...    print(type(inst))    # the exception instance
     ...    print(inst.args)     # arguments stored in .args
     ...    print(inst)          # __str__ allows args to be printed directly,
     ...                         # but may be overridden in exception subclasses
     ...    x, y = inst.args     # unpack args
     ...    print('x =', x)
     ...    print('y =', y)
     ...
     <class 'Exception'>
     ('spam', 'eggs')
     ('spam', 'eggs')
     x = spam
     y = eggs

If an exception has arguments, they are printed as the last part
(’detail’) of the message for unhandled exceptions.

Exception handlers don’t just handle exceptions if they occur
immediately in the try clause, but also if they occur inside functions
that are called (even indirectly) in the try clause.  For example:

     >>> def this_fails():
     ...     x = 1/0
     ...
     >>> try:
     ...     this_fails()
     ... except ZeroDivisionError as err:
     ...     print('Handling run-time error:', err)
     ...
     Handling run-time error: int division or modulo by zero


File: python.info,  Node: Raising Exceptions,  Next: User-defined Exceptions,  Prev: Handling Exceptions,  Up: Errors and Exceptions

2.8.4 Raising Exceptions
------------------------

The *note raise: 8a9. statement allows the programmer to force a
specified exception to occur.  For example:

     >>> raise NameError('HiThere')
     Traceback (most recent call last):
       File "<stdin>", line 1, in ?
     NameError: HiThere

The sole argument to *note raise: 8a9. indicates the exception to be
raised.  This must be either an exception instance or an exception class
(a class that derives from *note Exception: 1a1.).

If you need to determine whether an exception was raised but don’t
intend to handle it, a simpler form of the *note raise: 8a9. statement
allows you to re-raise the exception:

     >>> try:
     ...     raise NameError('HiThere')
     ... except NameError:
     ...     print('An exception flew by!')
     ...     raise
     ...
     An exception flew by!
     Traceback (most recent call last):
       File "<stdin>", line 2, in ?
     NameError: HiThere


File: python.info,  Node: User-defined Exceptions,  Next: Defining Clean-up Actions,  Prev: Raising Exceptions,  Up: Errors and Exceptions

2.8.5 User-defined Exceptions
-----------------------------

Programs may name their own exceptions by creating a new exception class
(see *note Classes: c0c. for more about Python classes).  Exceptions
should typically be derived from the *note Exception: 1a1. class, either
directly or indirectly.  For example:

     >>> class MyError(Exception):
     ...     def __init__(self, value):
     ...         self.value = value
     ...     def __str__(self):
     ...         return repr(self.value)
     ...
     >>> try:
     ...     raise MyError(2*2)
     ... except MyError as e:
     ...     print('My exception occurred, value:', e.value)
     ...
     My exception occurred, value: 4
     >>> raise MyError('oops!')
     Traceback (most recent call last):
       File "<stdin>", line 1, in ?
     __main__.MyError: 'oops!'

In this example, the default *note __init__(): 9d5. of *note Exception:
1a1. has been overridden.  The new behavior simply creates the `value'
attribute.  This replaces the default behavior of creating the `args'
attribute.

Exception classes can be defined which do anything any other class can
do, but are usually kept simple, often only offering a number of
attributes that allow information about the error to be extracted by
handlers for the exception.  When creating a module that can raise
several distinct errors, a common practice is to create a base class for
exceptions defined by that module, and subclass that to create specific
exception classes for different error conditions:

     class Error(Exception):
         """Base class for exceptions in this module."""
         pass

     class InputError(Error):
         """Exception raised for errors in the input.

         Attributes:
             expression -- input expression in which the error occurred
             message -- explanation of the error
         """

         def __init__(self, expression, message):
             self.expression = expression
             self.message = message

     class TransitionError(Error):
         """Raised when an operation attempts a state transition that's not
         allowed.

         Attributes:
             previous -- state at beginning of transition
             next -- attempted new state
             message -- explanation of why the specific transition is not allowed
         """

         def __init__(self, previous, next, message):
             self.previous = previous
             self.next = next
             self.message = message

Most exceptions are defined with names that end in "Error," similar to
the naming of the standard exceptions.

Many standard modules define their own exceptions to report errors that
may occur in functions they define.  More information on classes is
presented in chapter *note Classes: c0c.


File: python.info,  Node: Defining Clean-up Actions,  Next: Predefined Clean-up Actions,  Prev: User-defined Exceptions,  Up: Errors and Exceptions

2.8.6 Defining Clean-up Actions
-------------------------------

The *note try: 9e9. statement has another optional clause which is
intended to define clean-up actions that must be executed under all
circumstances.  For example:

     >>> try:
     ...     raise KeyboardInterrupt
     ... finally:
     ...     print('Goodbye, world!')
     ...
     Goodbye, world!
     Traceback (most recent call last):
       File "<stdin>", line 2, in ?
     KeyboardInterrupt

A `finally clause' is always executed before leaving the *note try: 9e9.
statement, whether an exception has occurred or not.  When an exception
has occurred in the *note try: 9e9. clause and has not been handled by
an *note except: 785. clause (or it has occurred in an *note except:
785. or *note else: bfa. clause), it is re-raised after the *note
finally: 526. clause has been executed.  The *note finally: 526. clause
is also executed "on the way out" when any other clause of the *note
try: 9e9. statement is left via a *note break: c02, *note continue: c04.
or *note return: 981. statement.  A more complicated example:

     >>> def divide(x, y):
     ...     try:
     ...         result = x / y
     ...     except ZeroDivisionError:
     ...         print("division by zero!")
     ...     else:
     ...         print("result is", result)
     ...     finally:
     ...         print("executing finally clause")
     ...
     >>> divide(2, 1)
     result is 2.0
     executing finally clause
     >>> divide(2, 0)
     division by zero!
     executing finally clause
     >>> divide("2", "1")
     executing finally clause
     Traceback (most recent call last):
       File "<stdin>", line 1, in ?
       File "<stdin>", line 3, in divide
     TypeError: unsupported operand type(s) for /: 'str' and 'str'

As you can see, the *note finally: 526. clause is executed in any event.
The *note TypeError: 562. raised by dividing two strings is not handled
by the *note except: 785. clause and therefore re-raised after the *note
finally: 526. clause has been executed.

In real world applications, the *note finally: 526. clause is useful for
releasing external resources (such as files or network connections),
regardless of whether the use of the resource was successful.


File: python.info,  Node: Predefined Clean-up Actions,  Prev: Defining Clean-up Actions,  Up: Errors and Exceptions

2.8.7 Predefined Clean-up Actions
---------------------------------

Some objects define standard clean-up actions to be undertaken when the
object is no longer needed, regardless of whether or not the operation
using the object succeeded or failed.  Look at the following example,
which tries to open a file and print its contents to the screen.

     for line in open("myfile.txt"):
         print(line, end="")

The problem with this code is that it leaves the file open for an
indeterminate amount of time after this part of the code has finished
executing.  This is not an issue in simple scripts, but can be a problem
for larger applications.  The *note with: 29d. statement allows objects
like files to be used in a way that ensures they are always cleaned up
promptly and correctly.

     with open("myfile.txt") as f:
         for line in f:
             print(line, end="")

After the statement is executed, the file `f' is always closed, even if
a problem was encountered while processing the lines.  Objects which,
like files, provide predefined clean-up actions will indicate this in
their documentation.


File: python.info,  Node: Classes,  Next: Brief Tour of the Standard Library,  Prev: Errors and Exceptions,  Up: The Python Tutorial

2.9 Classes
===========

Compared with other programming languages, Python’s class mechanism adds
classes with a minimum of new syntax and semantics.  It is a mixture of
the class mechanisms found in C++ and Modula-3.  Python classes provide
all the standard features of Object Oriented Programming: the class
inheritance mechanism allows multiple base classes, a derived class can
override any methods of its base class or classes, and a method can call
the method of a base class with the same name.  Objects can contain
arbitrary amounts and kinds of data.  As is true for modules, classes
partake of the dynamic nature of Python: they are created at runtime,
and can be modified further after creation.

In C++ terminology, normally class members (including the data members)
are `public' (except see below *note Private Variables: c77.), and all
member functions are `virtual'.  As in Modula-3, there are no shorthands
for referencing the object’s members from its methods: the method
function is declared with an explicit first argument representing the
object, which is provided implicitly by the call.  As in Smalltalk,
classes themselves are objects.  This provides semantics for importing
and renaming.  Unlike C++ and Modula-3, built-in types can be used as
base classes for extension by the user.  Also, like in C++, most
built-in operators with special syntax (arithmetic operators,
subscripting etc.)  can be redefined for class instances.

(Lacking universally accepted terminology to talk about classes, I will
make occasional use of Smalltalk and C++ terms.  I would use Modula-3
terms, since its object-oriented semantics are closer to those of Python
than C++, but I expect that few readers have heard of it.)

* Menu:

* A Word About Names and Objects:: 
* Python Scopes and Namespaces:: 
* A First Look at Classes:: 
* Random Remarks:: 
* Inheritance:: 
* Private Variables:: 
* Odds and Ends:: 
* Exceptions Are Classes Too:: 
* Iterators:: 
* Generators:: 
* Generator Expressions:: 


File: python.info,  Node: A Word About Names and Objects,  Next: Python Scopes and Namespaces,  Up: Classes

2.9.1 A Word About Names and Objects
------------------------------------

Objects have individuality, and multiple names (in multiple scopes) can
be bound to the same object.  This is known as aliasing in other
languages.  This is usually not appreciated on a first glance at Python,
and can be safely ignored when dealing with immutable basic types
(numbers, strings, tuples).  However, aliasing has a possibly surprising
effect on the semantics of Python code involving mutable objects such as
lists, dictionaries, and most other types.  This is usually used to the
benefit of the program, since aliases behave like pointers in some
respects.  For example, passing an object is cheap since only a pointer
is passed by the implementation; and if a function modifies an object
passed as an argument, the caller will see the change — this eliminates
the need for two different argument passing mechanisms as in Pascal.


File: python.info,  Node: Python Scopes and Namespaces,  Next: A First Look at Classes,  Prev: A Word About Names and Objects,  Up: Classes

2.9.2 Python Scopes and Namespaces
----------------------------------

Before introducing classes, I first have to tell you something about
Python’s scope rules.  Class definitions play some neat tricks with
namespaces, and you need to know how scopes and namespaces work to fully
understand what’s going on.  Incidentally, knowledge about this subject
is useful for any advanced Python programmer.

Let’s begin with some definitions.

A `namespace' is a mapping from names to objects.  Most namespaces are
currently implemented as Python dictionaries, but that’s normally not
noticeable in any way (except for performance), and it may change in the
future.  Examples of namespaces are: the set of built-in names
(containing functions such as *note abs(): c7c, and built-in exception
names); the global names in a module; and the local names in a function
invocation.  In a sense the set of attributes of an object also form a
namespace.  The important thing to know about namespaces is that there
is absolutely no relation between names in different namespaces; for
instance, two different modules may both define a function ‘maximize’
without confusion — users of the modules must prefix it with the module
name.

By the way, I use the word `attribute' for any name following a dot —
for example, in the expression ‘z.real’, ‘real’ is an attribute of the
object ‘z’.  Strictly speaking, references to names in modules are
attribute references: in the expression ‘modname.funcname’, ‘modname’ is
a module object and ‘funcname’ is an attribute of it.  In this case
there happens to be a straightforward mapping between the module’s
attributes and the global names defined in the module: they share the
same namespace!  (1)

Attributes may be read-only or writable.  In the latter case, assignment
to attributes is possible.  Module attributes are writable: you can
write ‘modname.the_answer = 42’.  Writable attributes may also be
deleted with the *note del: c30. statement.  For example, ‘del
modname.the_answer’ will remove the attribute ‘the_answer’ from the
object named by ‘modname’.

Namespaces are created at different moments and have different
lifetimes.  The namespace containing the built-in names is created when
the Python interpreter starts up, and is never deleted.  The global
namespace for a module is created when the module definition is read in;
normally, module namespaces also last until the interpreter quits.  The
statements executed by the top-level invocation of the interpreter,
either read from a script file or interactively, are considered part of
a module called *note __main__: 1, so they have their own global
namespace.  (The built-in names actually also live in a module; this is
called *note builtins: 13.)

The local namespace for a function is created when the function is
called, and deleted when the function returns or raises an exception
that is not handled within the function.  (Actually, forgetting would be
a better way to describe what actually happens.)  Of course, recursive
invocations each have their own local namespace.

A `scope' is a textual region of a Python program where a namespace is
directly accessible.  "Directly accessible" here means that an
unqualified reference to a name attempts to find the name in the
namespace.

Although scopes are determined statically, they are used dynamically.
At any time during execution, there are at least three nested scopes
whose namespaces are directly accessible:

   * the innermost scope, which is searched first, contains the local
     names

   * the scopes of any enclosing functions, which are searched starting
     with the nearest enclosing scope, contains non-local, but also
     non-global names

   * the next-to-last scope contains the current module’s global names

   * the outermost scope (searched last) is the namespace containing
     built-in names

If a name is declared global, then all references and assignments go
directly to the middle scope containing the module’s global names.  To
rebind variables found outside of the innermost scope, the *note
nonlocal: 8a6. statement can be used; if not declared nonlocal, those
variable are read-only (an attempt to write to such a variable will
simply create a `new' local variable in the innermost scope, leaving the
identically named outer variable unchanged).

Usually, the local scope references the local names of the (textually)
current function.  Outside functions, the local scope references the
same namespace as the global scope: the module’s namespace.  Class
definitions place yet another namespace in the local scope.

It is important to realize that scopes are determined textually: the
global scope of a function defined in a module is that module’s
namespace, no matter from where or by what alias the function is called.
On the other hand, the actual search for names is done dynamically, at
run time — however, the language definition is evolving towards static
name resolution, at "compile" time, so don’t rely on dynamic name
resolution!  (In fact, local variables are already determined
statically.)

A special quirk of Python is that – if no *note global: c0b. statement
is in effect – assignments to names always go into the innermost scope.
Assignments do not copy data — they just bind names to objects.  The
same is true for deletions: the statement ‘del x’ removes the binding of
‘x’ from the namespace referenced by the local scope.  In fact, all
operations that introduce new names use the local scope: in particular,
*note import: 881. statements and function definitions bind the module
or function name in the local scope.

The *note global: c0b. statement can be used to indicate that particular
variables live in the global scope and should be rebound there; the
*note nonlocal: 8a6. statement indicates that particular variables live
in an enclosing scope and should be rebound there.

* Menu:

* Scopes and Namespaces Example:: 

   ---------- Footnotes ----------

   (1) Except for one thing.  Module objects have a secret read-only
attribute called ‘__dict__’ which returns the dictionary used to
implement the module’s namespace; the name ‘__dict__’ is an attribute
but not a global name.  Obviously, using this violates the abstraction
of namespace implementation, and should be restricted to things like
post-mortem debuggers.


File: python.info,  Node: Scopes and Namespaces Example,  Up: Python Scopes and Namespaces

2.9.2.1 Scopes and Namespaces Example
.....................................

This is an example demonstrating how to reference the different scopes
and namespaces, and how *note global: c0b. and *note nonlocal: 8a6.
affect variable binding:

     def scope_test():
         def do_local():
             spam = "local spam"
         def do_nonlocal():
             nonlocal spam
             spam = "nonlocal spam"
         def do_global():
             global spam
             spam = "global spam"
         spam = "test spam"
         do_local()
         print("After local assignment:", spam)
         do_nonlocal()
         print("After nonlocal assignment:", spam)
         do_global()
         print("After global assignment:", spam)

     scope_test()
     print("In global scope:", spam)

The output of the example code is:

     After local assignment: test spam
     After nonlocal assignment: nonlocal spam
     After global assignment: nonlocal spam
     In global scope: global spam

Note how the `local' assignment (which is default) didn’t change
`scope_test'’s binding of `spam'.  The *note nonlocal: 8a6. assignment
changed `scope_test'’s binding of `spam', and the *note global: c0b.
assignment changed the module-level binding.

You can also see that there was no previous binding for `spam' before
the *note global: c0b. assignment.


File: python.info,  Node: A First Look at Classes,  Next: Random Remarks,  Prev: Python Scopes and Namespaces,  Up: Classes

2.9.3 A First Look at Classes
-----------------------------

Classes introduce a little bit of new syntax, three new object types,
and some new semantics.

* Menu:

* Class Definition Syntax:: 
* Class Objects:: 
* Instance Objects:: 
* Method Objects:: 
* Class and Instance Variables:: 


File: python.info,  Node: Class Definition Syntax,  Next: Class Objects,  Up: A First Look at Classes

2.9.3.1 Class Definition Syntax
...............................

The simplest form of class definition looks like this:

     class ClassName:
         <statement-1>
         .
         .
         .
         <statement-N>

Class definitions, like function definitions (*note def: a3a.
statements) must be executed before they have any effect.  (You could
conceivably place a class definition in a branch of an *note if: a65.
statement, or inside a function.)

In practice, the statements inside a class definition will usually be
function definitions, but other statements are allowed, and sometimes
useful — we’ll come back to this later.  The function definitions inside
a class normally have a peculiar form of argument list, dictated by the
calling conventions for methods — again, this is explained later.

When a class definition is entered, a new namespace is created, and used
as the local scope — thus, all assignments to local variables go into
this new namespace.  In particular, function definitions bind the name
of the new function here.

When a class definition is left normally (via the end), a `class object'
is created.  This is basically a wrapper around the contents of the
namespace created by the class definition; we’ll learn more about class
objects in the next section.  The original local scope (the one in
effect just before the class definition was entered) is reinstated, and
the class object is bound here to the class name given in the class
definition header (‘ClassName’ in the example).


File: python.info,  Node: Class Objects,  Next: Instance Objects,  Prev: Class Definition Syntax,  Up: A First Look at Classes

2.9.3.2 Class Objects
.....................

Class objects support two kinds of operations: attribute references and
instantiation.

`Attribute references' use the standard syntax used for all attribute
references in Python: ‘obj.name’.  Valid attribute names are all the
names that were in the class’s namespace when the class object was
created.  So, if the class definition looked like this:

     class MyClass:
         """A simple example class"""
         i = 12345
         def f(self):
             return 'hello world'

then ‘MyClass.i’ and ‘MyClass.f’ are valid attribute references,
returning an integer and a function object, respectively.  Class
attributes can also be assigned to, so you can change the value of
‘MyClass.i’ by assignment.  ‘__doc__’ is also a valid attribute,
returning the docstring belonging to the class: ‘"A simple example
class"’.

Class `instantiation' uses function notation.  Just pretend that the
class object is a parameterless function that returns a new instance of
the class.  For example (assuming the above class):

     x = MyClass()

creates a new `instance' of the class and assigns this object to the
local variable ‘x’.

The instantiation operation ("calling" a class object) creates an empty
object.  Many classes like to create objects with instances customized
to a specific initial state.  Therefore a class may define a special
method named *note __init__(): 9d5, like this:

     def __init__(self):
         self.data = []

When a class defines an *note __init__(): 9d5. method, class
instantiation automatically invokes *note __init__(): 9d5. for the
newly-created class instance.  So in this example, a new, initialized
instance can be obtained by:

     x = MyClass()

Of course, the *note __init__(): 9d5. method may have arguments for
greater flexibility.  In that case, arguments given to the class
instantiation operator are passed on to *note __init__(): 9d5.  For
example,

     >>> class Complex:
     ...     def __init__(self, realpart, imagpart):
     ...         self.r = realpart
     ...         self.i = imagpart
     ...
     >>> x = Complex(3.0, -4.5)
     >>> x.r, x.i
     (3.0, -4.5)


File: python.info,  Node: Instance Objects,  Next: Method Objects,  Prev: Class Objects,  Up: A First Look at Classes

2.9.3.3 Instance Objects
........................

Now what can we do with instance objects?  The only operations
understood by instance objects are attribute references.  There are two
kinds of valid attribute names, data attributes and methods.

`data attributes' correspond to "instance variables" in Smalltalk, and
to "data members" in C++.  Data attributes need not be declared; like
local variables, they spring into existence when they are first assigned
to.  For example, if ‘x’ is the instance of ‘MyClass’ created above, the
following piece of code will print the value ‘16’, without leaving a
trace:

     x.counter = 1
     while x.counter < 10:
         x.counter = x.counter * 2
     print(x.counter)
     del x.counter

The other kind of instance attribute reference is a `method'.  A method
is a function that "belongs to" an object.  (In Python, the term method
is not unique to class instances: other object types can have methods as
well.  For example, list objects have methods called append, insert,
remove, sort, and so on.  However, in the following discussion, we’ll
use the term method exclusively to mean methods of class instance
objects, unless explicitly stated otherwise.)

Valid method names of an instance object depend on its class.  By
definition, all attributes of a class that are function objects define
corresponding methods of its instances.  So in our example, ‘x.f’ is a
valid method reference, since ‘MyClass.f’ is a function, but ‘x.i’ is
not, since ‘MyClass.i’ is not.  But ‘x.f’ is not the same thing as
‘MyClass.f’ — it is a `method object', not a function object.


File: python.info,  Node: Method Objects,  Next: Class and Instance Variables,  Prev: Instance Objects,  Up: A First Look at Classes

2.9.3.4 Method Objects
......................

Usually, a method is called right after it is bound:

     x.f()

In the ‘MyClass’ example, this will return the string ‘'hello world'’.
However, it is not necessary to call a method right away: ‘x.f’ is a
method object, and can be stored away and called at a later time.  For
example:

     xf = x.f
     while True:
         print(xf())

will continue to print ‘hello world’ until the end of time.

What exactly happens when a method is called?  You may have noticed that
‘x.f()’ was called without an argument above, even though the function
definition for ‘f()’ specified an argument.  What happened to the
argument?  Surely Python raises an exception when a function that
requires an argument is called without any — even if the argument isn’t
actually used...

Actually, you may have guessed the answer: the special thing about
methods is that the object is passed as the first argument of the
function.  In our example, the call ‘x.f()’ is exactly equivalent to
‘MyClass.f(x)’.  In general, calling a method with a list of `n'
arguments is equivalent to calling the corresponding function with an
argument list that is created by inserting the method’s object before
the first argument.

If you still don’t understand how methods work, a look at the
implementation can perhaps clarify matters.  When an instance attribute
is referenced that isn’t a data attribute, its class is searched.  If
the name denotes a valid class attribute that is a function object, a
method object is created by packing (pointers to) the instance object
and the function object just found together in an abstract object: this
is the method object.  When the method object is called with an argument
list, a new argument list is constructed from the instance object and
the argument list, and the function object is called with this new
argument list.


File: python.info,  Node: Class and Instance Variables,  Prev: Method Objects,  Up: A First Look at Classes

2.9.3.5 Class and Instance Variables
....................................

Generally speaking, instance variables are for data unique to each
instance and class variables are for attributes and methods shared by
all instances of the class:

     class Dog:

         kind = 'canine'         # class variable shared by all instances

         def __init__(self, name):
             self.name = name    # instance variable unique to each instance

     >>> d = Dog('Fido')
     >>> e = Dog('Buddy')
     >>> d.kind                  # shared by all dogs
     'canine'
     >>> e.kind                  # shared by all dogs
     'canine'
     >>> d.name                  # unique to d
     'Fido'
     >>> e.name                  # unique to e
     'Buddy'

As discussed in *note A Word About Names and Objects: c79, shared data
can have possibly surprising effects with involving *note mutable: bf0.
objects such as lists and dictionaries.  For example, the `tricks' list
in the following code should not be used as a class variable because
just a single list would be shared by all `Dog' instances:

     class Dog:

         tricks = []             # mistaken use of a class variable

         def __init__(self, name):
             self.name = name

         def add_trick(self, trick):
             self.tricks.append(trick)

     >>> d = Dog('Fido')
     >>> e = Dog('Buddy')
     >>> d.add_trick('roll over')
     >>> e.add_trick('play dead')
     >>> d.tricks                # unexpectedly shared by all dogs
     ['roll over', 'play dead']

Correct design of the class should use an instance variable instead:

     class Dog:

         def __init__(self, name):
             self.name = name
             self.tricks = []    # creates a new empty list for each dog

         def add_trick(self, trick):
             self.tricks.append(trick)

     >>> d = Dog('Fido')
     >>> e = Dog('Buddy')
     >>> d.add_trick('roll over')
     >>> e.add_trick('play dead')
     >>> d.tricks
     ['roll over']
     >>> e.tricks
     ['play dead']


File: python.info,  Node: Random Remarks,  Next: Inheritance,  Prev: A First Look at Classes,  Up: Classes

2.9.4 Random Remarks
--------------------

Data attributes override method attributes with the same name; to avoid
accidental name conflicts, which may cause hard-to-find bugs in large
programs, it is wise to use some kind of convention that minimizes the
chance of conflicts.  Possible conventions include capitalizing method
names, prefixing data attribute names with a small unique string
(perhaps just an underscore), or using verbs for methods and nouns for
data attributes.

Data attributes may be referenced by methods as well as by ordinary
users ("clients") of an object.  In other words, classes are not usable
to implement pure abstract data types.  In fact, nothing in Python makes
it possible to enforce data hiding — it is all based upon convention.
(On the other hand, the Python implementation, written in C, can
completely hide implementation details and control access to an object
if necessary; this can be used by extensions to Python written in C.)

Clients should use data attributes with care — clients may mess up
invariants maintained by the methods by stamping on their data
attributes.  Note that clients may add data attributes of their own to
an instance object without affecting the validity of the methods, as
long as name conflicts are avoided — again, a naming convention can save
a lot of headaches here.

There is no shorthand for referencing data attributes (or other
methods!)  from within methods.  I find that this actually increases the
readability of methods: there is no chance of confusing local variables
and instance variables when glancing through a method.

Often, the first argument of a method is called ‘self’.  This is nothing
more than a convention: the name ‘self’ has absolutely no special
meaning to Python.  Note, however, that by not following the convention
your code may be less readable to other Python programmers, and it is
also conceivable that a `class browser' program might be written that
relies upon such a convention.

Any function object that is a class attribute defines a method for
instances of that class.  It is not necessary that the function
definition is textually enclosed in the class definition: assigning a
function object to a local variable in the class is also ok.  For
example:

     # Function defined outside the class
     def f1(self, x, y):
         return min(x, x+y)

     class C:
         f = f1
         def g(self):
             return 'hello world'
         h = g

Now ‘f’, ‘g’ and ‘h’ are all attributes of class ‘C’ that refer to
function objects, and consequently they are all methods of instances of
‘C’ — ‘h’ being exactly equivalent to ‘g’.  Note that this practice
usually only serves to confuse the reader of a program.

Methods may call other methods by using method attributes of the ‘self’
argument:

     class Bag:
         def __init__(self):
             self.data = []
         def add(self, x):
             self.data.append(x)
         def addtwice(self, x):
             self.add(x)
             self.add(x)

Methods may reference global names in the same way as ordinary
functions.  The global scope associated with a method is the module
containing its definition.  (A class is never used as a global scope.)
While one rarely encounters a good reason for using global data in a
method, there are many legitimate uses of the global scope: for one
thing, functions and modules imported into the global scope can be used
by methods, as well as functions and classes defined in it.  Usually,
the class containing the method is itself defined in this global scope,
and in the next section we’ll find some good reasons why a method would
want to reference its own class.

Each value is an object, and therefore has a `class' (also called its
`type').  It is stored as ‘object.__class__’.


File: python.info,  Node: Inheritance,  Next: Private Variables,  Prev: Random Remarks,  Up: Classes

2.9.5 Inheritance
-----------------

Of course, a language feature would not be worthy of the name "class"
without supporting inheritance.  The syntax for a derived class
definition looks like this:

     class DerivedClassName(BaseClassName):
         <statement-1>
         .
         .
         .
         <statement-N>

The name ‘BaseClassName’ must be defined in a scope containing the
derived class definition.  In place of a base class name, other
arbitrary expressions are also allowed.  This can be useful, for
example, when the base class is defined in another module:

     class DerivedClassName(modname.BaseClassName):

Execution of a derived class definition proceeds the same as for a base
class.  When the class object is constructed, the base class is
remembered.  This is used for resolving attribute references: if a
requested attribute is not found in the class, the search proceeds to
look in the base class.  This rule is applied recursively if the base
class itself is derived from some other class.

There’s nothing special about instantiation of derived classes:
‘DerivedClassName()’ creates a new instance of the class.  Method
references are resolved as follows: the corresponding class attribute is
searched, descending down the chain of base classes if necessary, and
the method reference is valid if this yields a function object.

Derived classes may override methods of their base classes.  Because
methods have no special privileges when calling other methods of the
same object, a method of a base class that calls another method defined
in the same base class may end up calling a method of a derived class
that overrides it.  (For C++ programmers: all methods in Python are
effectively ‘virtual’.)

An overriding method in a derived class may in fact want to extend
rather than simply replace the base class method of the same name.
There is a simple way to call the base class method directly: just call
‘BaseClassName.methodname(self, arguments)’.  This is occasionally
useful to clients as well.  (Note that this only works if the base class
is accessible as ‘BaseClassName’ in the global scope.)

Python has two built-in functions that work with inheritance:

   * Use *note isinstance(): 998. to check an instance’s type:
     ‘isinstance(obj, int)’ will be ‘True’ only if ‘obj.__class__’ is
     *note int: 227. or some class derived from *note int: 227.

   * Use *note issubclass(): 999. to check class inheritance:
     ‘issubclass(bool, int)’ is ‘True’ since *note bool: a72. is a
     subclass of *note int: 227.  However, ‘issubclass(float, int)’ is
     ‘False’ since *note float: 57a. is not a subclass of *note int:
     227.

* Menu:

* Multiple Inheritance:: 


File: python.info,  Node: Multiple Inheritance,  Up: Inheritance

2.9.5.1 Multiple Inheritance
............................

Python supports a form of multiple inheritance as well.  A class
definition with multiple base classes looks like this:

     class DerivedClassName(Base1, Base2, Base3):
         <statement-1>
         .
         .
         .
         <statement-N>

For most purposes, in the simplest cases, you can think of the search
for attributes inherited from a parent class as depth-first,
left-to-right, not searching twice in the same class where there is an
overlap in the hierarchy.  Thus, if an attribute is not found in
‘DerivedClassName’, it is searched for in ‘Base1’, then (recursively) in
the base classes of ‘Base1’, and if it was not found there, it was
searched for in ‘Base2’, and so on.

In fact, it is slightly more complex than that; the method resolution
order changes dynamically to support cooperative calls to *note super():
56a.  This approach is known in some other multiple-inheritance
languages as call-next-method and is more powerful than the super call
found in single-inheritance languages.

Dynamic ordering is necessary because all cases of multiple inheritance
exhibit one or more diamond relationships (where at least one of the
parent classes can be accessed through multiple paths from the
bottommost class).  For example, all classes inherit from *note object:
5cb, so any case of multiple inheritance provides more than one path to
reach *note object: 5cb.  To keep the base classes from being accessed
more than once, the dynamic algorithm linearizes the search order in a
way that preserves the left-to-right ordering specified in each class,
that calls each parent only once, and that is monotonic (meaning that a
class can be subclassed without affecting the precedence order of its
parents).  Taken together, these properties make it possible to design
reliable and extensible classes with multiple inheritance.  For more
detail, see ‘https://www.python.org/download/releases/2.3/mro/’.


File: python.info,  Node: Private Variables,  Next: Odds and Ends,  Prev: Inheritance,  Up: Classes

2.9.6 Private Variables
-----------------------

"Private" instance variables that cannot be accessed except from inside
an object don’t exist in Python.  However, there is a convention that is
followed by most Python code: a name prefixed with an underscore (e.g.
‘_spam’) should be treated as a non-public part of the API (whether it
is a function, a method or a data member).  It should be considered an
implementation detail and subject to change without notice.

Since there is a valid use-case for class-private members (namely to
avoid name clashes of names with names defined by subclasses), there is
limited support for such a mechanism, called `name mangling'.  Any
identifier of the form ‘__spam’ (at least two leading underscores, at
most one trailing underscore) is textually replaced with
‘_classname__spam’, where ‘classname’ is the current class name with
leading underscore(s) stripped.  This mangling is done without regard to
the syntactic position of the identifier, as long as it occurs within
the definition of a class.

Name mangling is helpful for letting subclasses override methods without
breaking intraclass method calls.  For example:

     class Mapping:
         def __init__(self, iterable):
             self.items_list = []
             self.__update(iterable)

         def update(self, iterable):
             for item in iterable:
                 self.items_list.append(item)

         __update = update   # private copy of original update() method

     class MappingSubclass(Mapping):

         def update(self, keys, values):
             # provides new signature for update()
             # but does not break __init__()
             for item in zip(keys, values):
                 self.items_list.append(item)

Note that the mangling rules are designed mostly to avoid accidents; it
still is possible to access or modify a variable that is considered
private.  This can even be useful in special circumstances, such as in
the debugger.

Notice that code passed to ‘exec()’ or ‘eval()’ does not consider the
classname of the invoking class to be the current class; this is similar
to the effect of the ‘global’ statement, the effect of which is likewise
restricted to code that is byte-compiled together.  The same restriction
applies to ‘getattr()’, ‘setattr()’ and ‘delattr()’, as well as when
referencing ‘__dict__’ directly.


File: python.info,  Node: Odds and Ends,  Next: Exceptions Are Classes Too,  Prev: Private Variables,  Up: Classes

2.9.7 Odds and Ends
-------------------

Sometimes it is useful to have a data type similar to the Pascal
"record" or C "struct", bundling together a few named data items.  An
empty class definition will do nicely:

     class Employee:
         pass

     john = Employee() # Create an empty employee record

     # Fill the fields of the record
     john.name = 'John Doe'
     john.dept = 'computer lab'
     john.salary = 1000

A piece of Python code that expects a particular abstract data type can
often be passed a class that emulates the methods of that data type
instead.  For instance, if you have a function that formats some data
from a file object, you can define a class with methods ‘read()’ and
‘readline()’ that get the data from a string buffer instead, and pass it
as an argument.

Instance method objects have attributes, too: ‘m.__self__’ is the
instance object with the method ‘m()’, and ‘m.__func__’ is the function
object corresponding to the method.


File: python.info,  Node: Exceptions Are Classes Too,  Next: Iterators,  Prev: Odds and Ends,  Up: Classes

2.9.8 Exceptions Are Classes Too
--------------------------------

User-defined exceptions are identified by classes as well.  Using this
mechanism it is possible to create extensible hierarchies of exceptions.

There are two new valid (semantic) forms for the *note raise: 8a9.
statement:

     raise Class

     raise Instance

In the first form, ‘Class’ must be an instance of *note type: 376. or of
a class derived from it.  The first form is a shorthand for:

     raise Class()

A class in an *note except: 785. clause is compatible with an exception
if it is the same class or a base class thereof (but not the other way
around — an except clause listing a derived class is not compatible with
a base class).  For example, the following code will print B, C, D in
that order:

     class B(Exception):
         pass
     class C(B):
         pass
     class D(C):
         pass

     for cls in [B, C, D]:
         try:
             raise cls()
         except D:
             print("D")
         except C:
             print("C")
         except B:
             print("B")

Note that if the except clauses were reversed (with ‘except B’ first),
it would have printed B, B, B — the first matching except clause is
triggered.

When an error message is printed for an unhandled exception, the
exception’s class name is printed, then a colon and a space, and finally
the instance converted to a string using the built-in function *note
str(): 25a.


File: python.info,  Node: Iterators,  Next: Generators,  Prev: Exceptions Are Classes Too,  Up: Classes

2.9.9 Iterators
---------------

By now you have probably noticed that most container objects can be
looped over using a *note for: 895. statement:

     for element in [1, 2, 3]:
         print(element)
     for element in (1, 2, 3):
         print(element)
     for key in {'one':1, 'two':2}:
         print(key)
     for char in "123":
         print(char)
     for line in open("myfile.txt"):
         print(line, end='')

This style of access is clear, concise, and convenient.  The use of
iterators pervades and unifies Python.  Behind the scenes, the *note
for: 895. statement calls *note iter(): 99a. on the container object.
The function returns an iterator object that defines the method *note
__next__(): 8cf. which accesses elements in the container one at a time.
When there are no more elements, *note __next__(): 8cf. raises a *note
StopIteration: 191. exception which tells the *note for: 895. loop to
terminate.  You can call the *note __next__(): 8cf. method using the
*note next(): 218. built-in function; this example shows how it all
works:

     >>> s = 'abc'
     >>> it = iter(s)
     >>> it
     <iterator object at 0x00A1DB50>
     >>> next(it)
     'a'
     >>> next(it)
     'b'
     >>> next(it)
     'c'
     >>> next(it)
     Traceback (most recent call last):
       File "<stdin>", line 1, in ?
         next(it)
     StopIteration

Having seen the mechanics behind the iterator protocol, it is easy to
add iterator behavior to your classes.  Define an *note __iter__(): 99b.
method which returns an object with a *note __next__(): 8cf. method.  If
the class defines ‘__next__()’, then *note __iter__(): 99b. can just
return ‘self’:

     class Reverse:
         """Iterator for looping over a sequence backwards."""
         def __init__(self, data):
             self.data = data
             self.index = len(data)
         def __iter__(self):
             return self
         def __next__(self):
             if self.index == 0:
                 raise StopIteration
             self.index = self.index - 1
             return self.data[self.index]

     >>> rev = Reverse('spam')
     >>> iter(rev)
     <__main__.Reverse object at 0x00A1DB50>
     >>> for char in rev:
     ...     print(char)
     ...
     m
     a
     p
     s


File: python.info,  Node: Generators,  Next: Generator Expressions,  Prev: Iterators,  Up: Classes

2.9.10 Generators
-----------------

*note Generator: 5c0.s are a simple and powerful tool for creating
iterators.  They are written like regular functions but use the *note
yield: 480. statement whenever they want to return data.  Each time
*note next(): 218. is called on it, the generator resumes where it left
off (it remembers all the data values and which statement was last
executed).  An example shows that generators can be trivially easy to
create:

     def reverse(data):
         for index in range(len(data)-1, -1, -1):
             yield data[index]

     >>> for char in reverse('golf'):
     ...     print(char)
     ...
     f
     l
     o
     g

Anything that can be done with generators can also be done with
class-based iterators as described in the previous section.  What makes
generators so compact is that the *note __iter__(): 99b. and *note
__next__(): c99. methods are created automatically.

Another key feature is that the local variables and execution state are
automatically saved between calls.  This made the function easier to
write and much more clear than an approach using instance variables like
‘self.index’ and ‘self.data’.

In addition to automatic method creation and saving program state, when
generators terminate, they automatically raise *note StopIteration: 191.
In combination, these features make it easy to create iterators with no
more effort than writing a regular function.


File: python.info,  Node: Generator Expressions,  Prev: Generators,  Up: Classes

2.9.11 Generator Expressions
----------------------------

Some simple generators can be coded succinctly as expressions using a
syntax similar to list comprehensions but with parentheses instead of
brackets.  These expressions are designed for situations where the
generator is used right away by an enclosing function.  Generator
expressions are more compact but less versatile than full generator
definitions and tend to be more memory friendly than equivalent list
comprehensions.

Examples:

     >>> sum(i*i for i in range(10))                 # sum of squares
     285

     >>> xvec = [10, 20, 30]
     >>> yvec = [7, 5, 3]
     >>> sum(x*y for x,y in zip(xvec, yvec))         # dot product
     260

     >>> from math import pi, sin
     >>> sine_table = {x: sin(x*pi/180) for x in range(0, 91)}

     >>> unique_words = set(word  for line in page  for word in line.split())

     >>> valedictorian = max((student.gpa, student.name) for student in graduates)

     >>> data = 'golf'
     >>> list(data[i] for i in range(len(data)-1, -1, -1))
     ['f', 'l', 'o', 'g']


File: python.info,  Node: Brief Tour of the Standard Library,  Next: Brief Tour of the Standard Library -- Part II,  Prev: Classes,  Up: The Python Tutorial

2.10 Brief Tour of the Standard Library
=======================================

* Menu:

* Operating System Interface:: 
* File Wildcards:: 
* Command Line Arguments:: 
* Error Output Redirection and Program Termination:: 
* String Pattern Matching:: 
* Mathematics:: 
* Internet Access:: 
* Dates and Times:: 
* Data Compression:: 
* Performance Measurement:: 
* Quality Control:: 
* Batteries Included:: 


File: python.info,  Node: Operating System Interface,  Next: File Wildcards,  Up: Brief Tour of the Standard Library

2.10.1 Operating System Interface
---------------------------------

The *note os: c2. module provides dozens of functions for interacting
with the operating system:

     >>> import os
     >>> os.getcwd()      # Return the current working directory
     'C:\\Python36'
     >>> os.chdir('/server/accesslogs')   # Change current working directory
     >>> os.system('mkdir today')   # Run the command mkdir in the system shell
     0

Be sure to use the ‘import os’ style instead of ‘from os import *’.
This will keep *note os.open(): 1f4. from shadowing the built-in *note
open(): 1e8. function which operates much differently.

The built-in *note dir(): 16a. and *note help(): 3b6. functions are
useful as interactive aids for working with large modules like *note os:
c2.:

     >>> import os
     >>> dir(os)
     <returns a list of all module functions>
     >>> help(os)
     <returns an extensive manual page created from the module's docstrings>

For daily file and directory management tasks, the *note shutil: e7.
module provides a higher level interface that is easier to use:

     >>> import shutil
     >>> shutil.copyfile('data.db', 'archive.db')
     'archive.db'
     >>> shutil.move('/build/executables', 'installdir')
     'installdir'


File: python.info,  Node: File Wildcards,  Next: Command Line Arguments,  Prev: Operating System Interface,  Up: Brief Tour of the Standard Library

2.10.2 File Wildcards
---------------------

The *note glob: 89. module provides a function for making file lists
from directory wildcard searches:

     >>> import glob
     >>> glob.glob('*.py')
     ['primes.py', 'random.py', 'quote.py']


File: python.info,  Node: Command Line Arguments,  Next: Error Output Redirection and Program Termination,  Prev: File Wildcards,  Up: Brief Tour of the Standard Library

2.10.3 Command Line Arguments
-----------------------------

Common utility scripts often need to process command line arguments.
These arguments are stored in the *note sys: fb. module’s `argv'
attribute as a list.  For instance the following output results from
running ‘python demo.py one two three’ at the command line:

     >>> import sys
     >>> print(sys.argv)
     ['demo.py', 'one', 'two', 'three']

The *note getopt: 86. module processes `sys.argv' using the conventions
of the Unix *note getopt(): 86. function.  More powerful and flexible
command line processing is provided by the *note argparse: 6. module.


File: python.info,  Node: Error Output Redirection and Program Termination,  Next: String Pattern Matching,  Prev: Command Line Arguments,  Up: Brief Tour of the Standard Library

2.10.4 Error Output Redirection and Program Termination
-------------------------------------------------------

The *note sys: fb. module also has attributes for `stdin', `stdout', and
`stderr'.  The latter is useful for emitting warnings and error messages
to make them visible even when `stdout' has been redirected:

     >>> sys.stderr.write('Warning, log file not found starting a new one\n')
     Warning, log file not found starting a new one

The most direct way to terminate a script is to use ‘sys.exit()’.


File: python.info,  Node: String Pattern Matching,  Next: Mathematics,  Prev: Error Output Redirection and Program Termination,  Up: Brief Tour of the Standard Library

2.10.5 String Pattern Matching
------------------------------

The *note re: db. module provides regular expression tools for advanced
string processing.  For complex matching and manipulation, regular
expressions offer succinct, optimized solutions:

     >>> import re
     >>> re.findall(r'\bf[a-z]*', 'which foot or hand fell fastest')
     ['foot', 'fell', 'fastest']
     >>> re.sub(r'(\b[a-z]+) \1', r'\1', 'cat in the the hat')
     'cat in the hat'

When only simple capabilities are needed, string methods are preferred
because they are easier to read and debug:

     >>> 'tea for too'.replace('too', 'two')
     'tea for two'


File: python.info,  Node: Mathematics,  Next: Internet Access,  Prev: String Pattern Matching,  Up: Brief Tour of the Standard Library

2.10.6 Mathematics
------------------

The *note math: b0. module gives access to the underlying C library
functions for floating point math:

     >>> import math
     >>> math.cos(math.pi / 4)
     0.70710678118654757
     >>> math.log(1024, 2)
     10.0

The *note random: da. module provides tools for making random
selections:

     >>> import random
     >>> random.choice(['apple', 'pear', 'banana'])
     'apple'
     >>> random.sample(range(100), 10)   # sampling without replacement
     [30, 83, 16, 4, 8, 81, 41, 50, 18, 33]
     >>> random.random()    # random float
     0.17970987693706186
     >>> random.randrange(6)    # random integer chosen from range(6)
     4

The *note statistics: f3. module calculates basic statistical properties
(the mean, median, variance, etc.)  of numeric data:

     >>> import statistics
     >>> data = [2.75, 1.75, 1.25, 0.25, 0.5, 1.25, 3.5]
     >>> statistics.mean(data)
     1.6071428571428572
     >>> statistics.median(data)
     1.25
     >>> statistics.variance(data)
     1.3720238095238095

The SciPy project <‘http://scipy.org’> has many other modules for
numerical computations.


File: python.info,  Node: Internet Access,  Next: Dates and Times,  Prev: Mathematics,  Up: Brief Tour of the Standard Library

2.10.7 Internet Access
----------------------

There are a number of modules for accessing the internet and processing
internet protocols.  Two of the simplest are *note urllib.request: 11d.
for retrieving data from URLs and *note smtplib: eb. for sending mail:

     >>> from urllib.request import urlopen
     >>> with urlopen('http://tycho.usno.navy.mil/cgi-bin/timer.pl') as response:
     ...     for line in response:
     ...         line = line.decode('utf-8')  # Decoding the binary data to text.
     ...         if 'EST' in line or 'EDT' in line:  # look for Eastern Time
     ...             print(line)

     <BR>Nov. 25, 09:43:32 PM EST

     >>> import smtplib
     >>> server = smtplib.SMTP('localhost')
     >>> server.sendmail('soothsayer@example.org', 'jcaesar@example.org',
     ... """To: jcaesar@example.org
     ... From: soothsayer@example.org
     ...
     ... Beware the Ides of March.
     ... """)
     >>> server.quit()

(Note that the second example needs a mailserver running on localhost.)


File: python.info,  Node: Dates and Times,  Next: Data Compression,  Prev: Internet Access,  Up: Brief Tour of the Standard Library

2.10.8 Dates and Times
----------------------

The *note datetime: 2f. module supplies classes for manipulating dates
and times in both simple and complex ways.  While date and time
arithmetic is supported, the focus of the implementation is on efficient
member extraction for output formatting and manipulation.  The module
also supports objects that are timezone aware.

     >>> # dates are easily constructed and formatted
     >>> from datetime import date
     >>> now = date.today()
     >>> now
     datetime.date(2003, 12, 2)
     >>> now.strftime("%m-%d-%y. %d %b %Y is a %A on the %d day of %B.")
     '12-02-03. 02 Dec 2003 is a Tuesday on the 02 day of December.'

     >>> # dates support calendar arithmetic
     >>> birthday = date(1964, 7, 31)
     >>> age = now - birthday
     >>> age.days
     14368


File: python.info,  Node: Data Compression,  Next: Performance Measurement,  Prev: Dates and Times,  Up: Brief Tour of the Standard Library

2.10.9 Data Compression
-----------------------

Common data archiving and compression formats are directly supported by
modules including: *note zlib: 141, *note gzip: 8b, *note bz2: 14, *note
lzma: ab, *note zipfile: 13f. and *note tarfile: ff.

     >>> import zlib
     >>> s = b'witch which has which witches wrist watch'
     >>> len(s)
     41
     >>> t = zlib.compress(s)
     >>> len(t)
     37
     >>> zlib.decompress(t)
     b'witch which has which witches wrist watch'
     >>> zlib.crc32(s)
     226805979


File: python.info,  Node: Performance Measurement,  Next: Quality Control,  Prev: Data Compression,  Up: Brief Tour of the Standard Library

2.10.10 Performance Measurement
-------------------------------

Some Python users develop a deep interest in knowing the relative
performance of different approaches to the same problem.  Python
provides a measurement tool that answers those questions immediately.

For example, it may be tempting to use the tuple packing and unpacking
feature instead of the traditional approach to swapping arguments.  The
*note timeit: 108. module quickly demonstrates a modest performance
advantage:

     >>> from timeit import Timer
     >>> Timer('t=a; a=b; b=t', 'a=1; b=2').timeit()
     0.57535828626024577
     >>> Timer('a,b = b,a', 'a=1; b=2').timeit()
     0.54962537085770791

In contrast to *note timeit: 108.’s fine level of granularity, the *note
profile: d1. and *note pstats: d2. modules provide tools for identifying
time critical sections in larger blocks of code.


File: python.info,  Node: Quality Control,  Next: Batteries Included,  Prev: Performance Measurement,  Up: Brief Tour of the Standard Library

2.10.11 Quality Control
-----------------------

One approach for developing high quality software is to write tests for
each function as it is developed and to run those tests frequently
during the development process.

The *note doctest: 65. module provides a tool for scanning a module and
validating tests embedded in a program’s docstrings.  Test construction
is as simple as cutting-and-pasting a typical call along with its
results into the docstring.  This improves the documentation by
providing the user with an example and it allows the doctest module to
make sure the code remains true to the documentation:

     def average(values):
         """Computes the arithmetic mean of a list of numbers.

         >>> print(average([20, 30, 70]))
         40.0
         """
         return sum(values) / len(values)

     import doctest
     doctest.testmod()   # automatically validate the embedded tests

The *note unittest: 118. module is not as effortless as the *note
doctest: 65. module, but it allows a more comprehensive set of tests to
be maintained in a separate file:

     import unittest

     class TestStatisticalFunctions(unittest.TestCase):

         def test_average(self):
             self.assertEqual(average([20, 30, 70]), 40.0)
             self.assertEqual(round(average([1, 5, 7]), 1), 4.3)
             with self.assertRaises(ZeroDivisionError):
                 average([])
             with self.assertRaises(TypeError):
                 average(20, 30, 70)

     unittest.main() # Calling from the command line invokes all tests


File: python.info,  Node: Batteries Included,  Prev: Quality Control,  Up: Brief Tour of the Standard Library

2.10.12 Batteries Included
--------------------------

Python has a "batteries included" philosophy.  This is best seen through
the sophisticated and robust capabilities of its larger packages.  For
example:

   * The *note xmlrpc.client: 13c. and *note xmlrpc.server: 13d. modules
     make implementing remote procedure calls into an almost trivial
     task.  Despite the modules names, no direct knowledge or handling
     of XML is needed.

   * The *note email: 67. package is a library for managing email
     messages, including MIME and other RFC 2822-based message
     documents.  Unlike *note smtplib: eb. and *note poplib: ce. which
     actually send and receive messages, the email package has a
     complete toolset for building or decoding complex message
     structures (including attachments) and for implementing internet
     encoding and header protocols.

   * The *note json: a2. package provides robust support for parsing
     this popular data interchange format.  The *note csv: 29. module
     supports direct reading and writing of files in Comma-Separated
     Value format, commonly supported by databases and spreadsheets.
     XML processing is supported by the *note xml.etree.ElementTree:
     134, *note xml.dom: 131. and *note xml.sax: 138. packages.
     Together, these modules and packages greatly simplify data
     interchange between Python applications and other tools.

   * The *note sqlite3: f0. module is a wrapper for the SQLite database
     library, providing a persistent database that can be updated and
     accessed using slightly nonstandard SQL syntax.

   * Internationalization is supported by a number of modules including
     *note gettext: 88, *note locale: a7, and the *note codecs: 1c.
     package.


File: python.info,  Node: Brief Tour of the Standard Library -- Part II,  Next: Virtual Environments and Packages,  Prev: Brief Tour of the Standard Library,  Up: The Python Tutorial

2.11 Brief Tour of the Standard Library – Part II
=================================================

This second tour covers more advanced modules that support professional
programming needs.  These modules rarely occur in small scripts.

* Menu:

* Output Formatting:: 
* Templating:: 
* Working with Binary Data Record Layouts:: 
* Multi-threading: Multi-threading<2>. 
* Logging:: 
* Weak References:: 
* Tools for Working with Lists:: 
* Decimal Floating Point Arithmetic:: 


File: python.info,  Node: Output Formatting,  Next: Templating,  Up: Brief Tour of the Standard Library -- Part II

2.11.1 Output Formatting
------------------------

The *note reprlib: dd. module provides a version of *note repr(): 3bb.
customized for abbreviated displays of large or deeply nested
containers:

     >>> import reprlib
     >>> reprlib.repr(set('supercalifragilisticexpialidocious'))
     "{'a', 'c', 'd', 'e', 'f', 'g', ...}"

The *note pprint: d0. module offers more sophisticated control over
printing both built-in and user defined objects in a way that is
readable by the interpreter.  When the result is longer than one line,
the "pretty printer" adds line breaks and indentation to more clearly
reveal data structure:

     >>> import pprint
     >>> t = [[[['black', 'cyan'], 'white', ['green', 'red']], [['magenta',
     ...     'yellow'], 'blue']]]
     ...
     >>> pprint.pprint(t, width=30)
     [[[['black', 'cyan'],
        'white',
        ['green', 'red']],
       [['magenta', 'yellow'],
        'blue']]]

The *note textwrap: 105. module formats paragraphs of text to fit a
given screen width:

     >>> import textwrap
     >>> doc = """The wrap() method is just like fill() except that it returns
     ... a list of strings instead of one big string with newlines to separate
     ... the wrapped lines."""
     ...
     >>> print(textwrap.fill(doc, width=40))
     The wrap() method is just like fill()
     except that it returns a list of strings
     instead of one big string with newlines
     to separate the wrapped lines.

The *note locale: a7. module accesses a database of culture specific
data formats.  The grouping attribute of locale’s format function
provides a direct way of formatting numbers with group separators:

     >>> import locale
     >>> locale.setlocale(locale.LC_ALL, 'English_United States.1252')
     'English_United States.1252'
     >>> conv = locale.localeconv()          # get a mapping of conventions
     >>> x = 1234567.8
     >>> locale.format("%d", x, grouping=True)
     '1,234,567'
     >>> locale.format_string("%s%.*f", (conv['currency_symbol'],
     ...                      conv['frac_digits'], x), grouping=True)
     '$1,234,567.80'


File: python.info,  Node: Templating,  Next: Working with Binary Data Record Layouts,  Prev: Output Formatting,  Up: Brief Tour of the Standard Library -- Part II

2.11.2 Templating
-----------------

The *note string: f4. module includes a versatile *note Template: 7c4.
class with a simplified syntax suitable for editing by end-users.  This
allows users to customize their applications without having to alter the
application.

The format uses placeholder names formed by ‘$’ with valid Python
identifiers (alphanumeric characters and underscores).  Surrounding the
placeholder with braces allows it to be followed by more alphanumeric
letters with no intervening spaces.  Writing ‘$$’ creates a single
escaped ‘$’:

     >>> from string import Template
     >>> t = Template('${village}folk send $$10 to $cause.')
     >>> t.substitute(village='Nottingham', cause='the ditch fund')
     'Nottinghamfolk send $10 to the ditch fund.'

The *note substitute(): cbe. method raises a *note KeyError: 1a7. when a
placeholder is not supplied in a dictionary or a keyword argument.  For
mail-merge style applications, user supplied data may be incomplete and
the *note safe_substitute(): cbf. method may be more appropriate — it
will leave placeholders unchanged if data is missing:

     >>> t = Template('Return the $item to $owner.')
     >>> d = dict(item='unladen swallow')
     >>> t.substitute(d)
     Traceback (most recent call last):
       ...
     KeyError: 'owner'
     >>> t.safe_substitute(d)
     'Return the unladen swallow to $owner.'

Template subclasses can specify a custom delimiter.  For example, a
batch renaming utility for a photo browser may elect to use percent
signs for placeholders such as the current date, image sequence number,
or file format:

     >>> import time, os.path
     >>> photofiles = ['img_1074.jpg', 'img_1076.jpg', 'img_1077.jpg']
     >>> class BatchRename(Template):
     ...     delimiter = '%'
     >>> fmt = input('Enter rename style (%d-date %n-seqnum %f-format):  ')
     Enter rename style (%d-date %n-seqnum %f-format):  Ashley_%n%f

     >>> t = BatchRename(fmt)
     >>> date = time.strftime('%d%b%y')
     >>> for i, filename in enumerate(photofiles):
     ...     base, ext = os.path.splitext(filename)
     ...     newname = t.substitute(d=date, n=i, f=ext)
     ...     print('{0} --> {1}'.format(filename, newname))

     img_1074.jpg --> Ashley_0.jpg
     img_1076.jpg --> Ashley_1.jpg
     img_1077.jpg --> Ashley_2.jpg

Another application for templating is separating program logic from the
details of multiple output formats.  This makes it possible to
substitute custom templates for XML files, plain text reports, and HTML
web reports.


File: python.info,  Node: Working with Binary Data Record Layouts,  Next: Multi-threading<2>,  Prev: Templating,  Up: Brief Tour of the Standard Library -- Part II

2.11.3 Working with Binary Data Record Layouts
----------------------------------------------

The *note struct: f6. module provides *note pack(): 86c. and *note
unpack(): cc2. functions for working with variable length binary record
formats.  The following example shows how to loop through header
information in a ZIP file without using the *note zipfile: 13f. module.
Pack codes ‘"H"’ and ‘"I"’ represent two and four byte unsigned numbers
respectively.  The ‘"<"’ indicates that they are standard size and in
little-endian byte order:

     import struct

     with open('myfile.zip', 'rb') as f:
         data = f.read()

     start = 0
     for i in range(3):                      # show the first 3 file headers
         start += 14
         fields = struct.unpack('<IIIHH', data[start:start+16])
         crc32, comp_size, uncomp_size, filenamesize, extra_size = fields

         start += 16
         filename = data[start:start+filenamesize]
         start += filenamesize
         extra = data[start:start+extra_size]
         print(filename, hex(crc32), comp_size, uncomp_size)

         start += extra_size + comp_size     # skip to the next header


File: python.info,  Node: Multi-threading<2>,  Next: Logging,  Prev: Working with Binary Data Record Layouts,  Up: Brief Tour of the Standard Library -- Part II

2.11.4 Multi-threading
----------------------

Threading is a technique for decoupling tasks which are not sequentially
dependent.  Threads can be used to improve the responsiveness of
applications that accept user input while other tasks run in the
background.  A related use case is running I/O in parallel with
computations in another thread.

The following code shows how the high level *note threading: 106. module
can run tasks in background while the main program continues to run:

     import threading, zipfile

     class AsyncZip(threading.Thread):
         def __init__(self, infile, outfile):
             threading.Thread.__init__(self)
             self.infile = infile
             self.outfile = outfile
         def run(self):
             f = zipfile.ZipFile(self.outfile, 'w', zipfile.ZIP_DEFLATED)
             f.write(self.infile)
             f.close()
             print('Finished background zip of:', self.infile)

     background = AsyncZip('mydata.txt', 'myarchive.zip')
     background.start()
     print('The main program continues to run in foreground.')

     background.join()    # Wait for the background task to finish
     print('Main program waited until background was done.')

The principal challenge of multi-threaded applications is coordinating
threads that share data or other resources.  To that end, the threading
module provides a number of synchronization primitives including locks,
events, condition variables, and semaphores.

While those tools are powerful, minor design errors can result in
problems that are difficult to reproduce.  So, the preferred approach to
task coordination is to concentrate all access to a resource in a single
thread and then use the *note queue: d8. module to feed that thread with
requests from other threads.  Applications using *note Queue: cc5.
objects for inter-thread communication and coordination are easier to
design, more readable, and more reliable.


File: python.info,  Node: Logging,  Next: Weak References,  Prev: Multi-threading<2>,  Up: Brief Tour of the Standard Library -- Part II

2.11.5 Logging
--------------

The *note logging: a8. module offers a full featured and flexible
logging system.  At its simplest, log messages are sent to a file or to
‘sys.stderr’:

     import logging
     logging.debug('Debugging information')
     logging.info('Informational message')
     logging.warning('Warning:config file %s not found', 'server.conf')
     logging.error('Error occurred')
     logging.critical('Critical error -- shutting down')

This produces the following output:

     WARNING:root:Warning:config file server.conf not found
     ERROR:root:Error occurred
     CRITICAL:root:Critical error -- shutting down

By default, informational and debugging messages are suppressed and the
output is sent to standard error.  Other output options include routing
messages through email, datagrams, sockets, or to an HTTP Server.  New
filters can select different routing based on message priority: ‘DEBUG’,
‘INFO’, ‘WARNING’, ‘ERROR’, and ‘CRITICAL’.

The logging system can be configured directly from Python or can be
loaded from a user editable configuration file for customized logging
without altering the application.


File: python.info,  Node: Weak References,  Next: Tools for Working with Lists,  Prev: Logging,  Up: Brief Tour of the Standard Library -- Part II

2.11.6 Weak References
----------------------

Python does automatic memory management (reference counting for most
objects and *note garbage collection: cca. to eliminate cycles).  The
memory is freed shortly after the last reference to it has been
eliminated.

This approach works fine for most applications but occasionally there is
a need to track objects only as long as they are being used by something
else.  Unfortunately, just tracking them creates a reference that makes
them permanent.  The *note weakref: 125. module provides tools for
tracking objects without creating a reference.  When the object is no
longer needed, it is automatically removed from a weakref table and a
callback is triggered for weakref objects.  Typical applications include
caching objects that are expensive to create:

     >>> import weakref, gc
     >>> class A:
     ...     def __init__(self, value):
     ...         self.value = value
     ...     def __repr__(self):
     ...         return str(self.value)
     ...
     >>> a = A(10)                   # create a reference
     >>> d = weakref.WeakValueDictionary()
     >>> d['primary'] = a            # does not create a reference
     >>> d['primary']                # fetch the object if it is still alive
     10
     >>> del a                       # remove the one reference
     >>> gc.collect()                # run garbage collection right away
     0
     >>> d['primary']                # entry was automatically removed
     Traceback (most recent call last):
       File "<stdin>", line 1, in <module>
         d['primary']                # entry was automatically removed
       File "C:/python36/lib/weakref.py", line 46, in __getitem__
         o = self.data[key]()
     KeyError: 'primary'


File: python.info,  Node: Tools for Working with Lists,  Next: Decimal Floating Point Arithmetic,  Prev: Weak References,  Up: Brief Tour of the Standard Library -- Part II

2.11.7 Tools for Working with Lists
-----------------------------------

Many data structure needs can be met with the built-in list type.
However, sometimes there is a need for alternative implementations with
different performance trade-offs.

The *note array: 7. module provides an *note array(): 8c4. object that
is like a list that stores only homogeneous data and stores it more
compactly.  The following example shows an array of numbers stored as
two byte unsigned binary numbers (typecode ‘"H"’) rather than the usual
16 bytes per entry for regular lists of Python int objects:

     >>> from array import array
     >>> a = array('H', [4000, 10, 700, 22222])
     >>> sum(a)
     26932
     >>> a[1:3]
     array('H', [10, 700])

The *note collections: 1e. module provides a *note deque(): 24e. object
that is like a list with faster appends and pops from the left side but
slower lookups in the middle.  These objects are well suited for
implementing queues and breadth first tree searches:

     >>> from collections import deque
     >>> d = deque(["task1", "task2", "task3"])
     >>> d.append("task4")
     >>> print("Handling", d.popleft())
     Handling task1

     unsearched = deque([starting_node])
     def breadth_first_search(unsearched):
         node = unsearched.popleft()
         for m in gen_moves(node):
             if is_goal(m):
                 return m
             unsearched.append(m)

In addition to alternative list implementations, the library also offers
other tools such as the *note bisect: 12. module with functions for
manipulating sorted lists:

     >>> import bisect
     >>> scores = [(100, 'perl'), (200, 'tcl'), (400, 'lua'), (500, 'python')]
     >>> bisect.insort(scores, (300, 'ruby'))
     >>> scores
     [(100, 'perl'), (200, 'tcl'), (300, 'ruby'), (400, 'lua'), (500, 'python')]

The *note heapq: 8d. module provides functions for implementing heaps
based on regular lists.  The lowest valued entry is always kept at
position zero.  This is useful for applications which repeatedly access
the smallest element but do not want to run a full list sort:

     >>> from heapq import heapify, heappop, heappush
     >>> data = [1, 3, 5, 7, 9, 2, 4, 6, 8, 0]
     >>> heapify(data)                      # rearrange the list into heap order
     >>> heappush(data, -5)                 # add a new entry
     >>> [heappop(data) for i in range(3)]  # fetch the three smallest entries
     [-5, 0, 1]


File: python.info,  Node: Decimal Floating Point Arithmetic,  Prev: Tools for Working with Lists,  Up: Brief Tour of the Standard Library -- Part II

2.11.8 Decimal Floating Point Arithmetic
----------------------------------------

The *note decimal: 34. module offers a *note Decimal: 618. datatype for
decimal floating point arithmetic.  Compared to the built-in *note
float: 57a. implementation of binary floating point, the class is
especially helpful for

   * financial applications and other uses which require exact decimal
     representation,

   * control over precision,

   * control over rounding to meet legal or regulatory requirements,

   * tracking of significant decimal places, or

   * applications where the user expects the results to match
     calculations done by hand.

For example, calculating a 5% tax on a 70 cent phone charge gives
different results in decimal floating point and binary floating point.
The difference becomes significant if the results are rounded to the
nearest cent:

     >>> from decimal import *
     >>> round(Decimal('0.70') * Decimal('1.05'), 2)
     Decimal('0.74')
     >>> round(.70 * 1.05, 2)
     0.73

The *note Decimal: 618. result keeps a trailing zero, automatically
inferring four place significance from multiplicands with two place
significance.  Decimal reproduces mathematics as done by hand and avoids
issues that can arise when binary floating point cannot exactly
represent decimal quantities.

Exact representation enables the *note Decimal: 618. class to perform
modulo calculations and equality tests that are unsuitable for binary
floating point:

     >>> Decimal('1.00') % Decimal('.10')
     Decimal('0.00')
     >>> 1.00 % 0.10
     0.09999999999999995

     >>> sum([Decimal('0.1')]*10) == Decimal('1.0')
     True
     >>> sum([0.1]*10) == 1.0
     False

The *note decimal: 34. module provides arithmetic with as much precision
as needed:

     >>> getcontext().prec = 36
     >>> Decimal(1) / Decimal(7)
     Decimal('0.142857142857142857142857142857142857')


File: python.info,  Node: Virtual Environments and Packages,  Next: What Now?,  Prev: Brief Tour of the Standard Library -- Part II,  Up: The Python Tutorial

2.12 Virtual Environments and Packages
======================================

* Menu:

* Introduction: Introduction<4>. 
* Creating Virtual Environments:: 
* Managing Packages with pip:: 


File: python.info,  Node: Introduction<4>,  Next: Creating Virtual Environments,  Up: Virtual Environments and Packages

2.12.1 Introduction
-------------------

Python applications will often use packages and modules that don’t come
as part of the standard library.  Applications will sometimes need a
specific version of a library, because the application may require that
a particular bug has been fixed or the application may be written using
an obsolete version of the library’s interface.

This means it may not be possible for one Python installation to meet
the requirements of every application.  If application A needs version
1.0 of a particular module but application B needs version 2.0, then the
requirements are in conflict and installing either version 1.0 or 2.0
will leave one application unable to run.

The solution for this problem is to create a *note virtual environment:
cd3. (often shortened to "virtualenv"), a self-contained directory tree
that contains a Python installation for a particular version of Python,
plus a number of additional packages.

Different applications can then use different virtual environments.  To
resolve the earlier example of conflicting requirements, application A
can have its own virtual environment with version 1.0 installed while
application B has another virtualenv with version 2.0.  If application B
requires a library be upgraded to version 3.0, this will not affect
application A’s environment.


File: python.info,  Node: Creating Virtual Environments,  Next: Managing Packages with pip,  Prev: Introduction<4>,  Up: Virtual Environments and Packages

2.12.2 Creating Virtual Environments
------------------------------------

The script used to create and manage virtual environments is called
‘pyvenv’.  ‘pyvenv’ will usually install the most recent version of
Python that you have available; the script is also installed with a
version number, so if you have multiple versions of Python on your
system you can select a specific Python version by running ‘pyvenv-3.4’
or whichever version you want.

To create a virtualenv, decide upon a directory where you want to place
it and run ‘pyvenv’ with the directory path:

     pyvenv tutorial-env

This will create the ‘tutorial-env’ directory if it doesn’t exist, and
also create directories inside it containing a copy of the Python
interpreter, the standard library, and various supporting files.

Once you’ve created a virtual environment, you need to activate it.

On Windows, run:

     tutorial-env/Scripts/activate

On Unix or MacOS, run:

     source tutorial-env/bin/activate

(This script is written for the bash shell.  If you use the ‘csh’ or
‘fish’ shells, there are alternate ‘activate.csh’ and ‘activate.fish’
scripts you should use instead.)

Activating the virtualenv will change your shell’s prompt to show what
virtualenv you’re using, and modify the environment so that running
‘python’ will get you that particular version and installation of
Python.  For example:

     -> source ~/envs/tutorial-env/bin/activate
     (tutorial-env) -> python
     Python 3.4.3+ (3.4:c7b9645a6f35+, May 22 2015, 09:31:25)
       ...
     >>> import sys
     >>> sys.path
     ['', '/usr/local/lib/python34.zip', ...,
     '~/envs/tutorial-env/lib/python3.4/site-packages']
     >>>


File: python.info,  Node: Managing Packages with pip,  Prev: Creating Virtual Environments,  Up: Virtual Environments and Packages

2.12.3 Managing Packages with pip
---------------------------------

Once you’ve activated a virtual environment, you can install, upgrade,
and remove packages using a program called ‘pip’.  By default ‘pip’ will
install packages from the Python Package Index,
<‘https://pypi.python.org/pypi’>.  You can browse the Python Package
Index by going to it in your web browser, or you can use ‘pip’’s limited
search feature:

     (tutorial-env) -> pip search astronomy
     skyfield               - Elegant astronomy for Python
     gary                   - Galactic astronomy and gravitational dynamics.
     novas                  - The United States Naval Observatory NOVAS astronomy library
     astroobs               - Provides astronomy ephemeris to plan telescope observations
     PyAstronomy            - A collection of astronomy related tools for Python.
     ...

‘pip’ has a number of subcommands: "search", "install", "uninstall",
"freeze", etc.  (Consult the *note Installing Python Modules: 3e5. guide
for complete documentation for ‘pip’.)

You can install the latest version of a package by specifying a
package’s name:

     -> pip install novas
     Collecting novas
       Downloading novas-3.1.1.3.tar.gz (136kB)
     Installing collected packages: novas
       Running setup.py install for novas
     Successfully installed novas-3.1.1.3

You can also install a specific version of a package by giving the
package name followed by ‘==’ and the version number:

     -> pip install requests==2.6.0
     Collecting requests==2.6.0
       Using cached requests-2.6.0-py2.py3-none-any.whl
     Installing collected packages: requests
     Successfully installed requests-2.6.0

If you re-run this command, ‘pip’ will notice that the requested version
is already installed and do nothing.  You can supply a different version
number to get that version, or you can run ‘pip install --upgrade’ to
upgrade the package to the latest version:

     -> pip install --upgrade requests
     Collecting requests
     Installing collected packages: requests
       Found existing installation: requests 2.6.0
         Uninstalling requests-2.6.0:
           Successfully uninstalled requests-2.6.0
     Successfully installed requests-2.7.0

‘pip uninstall’ followed by one or more package names will remove the
packages from the virtual environment.

‘pip show’ will display information about a particular package:

     (tutorial-env) -> pip show requests
     ---
     Metadata-Version: 2.0
     Name: requests
     Version: 2.7.0
     Summary: Python HTTP for Humans.
     Home-page: http://python-requests.org
     Author: Kenneth Reitz
     Author-email: me@kennethreitz.com
     License: Apache 2.0
     Location: /Users/akuchling/envs/tutorial-env/lib/python3.4/site-packages
     Requires:

‘pip list’ will display all of the packages installed in the virtual
environment:

     (tutorial-env) -> pip list
     novas (3.1.1.3)
     numpy (1.9.2)
     pip (7.0.3)
     requests (2.7.0)
     setuptools (16.0)

‘pip freeze’ will produce a similar list of the installed packages, but
the output uses the format that ‘pip install’ expects.  A common
convention is to put this list in a ‘requirements.txt’ file:

     (tutorial-env) -> pip freeze > requirements.txt
     (tutorial-env) -> cat requirements.txt
     novas==3.1.1.3
     numpy==1.9.2
     requests==2.7.0

The ‘requirements.txt’ can then be committed to version control and
shipped as part of an application.  Users can then install all the
necessary packages with ‘install -r’:

     -> pip install -r requirements.txt
     Collecting novas==3.1.1.3 (from -r requirements.txt (line 1))
       ...
     Collecting numpy==1.9.2 (from -r requirements.txt (line 2))
       ...
     Collecting requests==2.7.0 (from -r requirements.txt (line 3))
       ...
     Installing collected packages: novas, numpy, requests
       Running setup.py install for novas
     Successfully installed novas-3.1.1.3 numpy-1.9.2 requests-2.7.0

‘pip’ has many more options.  Consult the *note Installing Python
Modules: 3e5. guide for complete documentation for ‘pip’.  When you’ve
written a package and want to make it available on the Python Package
Index, consult the *note Distributing Python Modules: 3e6. guide.


File: python.info,  Node: What Now?,  Next: Interactive Input Editing and History Substitution,  Prev: Virtual Environments and Packages,  Up: The Python Tutorial

2.13 What Now?
==============

Reading this tutorial has probably reinforced your interest in using
Python — you should be eager to apply Python to solving your real-world
problems.  Where should you go to learn more?

This tutorial is part of Python’s documentation set.  Some other
documents in the set are:

   * *note The Python Standard Library: bc5.:

     You should browse through this manual, which gives complete (though
     terse) reference material about types, functions, and the modules
     in the standard library.  The standard Python distribution includes
     a `lot' of additional code.  There are modules to read Unix
     mailboxes, retrieve documents via HTTP, generate random numbers,
     parse command-line options, write CGI programs, compress data, and
     many other tasks.  Skimming through the Library Reference will give
     you an idea of what’s available.

   * *note Installing Python Modules: 3e5. explains how to install
     additional modules written by other Python users.

   * *note The Python Language Reference: bc6.: A detailed explanation
     of Python’s syntax and semantics.  It’s heavy reading, but is
     useful as a complete guide to the language itself.

More Python resources:

   * ‘https://www.python.org’: The major Python Web site.  It contains
     code, documentation, and pointers to Python-related pages around
     the Web.  This Web site is mirrored in various places around the
     world, such as Europe, Japan, and Australia; a mirror may be faster
     than the main site, depending on your geographical location.

   * ‘https://docs.python.org’: Fast access to Python’s documentation.

   * ‘https://pypi.python.org/pypi’: The Python Package Index,
     previously also nicknamed the Cheese Shop, is an index of
     user-created Python modules that are available for download.  Once
     you begin releasing code, you can register it here so that others
     can find it.

   * ‘http://code.activestate.com/recipes/langs/python/’: The Python
     Cookbook is a sizable collection of code examples, larger modules,
     and useful scripts.  Particularly notable contributions are
     collected in a book also titled Python Cookbook (O’Reilly &
     Associates, ISBN 0-596-00797-3.)

   * ‘http://www.pyvideo.org’ collects links to Python-related videos
     from conferences and user-group meetings.

   * ‘http://scipy.org’: The Scientific Python project includes modules
     for fast array computations and manipulations plus a host of
     packages for such things as linear algebra, Fourier transforms,
     non-linear solvers, random number distributions, statistical
     analysis and the like.

For Python-related questions and problem reports, you can post to the
newsgroup ‘comp.lang.python’, or send them to the mailing list at
<python-list@python.org>.  The newsgroup and mailing list are gatewayed,
so messages posted to one will automatically be forwarded to the other.
There are hundreds of postings a day, asking (and answering) questions,
suggesting new features, and announcing new modules.  Mailing list
archives are available at ‘https://mail.python.org/pipermail/’.

Before posting, be sure to check the list of *note Frequently Asked
Questions: cd9. (also called the FAQ). The FAQ answers many of the
questions that come up again and again, and may already contain the
solution for your problem.


File: python.info,  Node: Interactive Input Editing and History Substitution,  Next: Floating Point Arithmetic Issues and Limitations,  Prev: What Now?,  Up: The Python Tutorial

2.14 Interactive Input Editing and History Substitution
=======================================================

Some versions of the Python interpreter support editing of the current
input line and history substitution, similar to facilities found in the
Korn shell and the GNU Bash shell.  This is implemented using the GNU
Readline(1) library, which supports various styles of editing.  This
library has its own documentation which we won’t duplicate here.

* Menu:

* Tab Completion and History Editing:: 
* Alternatives to the Interactive Interpreter:: 

   ---------- Footnotes ----------

   (1) http://tiswww.case.edu/php/chet/readline/rltop.html


File: python.info,  Node: Tab Completion and History Editing,  Next: Alternatives to the Interactive Interpreter,  Up: Interactive Input Editing and History Substitution

2.14.1 Tab Completion and History Editing
-----------------------------------------

Completion of variable and module names is *note automatically enabled:
4e7. at interpreter startup so that the ‘Tab’ key invokes the completion
function; it looks at Python statement names, the current local
variables, and the available module names.  For dotted expressions such
as ‘string.a’, it will evaluate the expression up to the final ‘'.'’ and
then suggest completions from the attributes of the resulting object.
Note that this may execute application-defined code if an object with a
*note __getattr__(): 782. method is part of the expression.  The default
configuration also saves your history into a file named
‘.python_history’ in your user directory.  The history will be available
again during the next interactive interpreter session.


File: python.info,  Node: Alternatives to the Interactive Interpreter,  Prev: Tab Completion and History Editing,  Up: Interactive Input Editing and History Substitution

2.14.2 Alternatives to the Interactive Interpreter
--------------------------------------------------

This facility is an enormous step forward compared to earlier versions
of the interpreter; however, some wishes are left: It would be nice if
the proper indentation were suggested on continuation lines (the parser
knows if an indent token is required next).  The completion mechanism
might use the interpreter’s symbol table.  A command to check (or even
suggest) matching parentheses, quotes, etc., would also be useful.

One alternative enhanced interactive interpreter that has been around
for quite some time is IPython(1), which features tab completion, object
exploration and advanced history management.  It can also be thoroughly
customized and embedded into other applications.  Another similar
enhanced interactive environment is bpython(2).

   ---------- Footnotes ----------

   (1) http://ipython.scipy.org/

   (2) http://www.bpython-interpreter.org/


File: python.info,  Node: Floating Point Arithmetic Issues and Limitations,  Next: Appendix,  Prev: Interactive Input Editing and History Substitution,  Up: The Python Tutorial

2.15 Floating Point Arithmetic: Issues and Limitations
======================================================

Floating-point numbers are represented in computer hardware as base 2
(binary) fractions.  For example, the decimal fraction

     0.125

has value 1/10 + 2/100 + 5/1000, and in the same way the binary fraction

     0.001

has value 0/2 + 0/4 + 1/8.  These two fractions have identical values,
the only real difference being that the first is written in base 10
fractional notation, and the second in base 2.

Unfortunately, most decimal fractions cannot be represented exactly as
binary fractions.  A consequence is that, in general, the decimal
floating-point numbers you enter are only approximated by the binary
floating-point numbers actually stored in the machine.

The problem is easier to understand at first in base 10.  Consider the
fraction 1/3.  You can approximate that as a base 10 fraction:

     0.3

or, better,

     0.33

or, better,

     0.333

and so on.  No matter how many digits you’re willing to write down, the
result will never be exactly 1/3, but will be an increasingly better
approximation of 1/3.

In the same way, no matter how many base 2 digits you’re willing to use,
the decimal value 0.1 cannot be represented exactly as a base 2
fraction.  In base 2, 1/10 is the infinitely repeating fraction

     0.0001100110011001100110011001100110011001100110011...

Stop at any finite number of bits, and you get an approximation.  On
most machines today, floats are approximated using a binary fraction
with the numerator using the first 53 bits starting with the most
significant bit and with the denominator as a power of two.  In the case
of 1/10, the binary fraction is ‘3602879701896397 / 2 ** 55’ which is
close to but not exactly equal to the true value of 1/10.

Many users are not aware of the approximation because of the way values
are displayed.  Python only prints a decimal approximation to the true
decimal value of the binary approximation stored by the machine.  On
most machines, if Python were to print the true decimal value of the
binary approximation stored for 0.1, it would have to display

     >>> 0.1
     0.1000000000000000055511151231257827021181583404541015625

That is more digits than most people find useful, so Python keeps the
number of digits manageable by displaying a rounded value instead

     >>> 1 / 10
     0.1

Just remember, even though the printed result looks like the exact value
of 1/10, the actual stored value is the nearest representable binary
fraction.

Interestingly, there are many different decimal numbers that share the
same nearest approximate binary fraction.  For example, the numbers
‘0.1’ and ‘0.10000000000000001’ and
‘0.1000000000000000055511151231257827021181583404541015625’ are all
approximated by ‘3602879701896397 / 2 ** 55’.  Since all of these
decimal values share the same approximation, any one of them could be
displayed while still preserving the invariant ‘eval(repr(x)) == x’.

Historically, the Python prompt and built-in *note repr(): 3bb. function
would choose the one with 17 significant digits, ‘0.10000000000000001’.
Starting with Python 3.1, Python (on most systems) is now able to choose
the shortest of these and simply display ‘0.1’.

Note that this is in the very nature of binary floating-point: this is
not a bug in Python, and it is not a bug in your code either.  You’ll
see the same kind of thing in all languages that support your hardware’s
floating-point arithmetic (although some languages may not `display' the
difference by default, or in all output modes).

For more pleasant output, you may wish to use string formatting to
produce a limited number of significant digits:

     >>> format(math.pi, '.12g')  # give 12 significant digits
     '3.14159265359'

     >>> format(math.pi, '.2f')   # give 2 digits after the point
     '3.14'

     >>> repr(math.pi)
     '3.141592653589793'

It’s important to realize that this is, in a real sense, an illusion:
you’re simply rounding the `display' of the true machine value.

One illusion may beget another.  For example, since 0.1 is not exactly
1/10, summing three values of 0.1 may not yield exactly 0.3, either:

     >>> .1 + .1 + .1 == .3
     False

Also, since the 0.1 cannot get any closer to the exact value of 1/10 and
0.3 cannot get any closer to the exact value of 3/10, then pre-rounding
with *note round(): 8d9. function cannot help:

     >>> round(.1, 1) + round(.1, 1) + round(.1, 1) == round(.3, 1)
     False

Though the numbers cannot be made closer to their intended exact values,
the *note round(): 8d9. function can be useful for post-rounding so that
results with inexact values become comparable to one another:

     >>> round(.1 + .1 + .1, 10) == round(.3, 10)
     True

Binary floating-point arithmetic holds many surprises like this.  The
problem with "0.1" is explained in precise detail below, in the
"Representation Error" section.  See The Perils of Floating Point(1) for
a more complete account of other common surprises.

As that says near the end, "there are no easy answers."  Still, don’t be
unduly wary of floating-point!  The errors in Python float operations
are inherited from the floating-point hardware, and on most machines are
on the order of no more than 1 part in 2**53 per operation.  That’s more
than adequate for most tasks, but you do need to keep in mind that it’s
not decimal arithmetic and that every float operation can suffer a new
rounding error.

While pathological cases do exist, for most casual use of floating-point
arithmetic you’ll see the result you expect in the end if you simply
round the display of your final results to the number of decimal digits
you expect.  *note str(): 25a. usually suffices, and for finer control
see the *note str.format(): 14d. method’s format specifiers in *note
Format String Syntax: 98a.

For use cases which require exact decimal representation, try using the
*note decimal: 34. module which implements decimal arithmetic suitable
for accounting applications and high-precision applications.

Another form of exact arithmetic is supported by the *note fractions:
82. module which implements arithmetic based on rational numbers (so the
numbers like 1/3 can be represented exactly).

If you are a heavy user of floating point operations you should take a
look at the Numerical Python package and many other packages for
mathematical and statistical operations supplied by the SciPy project.
See <‘http://scipy.org’>.

Python provides tools that may help on those rare occasions when you
really `do' want to know the exact value of a float.  The *note
float.as_integer_ratio(): ce4. method expresses the value of a float as
a fraction:

     >>> x = 3.14159
     >>> x.as_integer_ratio()
     (3537115888337719, 1125899906842624)

Since the ratio is exact, it can be used to losslessly recreate the
original value:

     >>> x == 3537115888337719 / 1125899906842624
     True

The *note float.hex(): ce5. method expresses a float in hexadecimal
(base 16), again giving the exact value stored by your computer:

     >>> x.hex()
     '0x1.921f9f01b866ep+1'

This precise hexadecimal representation can be used to reconstruct the
float value exactly:

     >>> x == float.fromhex('0x1.921f9f01b866ep+1')
     True

Since the representation is exact, it is useful for reliably porting
values across different versions of Python (platform independence) and
exchanging data with other languages that support the same format (such
as Java and C99).

Another helpful tool is the *note math.fsum(): 9b4. function which helps
mitigate loss-of-precision during summation.  It tracks "lost digits" as
values are added onto a running total.  That can make a difference in
overall accuracy so that the errors do not accumulate to the point where
they affect the final total:

     >>> sum([0.1] * 10) == 1.0
     False
     >>> math.fsum([0.1] * 10) == 1.0
     True

* Menu:

* Representation Error:: 

   ---------- Footnotes ----------

   (1) http://www.lahey.com/float.htm


File: python.info,  Node: Representation Error,  Up: Floating Point Arithmetic Issues and Limitations

2.15.1 Representation Error
---------------------------

This section explains the "0.1" example in detail, and shows how you can
perform an exact analysis of cases like this yourself.  Basic
familiarity with binary floating-point representation is assumed.

`Representation error' refers to the fact that some (most, actually)
decimal fractions cannot be represented exactly as binary (base 2)
fractions.  This is the chief reason why Python (or Perl, C, C++, Java,
Fortran, and many others) often won’t display the exact decimal number
you expect.

Why is that?  1/10 is not exactly representable as a binary fraction.
Almost all machines today (November 2000) use IEEE-754 floating point
arithmetic, and almost all platforms map Python floats to IEEE-754
"double precision".  754 doubles contain 53 bits of precision, so on
input the computer strives to convert 0.1 to the closest fraction it can
of the form `J'/2**`N' where `J' is an integer containing exactly 53
bits.  Rewriting

     1 / 10 ~= J / (2**N)

as

     J ~= 2**N / 10

and recalling that `J' has exactly 53 bits (is ‘>= 2**52’ but ‘<
2**53’), the best value for `N' is 56:

     >>> 2**52 <=  2**56 // 10  < 2**53
     True

That is, 56 is the only value for `N' that leaves `J' with exactly 53
bits.  The best possible value for `J' is then that quotient rounded:

     >>> q, r = divmod(2**56, 10)
     >>> r
     6

Since the remainder is more than half of 10, the best approximation is
obtained by rounding up:

     >>> q+1
     7205759403792794

Therefore the best possible approximation to 1/10 in 754 double
precision is:

     7205759403792794 / 2 ** 56

Dividing both the numerator and denominator by two reduces the fraction
to:

     3602879701896397 / 2 ** 55

Note that since we rounded up, this is actually a little bit larger than
1/10; if we had not rounded up, the quotient would have been a little
bit smaller than 1/10.  But in no case can it be `exactly' 1/10!

So the computer never "sees" 1/10: what it sees is the exact fraction
given above, the best 754 double approximation it can get:

     >>> 0.1 * 2 ** 55
     3602879701896397.0

If we multiply that fraction by 10**55, we can see the value out to 55
decimal digits:

     >>> 3602879701896397 * 10 ** 55 // 2 ** 55
     1000000000000000055511151231257827021181583404541015625

meaning that the exact number stored in the computer is equal to the
decimal value 0.1000000000000000055511151231257827021181583404541015625.
Instead of displaying the full decimal value, many languages (including
older versions of Python), round the result to 17 significant digits:

     >>> format(0.1, '.17f')
     '0.10000000000000001'

The *note fractions: 82. and *note decimal: 34. modules make these
calculations easy:

     >>> from decimal import Decimal
     >>> from fractions import Fraction

     >>> Fraction.from_float(0.1)
     Fraction(3602879701896397, 36028797018963968)

     >>> (0.1).as_integer_ratio()
     (3602879701896397, 36028797018963968)

     >>> Decimal.from_float(0.1)
     Decimal('0.1000000000000000055511151231257827021181583404541015625')

     >>> format(Decimal.from_float(0.1), '.17')
     '0.10000000000000001'


File: python.info,  Node: Appendix,  Prev: Floating Point Arithmetic Issues and Limitations,  Up: The Python Tutorial

2.16 Appendix
=============

* Menu:

* Interactive Mode: Interactive Mode<2>. 


File: python.info,  Node: Interactive Mode<2>,  Up: Appendix

2.16.1 Interactive Mode
-----------------------

* Menu:

* Error Handling:: 
* Executable Python Scripts:: 
* The Interactive Startup File:: 
* The Customization Modules:: 


File: python.info,  Node: Error Handling,  Next: Executable Python Scripts,  Up: Interactive Mode<2>

2.16.1.1 Error Handling
.......................

When an error occurs, the interpreter prints an error message and a
stack trace.  In interactive mode, it then returns to the primary
prompt; when input came from a file, it exits with a nonzero exit status
after printing the stack trace.  (Exceptions handled by an *note except:
785. clause in a *note try: 9e9. statement are not errors in this
context.)  Some errors are unconditionally fatal and cause an exit with
a nonzero exit; this applies to internal inconsistencies and some cases
of running out of memory.  All error messages are written to the
standard error stream; normal output from executed commands is written
to standard output.

Typing the interrupt character (usually ‘Control-C’ or ‘Delete’) to the
primary or secondary prompt cancels the input and returns to the primary
prompt.  (1) Typing an interrupt while a command is executing raises the
*note KeyboardInterrupt: 1a3. exception, which may be handled by a *note
try: 9e9. statement.

   ---------- Footnotes ----------

   (1) A problem with the GNU Readline package may prevent this.


File: python.info,  Node: Executable Python Scripts,  Next: The Interactive Startup File,  Prev: Error Handling,  Up: Interactive Mode<2>

2.16.1.2 Executable Python Scripts
..................................

On BSD’ish Unix systems, Python scripts can be made directly executable,
like shell scripts, by putting the line

     #!/usr/bin/env python3.5

(assuming that the interpreter is on the user’s ‘PATH’) at the beginning
of the script and giving the file an executable mode.  The ‘#!’ must be
the first two characters of the file.  On some platforms, this first
line must end with a Unix-style line ending (‘'\n'’), not a Windows
(‘'\r\n'’) line ending.  Note that the hash, or pound, character, ‘'#'’,
is used to start a comment in Python.

The script can be given an executable mode, or permission, using the
‘chmod’ command.

     $ chmod +x myscript.py

On Windows systems, there is no notion of an "executable mode".  The
Python installer automatically associates ‘.py’ files with ‘python.exe’
so that a double-click on a Python file will run it as a script.  The
extension can also be ‘.pyw’, in that case, the console window that
normally appears is suppressed.


File: python.info,  Node: The Interactive Startup File,  Next: The Customization Modules,  Prev: Executable Python Scripts,  Up: Interactive Mode<2>

2.16.1.3 The Interactive Startup File
.....................................

When you use Python interactively, it is frequently handy to have some
standard commands executed every time the interpreter is started.  You
can do this by setting an environment variable named *note
PYTHONSTARTUP: 4e6. to the name of a file containing your start-up
commands.  This is similar to the ‘.profile’ feature of the Unix shells.

This file is only read in interactive sessions, not when Python reads
commands from a script, and not when ‘/dev/tty’ is given as the explicit
source of commands (which otherwise behaves like an interactive
session).  It is executed in the same namespace where interactive
commands are executed, so that objects that it defines or imports can be
used without qualification in the interactive session.  You can also
change the prompts ‘sys.ps1’ and ‘sys.ps2’ in this file.

If you want to read an additional start-up file from the current
directory, you can program this in the global start-up file using code
like ‘if os.path.isfile('.pythonrc.py'):
exec(open('.pythonrc.py').read())’.  If you want to use the startup file
in a script, you must do this explicitly in the script:

     import os
     filename = os.environ.get('PYTHONSTARTUP')
     if filename and os.path.isfile(filename):
         with open(filename) as fobj:
            startup_file = fobj.read()
         exec(startup_file)


File: python.info,  Node: The Customization Modules,  Prev: The Interactive Startup File,  Up: Interactive Mode<2>

2.16.1.4 The Customization Modules
..................................

Python provides two hooks to let you customize it: ‘sitecustomize’ and
‘usercustomize’.  To see how it works, you need first to find the
location of your user site-packages directory.  Start Python and run
this code:

     >>> import site
     >>> site.getusersitepackages()
     '/home/user/.local/lib/python3.5/site-packages'

Now you can create a file named ‘usercustomize.py’ in that directory and
put anything you want in it.  It will affect every invocation of Python,
unless it is started with the *note -s: 986. option to disable the
automatic import.

‘sitecustomize’ works in the same way, but is typically created by an
administrator of the computer in the global site-packages directory, and
is imported before ‘usercustomize’.  See the documentation of the *note
site: e9. module for more details.


File: python.info,  Node: Python Setup and Usage,  Next: The Python Language Reference,  Prev: The Python Tutorial,  Up: Top

3 Python Setup and Usage
************************

This part of the documentation is devoted to general information on the
setup of the Python environment on different platform, the invocation of
the interpreter and things that make working with Python easier.

* Menu:

* Command line and environment:: 
* Using Python on Unix platforms:: 
* Using Python on Windows:: 
* Using Python on a Macintosh:: 
* Additional Tools and Scripts:: 


File: python.info,  Node: Command line and environment,  Next: Using Python on Unix platforms,  Up: Python Setup and Usage

3.1 Command line and environment
================================

The CPython interpreter scans the command line and the environment for
various settings.

`CPython implementation detail:' Other implementations’ command line
schemes may differ.  See *note Alternate Implementations: cf9. for
further resources.

* Menu:

* Command line:: 
* Environment variables:: 


File: python.info,  Node: Command line,  Next: Environment variables,  Up: Command line and environment

3.1.1 Command line
------------------

When invoking Python, you may specify any of these options:

     python [-bBdEhiIOqsSuvVWx?] [-c command | -m module-name | script | - ] [args]

The most common use case is, of course, a simple invocation of a script:

     python myscript.py

* Menu:

* Interface options:: 
* Generic options:: 
* Miscellaneous options:: 
* Options you shouldn't use:: 


File: python.info,  Node: Interface options,  Next: Generic options,  Up: Command line

3.1.1.1 Interface options
.........................

The interpreter interface resembles that of the UNIX shell, but provides
some additional methods of invocation:

   * When called with standard input connected to a tty device, it
     prompts for commands and executes them until an EOF (an end-of-file
     character, you can produce that with ‘Ctrl-D’ on UNIX or ‘Ctrl-Z,
     Enter’ on Windows) is read.

   * When called with a file name argument or with a file as standard
     input, it reads and executes a script from that file.

   * When called with a directory name argument, it reads and executes
     an appropriately named script from that directory.

   * When called with ‘-c command’, it executes the Python statement(s)
     given as `command'.  Here `command' may contain multiple statements
     separated by newlines.  Leading whitespace is significant in Python
     statements!

   * When called with ‘-m module-name’, the given module is located on
     the Python module path and executed as a script.

In non-interactive mode, the entire input is parsed before it is
executed.

An interface option terminates the list of options consumed by the
interpreter, all consecutive arguments will end up in *note sys.argv:
85c. – note that the first element, subscript zero (‘sys.argv[0]’), is a
string reflecting the program’s source.

 -- Program Option: -c <command>

     Execute the Python code in `command'.  `command' can be one or more
     statements separated by newlines, with significant leading
     whitespace as in normal module code.

     If this option is given, the first element of *note sys.argv: 85c.
     will be ‘"-c"’ and the current directory will be added to the start
     of *note sys.path: 16c. (allowing modules in that directory to be
     imported as top level modules).

 -- Program Option: -m <module-name>

     Search *note sys.path: 16c. for the named module and execute its
     contents as the *note __main__: 1. module.

     Since the argument is a `module' name, you must not give a file
     extension (‘.py’).  The module name should be a valid absolute
     Python module name, but the implementation may not always enforce
     this (e.g.  it may allow you to use a name that includes a hyphen).

     Package names (including namespace packages) are also permitted.
     When a package name is supplied instead of a normal module, the
     interpreter will execute ‘<pkg>.__main__’ as the main module.  This
     behaviour is deliberately similar to the handling of directories
     and zipfiles that are passed to the interpreter as the script
     argument.

          Note: This option cannot be used with built-in modules and
          extension modules written in C, since they do not have Python
          module files.  However, it can still be used for precompiled
          modules, even if the original source file is not available.

     If this option is given, the first element of *note sys.argv: 85c.
     will be the full path to the module file (while the module file is
     being located, the first element will be set to ‘"-m"’).  As with
     the *note -c: bd2. option, the current directory will be added to
     the start of *note sys.path: 16c.

     Many standard library modules contain code that is invoked on their
     execution as a script.  An example is the *note timeit: 108.
     module:

          python -mtimeit -s 'setup here' 'benchmarked code here'
          python -mtimeit -h # for details

     See also
     ........

     *note runpy.run_module(): cfd.

          Equivalent functionality directly available to Python code

     PEP 338(1) – Executing modules as scripts

     Changed in version 3.1: Supply the package name to run a ‘__main__’
     submodule.

     Changed in version 3.4: namespace packages are also supported

 -- Describe: -

     Read commands from standard input (*note sys.stdin: 1b9.).  If
     standard input is a terminal, *note -i: aa1. is implied.

     If this option is given, the first element of *note sys.argv: 85c.
     will be ‘"-"’ and the current directory will be added to the start
     of *note sys.path: 16c.

 -- Describe: <script>

     Execute the Python code contained in `script', which must be a
     filesystem path (absolute or relative) referring to either a Python
     file, a directory containing a ‘__main__.py’ file, or a zipfile
     containing a ‘__main__.py’ file.

     If this option is given, the first element of *note sys.argv: 85c.
     will be the script name as given on the command line.

     If the script name refers directly to a Python file, the directory
     containing that file is added to the start of *note sys.path: 16c,
     and the file is executed as the *note __main__: 1. module.

     If the script name refers to a directory or zipfile, the script
     name is added to the start of *note sys.path: 16c. and the
     ‘__main__.py’ file in that location is executed as the *note
     __main__: 1. module.

     See also
     ........

     *note runpy.run_path(): 925.

          Equivalent functionality directly available to Python code

If no interface option is given, *note -i: aa1. is implied,
‘sys.argv[0]’ is an empty string (‘""’) and the current directory will
be added to the start of *note sys.path: 16c.  Also, tab-completion and
history editing is automatically enabled, if available on your platform
(see *note Readline configuration: 4e7.).

See also
........

*note Invoking the Interpreter: bcf.

Changed in version 3.4: Automatic enabling of tab-completion and history
editing.

   ---------- Footnotes ----------

   (1) https://www.python.org/dev/peps/pep-0338


File: python.info,  Node: Generic options,  Next: Miscellaneous options,  Prev: Interface options,  Up: Command line

3.1.1.2 Generic options
.......................

 -- Program Option: -?
 -- Program Option: -h
 -- Program Option: --help

     Print a short description of all command line options.

 -- Program Option: -V
 -- Program Option: --version

     Print the Python version number and exit.  Example output could be:

          Python 3.0


File: python.info,  Node: Miscellaneous options,  Next: Options you shouldn't use,  Prev: Generic options,  Up: Command line

3.1.1.3 Miscellaneous options
.............................

 -- Program Option: -b

     Issue a warning when comparing *note bytes: 1db. or *note
     bytearray: 1dc. with *note str: 25a. or *note bytes: 1db. with
     *note int: 227.  Issue an error when the option is given twice
     (‘-bb’).

     Changed in version 3.5: Affects comparisons of *note bytes: 1db.
     with *note int: 227.

 -- Program Option: -B

     If given, Python won’t try to write ‘.pyc’ files on the import of
     source modules.  See also *note PYTHONDONTWRITEBYTECODE: 9ae.

 -- Program Option: -d

     Turn on parser debugging output (for wizards only, depending on
     compilation options).  See also *note PYTHONDEBUG: d02.

 -- Program Option: -E

     Ignore all ‘PYTHON*’ environment variables, e.g.  *note PYTHONPATH:
     567. and *note PYTHONHOME: d04, that might be set.

 -- Program Option: -i

     When a script is passed as first argument or the *note -c: bd2.
     option is used, enter interactive mode after executing the script
     or the command, even when *note sys.stdin: 1b9. does not appear to
     be a terminal.  The *note PYTHONSTARTUP: 4e6. file is not read.

     This can be useful to inspect global variables or a stack trace
     when a script raises an exception.  See also *note PYTHONINSPECT:
     aa0.

 -- Program Option: -I

     Run Python in isolated mode.  This also implies -E and -s.  In
     isolated mode *note sys.path: 16c. contains neither the script’s
     directory nor the user’s site-packages directory.  All ‘PYTHON*’
     environment variables are ignored, too.  Further restrictions may
     be imposed to prevent the user from injecting malicious code.

     New in version 3.4.

 -- Program Option: -O

     Turn on basic optimizations.  This changes the filename extension
     for compiled (*note bytecode: d06.) files from ‘.pyc’ to ‘.pyo’.
     See also *note PYTHONOPTIMIZE: d07.

 -- Program Option: -OO

     Discard docstrings in addition to the *note -O: 221. optimizations.

 -- Program Option: -q

     Don’t display the copyright and version messages even in
     interactive mode.

     New in version 3.2.

 -- Program Option: -R

     Kept for compatibility.  On Python 3.3 and greater, hash
     randomization is turned on by default.

     On previous versions of Python, this option turns on hash
     randomization, so that the *note __hash__(): 5e7. values of str,
     bytes and datetime are "salted" with an unpredictable random value.
     Although they remain constant within an individual Python process,
     they are not predictable between repeated invocations of Python.

     Hash randomization is intended to provide protection against a
     denial-of-service caused by carefully-chosen inputs that exploit
     the worst case performance of a dict construction, O(n^2)
     complexity.  See
     ‘http://www.ocert.org/advisories/ocert-2011-003.html’ for details.

     *note PYTHONHASHSEED: 5e8. allows you to set a fixed value for the
     hash seed secret.

     New in version 3.2.3.

 -- Program Option: -s

     Don’t add the *note user site-packages directory: d0a. to *note
     sys.path: 16c.

     See also
     ........

     PEP 370(1) – Per user site-packages directory

 -- Program Option: -S

     Disable the import of the module *note site: e9. and the
     site-dependent manipulations of *note sys.path: 16c. that it
     entails.  Also disable these manipulations if *note site: e9. is
     explicitly imported later (call *note site.main(): d0b. if you want
     them to be triggered).

 -- Program Option: -u

     Force the binary layer of the stdout and stderr streams (which is
     available as their ‘buffer’ attribute) to be unbuffered.  The text
     I/O layer will still be line-buffered if writing to the console, or
     block-buffered if redirected to a non-interactive file.

     See also *note PYTHONUNBUFFERED: d0d.

 -- Program Option: -v

     Print a message each time a module is initialized, showing the
     place (filename or built-in module) from which it is loaded.  When
     given twice (‘-vv’), print a message for each file that is checked
     for when searching for a module.  Also provides information on
     module cleanup at exit.  See also *note PYTHONVERBOSE: d0e.

 -- Program Option: -W arg

     Warning control.  Python’s warning machinery by default prints
     warning messages to *note sys.stderr: 270.  A typical warning
     message has the following form:

          file:line: category: message

     By default, each warning is printed once for each source line where
     it occurs.  This option controls how often warnings are printed.

     Multiple *note -W: 8eb. options may be given; when a warning
     matches more than one option, the action for the last matching
     option is performed.  Invalid *note -W: 8eb. options are ignored
     (though, a warning message is printed about invalid options when
     the first warning is issued).

     Warnings can also be controlled from within a Python program using
     the *note warnings: 123. module.

     The simplest form of argument is one of the following action
     strings (or a unique abbreviation):

     ‘ignore’

          Ignore all warnings.

     ‘default’

          Explicitly request the default behavior (printing each warning
          once per source line).

     ‘all’

          Print a warning each time it occurs (this may generate many
          messages if a warning is triggered repeatedly for the same
          source line, such as inside a loop).

     ‘module’

          Print each warning only the first time it occurs in each
          module.

     ‘once’

          Print each warning only the first time it occurs in the
          program.

     ‘error’

          Raise an exception instead of printing a warning message.

     The full form of argument is:

          action:message:category:module:line

     Here, `action' is as explained above but only applies to messages
     that match the remaining fields.  Empty fields match all values;
     trailing empty fields may be omitted.  The `message' field matches
     the start of the warning message printed; this match is
     case-insensitive.  The `category' field matches the warning
     category.  This must be a class name; the match tests whether the
     actual warning category of the message is a subclass of the
     specified warning category.  The full class name must be given.
     The `module' field matches the (fully-qualified) module name; this
     match is case-sensitive.  The `line' field matches the line number,
     where zero matches all line numbers and is thus equivalent to an
     omitted line number.

     See also
     ........

     *note warnings: 123. – the warnings module

     PEP 230(2) – Warning framework

     *note PYTHONWARNINGS: 788.

 -- Program Option: -x

     Skip the first line of the source, allowing use of non-Unix forms
     of ‘#!cmd’.  This is intended for a DOS specific hack only.

          Note: The line numbers in error messages will be off by one.

 -- Program Option: -X

     Reserved for various implementation-specific options.  CPython
     currently defines the following possible values:

        * ‘-X faulthandler’ to enable *note faulthandler: 7b.;

        * ‘-X showrefcount’ to enable the output of the total reference
          count and memory blocks (only works on debug builds);

        * ‘-X tracemalloc’ to start tracing Python memory allocations
          using the *note tracemalloc: 111. module.  By default, only
          the most recent frame is stored in a traceback of a trace.
          Use ‘-X tracemalloc=NFRAME’ to start tracing with a traceback
          limit of `NFRAME' frames.  See the *note tracemalloc.start():
          d10. for more information.

     It also allows passing arbitrary values and retrieving them through
     the *note sys._xoptions: d11. dictionary.

     Changed in version 3.2: It is now allowed to pass *note -X: 5ec.
     with CPython.

     New in version 3.3: The ‘-X faulthandler’ option.

     New in version 3.4: The ‘-X showrefcount’ and ‘-X tracemalloc’
     options.

   ---------- Footnotes ----------

   (1) https://www.python.org/dev/peps/pep-0370

   (2) https://www.python.org/dev/peps/pep-0230


File: python.info,  Node: Options you shouldn't use,  Prev: Miscellaneous options,  Up: Command line

3.1.1.4 Options you shouldn’t use
.................................

 -- Program Option: -J

     Reserved for use by Jython(1).

   ---------- Footnotes ----------

   (1) http://www.jython.org/


File: python.info,  Node: Environment variables,  Prev: Command line,  Up: Command line and environment

3.1.2 Environment variables
---------------------------

These environment variables influence Python’s behavior, they are
processed before the command-line switches other than -E or -I. It is
customary that command-line switches override environmental variables
where there is a conflict.

 -- Environment Variable: PYTHONHOME

     Change the location of the standard Python libraries.  By default,
     the libraries are searched in ‘`prefix'/lib/python`version'’ and
     ‘`exec_prefix'/lib/python`version'’, where ‘`prefix'’ and
     ‘`exec_prefix'’ are installation-dependent directories, both
     defaulting to ‘/usr/local’.

     When *note PYTHONHOME: d04. is set to a single directory, its value
     replaces both ‘`prefix'’ and ‘`exec_prefix'’.  To specify different
     values for these, set *note PYTHONHOME: d04. to
     ‘`prefix':`exec_prefix'’.

 -- Environment Variable: PYTHONPATH

     Augment the default search path for module files.  The format is
     the same as the shell’s ‘PATH’: one or more directory pathnames
     separated by *note os.pathsep: d15. (e.g.  colons on Unix or
     semicolons on Windows).  Non-existent directories are silently
     ignored.

     In addition to normal directories, individual *note PYTHONPATH:
     567. entries may refer to zipfiles containing pure Python modules
     (in either source or compiled form).  Extension modules cannot be
     imported from zipfiles.

     The default search path is installation dependent, but generally
     begins with ‘`prefix'/lib/python`version'’ (see *note PYTHONHOME:
     d04. above).  It is `always' appended to *note PYTHONPATH: 567.

     An additional directory will be inserted in the search path in
     front of *note PYTHONPATH: 567. as described above under *note
     Interface options: cfc.  The search path can be manipulated from
     within a Python program as the variable *note sys.path: 16c.

 -- Environment Variable: PYTHONSTARTUP

     If this is the name of a readable file, the Python commands in that
     file are executed before the first prompt is displayed in
     interactive mode.  The file is executed in the same namespace where
     interactive commands are executed so that objects defined or
     imported in it can be used without qualification in the interactive
     session.  You can also change the prompts *note sys.ps1: d16. and
     *note sys.ps2: d17. and the hook *note sys.__interactivehook__:
     4e5. in this file.

 -- Environment Variable: PYTHONOPTIMIZE

     If this is set to a non-empty string it is equivalent to specifying
     the *note -O: 221. option.  If set to an integer, it is equivalent
     to specifying *note -O: 221. multiple times.

 -- Environment Variable: PYTHONDEBUG

     If this is set to a non-empty string it is equivalent to specifying
     the *note -d: d01. option.  If set to an integer, it is equivalent
     to specifying *note -d: d01. multiple times.

 -- Environment Variable: PYTHONINSPECT

     If this is set to a non-empty string it is equivalent to specifying
     the *note -i: aa1. option.

     This variable can also be modified by Python code using *note
     os.environ: 77a. to force inspect mode on program termination.

 -- Environment Variable: PYTHONUNBUFFERED

     If this is set to a non-empty string it is equivalent to specifying
     the *note -u: d0c. option.

 -- Environment Variable: PYTHONVERBOSE

     If this is set to a non-empty string it is equivalent to specifying
     the *note -v: a02. option.  If set to an integer, it is equivalent
     to specifying *note -v: a02. multiple times.

 -- Environment Variable: PYTHONCASEOK

     If this is set, Python ignores case in *note import: 881.
     statements.  This only works on Windows and OS X.

 -- Environment Variable: PYTHONDONTWRITEBYTECODE

     If this is set to a non-empty string, Python won’t try to write
     ‘.pyc’ or ‘.pyo’ files on the import of source modules.  This is
     equivalent to specifying the *note -B: 9ad. option.

 -- Environment Variable: PYTHONHASHSEED

     If this variable is not set or set to ‘random’, a random value is
     used to seed the hashes of str, bytes and datetime objects.

     If *note PYTHONHASHSEED: 5e8. is set to an integer value, it is
     used as a fixed seed for generating the hash() of the types covered
     by the hash randomization.

     Its purpose is to allow repeatable hashing, such as for selftests
     for the interpreter itself, or to allow a cluster of python
     processes to share hash values.

     The integer must be a decimal number in the range [0,4294967295].
     Specifying the value 0 will disable hash randomization.

     New in version 3.2.3.

 -- Environment Variable: PYTHONIOENCODING

     If this is set before running the interpreter, it overrides the
     encoding used for stdin/stdout/stderr, in the syntax
     ‘encodingname:errorhandler’.  Both the ‘encodingname’ and the
     ‘:errorhandler’ parts are optional and have the same meaning as in
     *note str.encode(): 89d.

     For stderr, the ‘:errorhandler’ part is ignored; the handler will
     always be ‘'backslashreplace'’.

     Changed in version 3.4: The ‘encodingname’ part is now optional.

 -- Environment Variable: PYTHONNOUSERSITE

     If this is set, Python won’t add the *note user site-packages
     directory: d0a. to *note sys.path: 16c.

     See also
     ........

     PEP 370(1) – Per user site-packages directory

 -- Environment Variable: PYTHONUSERBASE

     Defines the *note user base directory: d18, which is used to
     compute the path of the *note user site-packages directory: d0a.
     and *note Distutils installation paths: d19. for ‘python setup.py
     install --user’.

     See also
     ........

     PEP 370(2) – Per user site-packages directory

 -- Environment Variable: PYTHONEXECUTABLE

     If this environment variable is set, ‘sys.argv[0]’ will be set to
     its value instead of the value got through the C runtime.  Only
     works on Mac OS X.

 -- Environment Variable: PYTHONWARNINGS

     This is equivalent to the *note -W: 8eb. option.  If set to a comma
     separated string, it is equivalent to specifying *note -W: 8eb.
     multiple times.

 -- Environment Variable: PYTHONFAULTHANDLER

     If this environment variable is set to a non-empty string, *note
     faulthandler.enable(): 161. is called at startup: install a handler
     for ‘SIGSEGV’, ‘SIGFPE’, ‘SIGABRT’, ‘SIGBUS’ and ‘SIGILL’ signals
     to dump the Python traceback.  This is equivalent to *note -X: 5ec.
     ‘faulthandler’ option.

     New in version 3.3.

 -- Environment Variable: PYTHONTRACEMALLOC

     If this environment variable is set to a non-empty string, start
     tracing Python memory allocations using the *note tracemalloc: 111.
     module.  The value of the variable is the maximum number of frames
     stored in a traceback of a trace.  For example,
     ‘PYTHONTRACEMALLOC=1’ stores only the most recent frame.  See the
     *note tracemalloc.start(): d10. for more information.

     New in version 3.4.

 -- Environment Variable: PYTHONASYNCIODEBUG

     If this environment variable is set to a non-empty string, enable
     the *note debug mode: d1d. of the *note asyncio: a. module.

     New in version 3.4.

 -- Environment Variable: PYTHONMALLOC

     Set the Python memory allocators and/or install debug hooks.

     Set the family of memory allocators used by Python:

        * ‘malloc’: use the ‘malloc()’ function of the C library for all
          domains (*note PYMEM_DOMAIN_RAW: d1e, *note PYMEM_DOMAIN_MEM:
          155, *note PYMEM_DOMAIN_OBJ: 154.).

        * ‘pymalloc’: use the *note pymalloc allocator: 183. for *note
          PYMEM_DOMAIN_MEM: 155. and *note PYMEM_DOMAIN_OBJ: 154.
          domains and use the ‘malloc()’ function for the *note
          PYMEM_DOMAIN_RAW: d1e. domain.

     Install debug hooks:

        * ‘debug’: install debug hooks on top of the default memory
          allocator

        * ‘malloc_debug’: same as ‘malloc’ but also install debug hooks

        * ‘pymalloc_debug’: same as ‘pymalloc’ but also install debug
          hooks

     When Python is compiled in release mode, the default is ‘pymalloc’.
     When compiled in debug mode, the default is ‘pymalloc_debug’ and
     the debug hooks are used automatically.

     If Python is configured without ‘pymalloc’ support, ‘pymalloc’ and
     ‘pymalloc_debug’ are not available, the default is ‘malloc’ in
     release mode and ‘malloc_debug’ in debug mode.

     See the *note PyMem_SetupDebugHooks(): 156. function for debug
     hooks on Python memory allocators.

     New in version 3.6.

 -- Environment Variable: PYTHONMALLOCSTATS

     If set to a non-empty string, Python will print statistics of the
     *note pymalloc memory allocator: 183. every time a new pymalloc
     object arena is created, and on shutdown.

     This variable is ignored if the *note PYTHONMALLOC: 151.
     environment variable is used to force the ‘malloc()’ allocator of
     the C library, or if Python is configured without ‘pymalloc’
     support.

     Changed in version 3.6: This variable can now also be used on
     Python compiled in release mode.  It now has no effect if set to an
     empty string.

* Menu:

* Debug-mode variables:: 

   ---------- Footnotes ----------

   (1) https://www.python.org/dev/peps/pep-0370

   (2) https://www.python.org/dev/peps/pep-0370


File: python.info,  Node: Debug-mode variables,  Up: Environment variables

3.1.2.1 Debug-mode variables
............................

Setting these variables only has an effect in a debug build of Python,
that is, if Python was configured with the ‘--with-pydebug’ build
option.

 -- Environment Variable: PYTHONTHREADDEBUG

     If set, Python will print threading debug info.

 -- Environment Variable: PYTHONDUMPREFS

     If set, Python will dump objects and reference counts still alive
     after shutting down the interpreter.


File: python.info,  Node: Using Python on Unix platforms,  Next: Using Python on Windows,  Prev: Command line and environment,  Up: Python Setup and Usage

3.2 Using Python on Unix platforms
==================================

* Menu:

* Getting and installing the latest version of Python:: 
* Building Python:: 
* Python-related paths and files:: 
* Miscellaneous:: 
* Editors:: 


File: python.info,  Node: Getting and installing the latest version of Python,  Next: Building Python,  Up: Using Python on Unix platforms

3.2.1 Getting and installing the latest version of Python
---------------------------------------------------------

* Menu:

* On Linux:: 
* On FreeBSD and OpenBSD:: 
* On OpenSolaris:: 


File: python.info,  Node: On Linux,  Next: On FreeBSD and OpenBSD,  Up: Getting and installing the latest version of Python

3.2.1.1 On Linux
................

Python comes preinstalled on most Linux distributions, and is available
as a package on all others.  However there are certain features you
might want to use that are not available on your distro’s package.  You
can easily compile the latest version of Python from source.

In the event that Python doesn’t come preinstalled and isn’t in the
repositories as well, you can easily make packages for your own distro.
Have a look at the following links:

See also
........

‘https://www.debian.org/doc/manuals/maint-guide/first.en.html’

     for Debian users

‘https://en.opensuse.org/Portal:Packaging’

     for OpenSuse users

‘https://docs.fedoraproject.org/en-US/Fedora_Draft_Documentation/0.1/html/RPM_Guide/ch-creating-rpms.html’

     for Fedora users

‘http://www.slackbook.org/html/package-management-making-packages.html’

     for Slackware users


File: python.info,  Node: On FreeBSD and OpenBSD,  Next: On OpenSolaris,  Prev: On Linux,  Up: Getting and installing the latest version of Python

3.2.1.2 On FreeBSD and OpenBSD
..............................

   * FreeBSD users, to add the package use:

          pkg_add -r python

   * OpenBSD users use:

          pkg_add ftp://ftp.openbsd.org/pub/OpenBSD/4.2/packages/<insert your architecture here>/python-<version>.tgz

     For example i386 users get the 2.5.1 version of Python using:

          pkg_add ftp://ftp.openbsd.org/pub/OpenBSD/4.2/packages/i386/python-2.5.1p2.tgz


File: python.info,  Node: On OpenSolaris,  Prev: On FreeBSD and OpenBSD,  Up: Getting and installing the latest version of Python

3.2.1.3 On OpenSolaris
......................

You can get Python from OpenCSW(1). Various versions of Python are
available and can be installed with e.g.  ‘pkgutil -i python27’.

   ---------- Footnotes ----------

   (1) http://www.opencsw.org/


File: python.info,  Node: Building Python,  Next: Python-related paths and files,  Prev: Getting and installing the latest version of Python,  Up: Using Python on Unix platforms

3.2.2 Building Python
---------------------

If you want to compile CPython yourself, first thing you should do is
get the source(1).  You can download either the latest release’s source
or just grab a fresh clone(2).  (If you want to contribute patches, you
will need a clone.)

The build process consists in the usual

     ./configure
     make
     make install

invocations.  Configuration options and caveats for specific Unix
platforms are extensively documented in the README(3) file in the root
of the Python source tree.

     Warning: ‘make install’ can overwrite or masquerade the ‘python3’
     binary.  ‘make altinstall’ is therefore recommended instead of
     ‘make install’ since it only installs
     ‘`exec_prefix'/bin/python`version'’.

   ---------- Footnotes ----------

   (1) https://www.python.org/downloads/source/

   (2) 
https://docs.python.org/devguide/setup.html#getting-the-source-code

   (3) https://hg.python.org/cpython/file/default/README


File: python.info,  Node: Python-related paths and files,  Next: Miscellaneous,  Prev: Building Python,  Up: Using Python on Unix platforms

3.2.3 Python-related paths and files
------------------------------------

These are subject to difference depending on local installation
conventions; ‘prefix’ (‘${prefix}’) and ‘exec_prefix’ (‘${exec_prefix}’)
are installation-dependent and should be interpreted as for GNU
software; they may be the same.

For example, on most Linux systems, the default for both is ‘/usr’.

File/directory                                      Meaning
                                                    
---------------------------------------------------------------------------------------------------
                                                    
‘`exec_prefix'/bin/python3’                         Recommended location of the interpreter.
                                                    
                                                    
‘`prefix'/lib/python`version'’,                     Recommended locations of the directories
‘`exec_prefix'/lib/python`version'’                 containing the standard modules.
                                                    
                                                    
‘`prefix'/include/python`version'’,                 Recommended locations of the directories
‘`exec_prefix'/include/python`version'’             containing the include files needed for
                                                    developing Python extensions and embedding
                                                    the interpreter.
                                                    


File: python.info,  Node: Miscellaneous,  Next: Editors,  Prev: Python-related paths and files,  Up: Using Python on Unix platforms

3.2.4 Miscellaneous
-------------------

To easily use Python scripts on Unix, you need to make them executable,
e.g.  with

     $ chmod +x script

and put an appropriate Shebang line at the top of the script.  A good
choice is usually

     #!/usr/bin/env python3

which searches for the Python interpreter in the whole ‘PATH’.  However,
some Unices may not have the ‘env’ command, so you may need to hardcode
‘/usr/bin/python3’ as the interpreter path.

To use shell commands in your Python scripts, look at the *note
subprocess: f7. module.


File: python.info,  Node: Editors,  Prev: Miscellaneous,  Up: Using Python on Unix platforms

3.2.5 Editors
-------------

Vim and Emacs are excellent editors which support Python very well.  For
more information on how to code in Python in these editors, look at:

   * ‘http://www.vim.org/scripts/script.php?script_id=790’

   * ‘http://sourceforge.net/projects/python-mode’

Geany is an excellent IDE with support for a lot of languages.  For more
information, read: ‘http://www.geany.org/’

Komodo edit is another extremely good IDE. It also has support for a lot
of languages.  For more information, read ‘http://komodoide.com/’.


File: python.info,  Node: Using Python on Windows,  Next: Using Python on a Macintosh,  Prev: Using Python on Unix platforms,  Up: Python Setup and Usage

3.3 Using Python on Windows
===========================

This document aims to give an overview of Windows-specific behaviour you
should know about when using Python on Microsoft Windows.

* Menu:

* Installing Python:: 
* Alternative bundles:: 
* Configuring Python:: 
* Python Launcher for Windows:: 
* Finding modules:: 
* Additional modules:: 
* Compiling Python on Windows:: 
* Embedded Distribution:: 
* Other resources:: 


File: python.info,  Node: Installing Python,  Next: Alternative bundles,  Up: Using Python on Windows

3.3.1 Installing Python
-----------------------

Unlike most Unix systems and services, Windows does not include a system
supported installation of Python.  To make Python available, the CPython
team has compiled Windows installers (MSI packages) with every
release(1) for many years.  These installers are primarily intended to
add a per-user installation of Python, with the core interpreter and
library being used by a single user.  The installer is also able to
install for all users of a single machine, and a separate ZIP file is
available for application-local distributions.

* Menu:

* Supported Versions:: 
* Installation Steps:: 
* Installing Without UI:: 
* Installing Without Downloading:: 
* Modifying an install:: 
* Other Platforms:: 

   ---------- Footnotes ----------

   (1) https://www.python.org/download/releases/


File: python.info,  Node: Supported Versions,  Next: Installation Steps,  Up: Installing Python

3.3.1.1 Supported Versions
..........................

As specified in PEP 11(1), a Python release only supports a Windows
platform while Microsoft considers the platform under extended support.
This means that Python 3.5 supports Windows Vista and newer.  If you
require Windows XP support then please install Python 3.4.

   ---------- Footnotes ----------

   (1) https://www.python.org/dev/peps/pep-0011


File: python.info,  Node: Installation Steps,  Next: Installing Without UI,  Prev: Supported Versions,  Up: Installing Python

3.3.1.2 Installation Steps
..........................

Four Python 3.5 installers are available for download - two each for the
32-bit and 64-bit versions of the interpreter.  The `web installer' is a
small initial download, and it will automatically download the required
components as necessary.  The `offline installer' includes the
components necessary for a default installation and only requires an
internet connection for optional features.  See *note Installing Without
Downloading: d32. for other ways to avoid downloading during
installation.

After starting the installer, one of two options may be selected:

 [image src="win_installer.png" ]

If you select "Install Now":

   * You will `not' need to be an administrator (unless a system update
     for the C Runtime Library is required or you install the *note
     Python Launcher for Windows: 5ad. for all users)

   * Python will be installed into your user directory

   * The *note Python Launcher for Windows: 5ad. will be installed
     according to the option at the bottom of the first pace

   * The standard library, test suite, launcher and pip will be
     installed

   * If selected, the install directory will be added to your ‘PATH’

   * Shortcuts will only be visible for the current user

Selecting "Customize installation" will allow you to select the features
to install, the installation location and other options or post-install
actions.  To install debugging symbols or binaries, you will need to use
this option.

To perform an all-users installation, you should select "Customize
installation".  In this case:

   * You may be required to provide administrative credentials or
     approval

   * Python will be installed into the Program Files directory

   * The *note Python Launcher for Windows: 5ad. will be installed into
     the Windows directory

   * Optional features may be selected during installation

   * The standard library can be pre-compiled to bytecode

   * If selected, the install directory will be added to the system
     ‘PATH’

   * Shortcuts are available for all users


File: python.info,  Node: Installing Without UI,  Next: Installing Without Downloading,  Prev: Installation Steps,  Up: Installing Python

3.3.1.3 Installing Without UI
.............................

All of the options available in the installer UI can also be specified
from the command line, allowing scripted installers to replicate an
installation on many machines without user interaction.  These options
may also be set without suppressing the UI in order to change some of
the defaults.

To completely hide the installer UI and install Python silently, pass
the ‘/quiet’ option.  To skip past the user interaction but still
display progress and errors, pass the ‘/passive’ option.  The
‘/uninstall’ option may be passed to immediately begin removing Python -
no prompt will be displayed.

All other options are passed as ‘name=value’, where the value is usually
‘0’ to disable a feature, ‘1’ to enable a feature, or a path.  The full
list of available options is shown below.

Name                            Description                                Default
                                                                           
----------------------------------------------------------------------------------------------------------
                                                                           
InstallAllUsers                 Perform a system-wide installation.        0
                                                                           
                                                                           
TargetDir                       The installation directory                 Selected based on
                                                                           InstallAllUsers
                                                                           
                                                                           
DefaultAllUsersTargetDir        The default installation directory for     ‘%ProgramFiles%\Python X.Y’
                                all-user installs                          or
                                                                           ‘%ProgramFiles(x86)%\Python
                                                                           X.Y’
                                                                           
                                                                           
DefaultJustForMeTargetDir       The default install directory for          ‘%LocalAppData%\Programs\PythonXY’
                                just-for-me installs                       or
                                                                           ‘%LocalAppData%\Programs\PythonXY-32’
                                                                           
                                                                           
DefaultCustomTargetDir          The default custom install directory       (empty)
                                displayed in the UI                        
                                
                                                                           
AssociateFiles                  Create file associations if the launcher   1
                                is also installed.                         
                                
                                                                           
CompileAll                      Compile all ‘.py’ files to ‘.pyc’.         0
                                                                           
                                                                           
PrependPath                     Add install and Scripts directories tho    0
                                ‘PATH’ and ‘.PY’ to ‘PATHEXT’              
                                
                                                                           
Shortcuts                       Create shortcuts for the interpreter,      1
                                documentation and IDLE if installed.       
                                
                                                                           
Include_doc                     Install Python manual                      1
                                                                           
                                                                           
Include_debug                   Install debug binaries                     0
                                                                           
                                                                           
Include_dev                     Install developer headers and libraries    1
                                                                           
                                                                           
Include_exe                     Install ‘python.exe’ and related files     1
                                                                           
                                                                           
Include_launcher                Install                                    1
                                *note Python Launcher for Windows: 5ad.    
                                
                                                                           
InstallLauncherAllUsers         Installs                                   1
                                *note Python Launcher for Windows: 5ad.    
                                for all users.
                                
                                                                           
Include_lib                     Install standard library and extension     1
                                modules                                    
                                
                                                                           
Include_pip                     Install bundled pip and setuptools         1
                                                                           
                                                                           
Include_symbols                 Install debugging symbols (‘*’.pdb)        0
                                                                           
                                                                           
Include_tcltk                   Install Tcl/Tk support and IDLE            1
                                                                           
                                                                           
Include_test                    Install standard library test suite        1
                                                                           
                                                                           
Include_tools                   Install utility scripts                    1
                                                                           
                                                                           
LauncherOnly                    Only installs the launcher.  This will     0
                                override most other options.               
                                
                                                                           
SimpleInstall                   Disable most install UI                    0
                                                                           
                                                                           
SimpleInstallDescription        A custom message to display when the       (empty)
                                simplified install UI is used.             
                                

For example, to silently install a default, system-wide Python
installation, you could use the following command (from an elevated
command prompt):

     python-3.5.0.exe /quiet InstallAllUsers=1 PrependPath=1 Include_test=0

To allow users to easily install a personal copy of Python without the
test suite, you could provide a shortcut with the following command.
This will display a simplified initial page and disallow customization:

     python-3.5.0.exe InstallAllUsers=0 Include_launcher=0 Include_test=0
         SimpleInstall=1 SimpleInstallDescription="Just for me, no test suite."

(Note that omitting the launcher also omits file associations, and is
only recommended for per-user installs when there is also a system-wide
installation that included the launcher.)

The options listed above can also be provided in a file named
‘unattend.xml’ alongside the executable.  This file specifies a list of
options and values.  When a value is provided as an attribute, it will
be converted to a number if possible.  Values provided as element text
are always left as strings.  This example file sets the same options and
the previous example:

     <Options>
         <Option Name="InstallAllUsers" Value="no" />
         <Option Name="Include_launcher" Value="0" />
         <Option Name="Include_test" Value="no" />
         <Option Name="SimpleInstall" Value="yes" />
         <Option Name="SimpleInstallDescription">Just for me, no test suite</Option>
     </Options>


File: python.info,  Node: Installing Without Downloading,  Next: Modifying an install,  Prev: Installing Without UI,  Up: Installing Python

3.3.1.4 Installing Without Downloading
......................................

As some features of Python are not included in the initial installer
download, selecting those features may require an internet connection.
To avoid this need, all possible components may be downloaded on-demand
to create a complete `layout' that will no longer require an internet
connection regardless of the selected features.  Note that this download
may be bigger than required, but where a large number of installations
are going to be performed it is very useful to have a locally cached
copy.

Execute the following command from Command Prompt to download all
possible required files.  Remember to substitute ‘python-3.5.0.exe’ for
the actual name of your installer, and to create layouts in their own
directories to avoid collisions between files with the same name.

     python-3.5.0.exe /layout [optional target directory]

You may also specify the ‘/quiet’ option to hide the progress display.


File: python.info,  Node: Modifying an install,  Next: Other Platforms,  Prev: Installing Without Downloading,  Up: Installing Python

3.3.1.5 Modifying an install
............................

Once Python has been installed, you can add or remove features through
the Programs and Features tool that is part of Windows.  Select the
Python entry and choose "Uninstall/Change" to open the installer in
maintenance mode.

"Modify" allows you to add or remove features by modifying the
checkboxes - unchanged checkboxes will not install or remove anything.
Some options cannot be changed in this mode, such as the install
directory; to modify these, you will need to remove and then reinstall
Python completely.

"Repair" will verify all the files that should be installed using the
current settings and replace any that have been removed or modified.

"Uninstall" will remove Python entirely, with the exception of the *note
Python Launcher for Windows: 5ad, which has its own entry in Programs
and Features.


File: python.info,  Node: Other Platforms,  Prev: Modifying an install,  Up: Installing Python

3.3.1.6 Other Platforms
.......................

With ongoing development of Python, some platforms that used to be
supported earlier are no longer supported (due to the lack of users or
developers).  Check PEP 11(1) for details on all unsupported platforms.

   * Windows CE(2) is still supported.

   * The Cygwin(3) installer offers to install the Python interpreter as
     well (cf.  Cygwin package source(4), Maintainer releases(5))

See Python for Windows(6) for detailed information about platforms with
pre-compiled installers.

See also
........

Python on XP(7)

     "7 Minutes to "Hello World!""  by Richard Dooling, 2006

Installing on Windows(8)

     in "Dive into Python: Python from novice to pro(9)" by Mark
     Pilgrim, 2004, ISBN 1-59059-356-1

For Windows users(10)

     in "Installing Python" in "A Byte of Python(11)" by Swaroop C H,
     2003

   ---------- Footnotes ----------

   (1) https://www.python.org/dev/peps/pep-0011

   (2) http://pythonce.sourceforge.net/

   (3) http://cygwin.com/

   (4) 
ftp://ftp.uni-erlangen.de/pub/pc/gnuwin32/cygwin/mirrors/cygnus/release/python

   (5) http://www.tishler.net/jason/software/python/

   (6) https://www.python.org/downloads/windows/

   (7) 
http://dooling.com/index.php/2006/03/14/python-on-xp-7-minutes-to-hello-world/

   (8) http://www.diveintopython.net/installing_python/windows.html

   (9) http://www.diveintopython.net/

   (10) 
http://python.swaroopch.com/installation.html#installation-on-windows

   (11) http://python.swaroopch.com/


File: python.info,  Node: Alternative bundles,  Next: Configuring Python,  Prev: Installing Python,  Up: Using Python on Windows

3.3.2 Alternative bundles
-------------------------

Besides the standard CPython distribution, there are modified packages
including additional functionality.  The following is a list of popular
versions and their key features:

ActivePython(1)

     Installer with multi-platform compatibility, documentation, PyWin32

Anaconda(2)

     Popular scientific modules (such as numpy, scipy and pandas) and
     the ‘conda’ package manager.

Canopy(3)

     A "comprehensive Python analysis environment" with editors and
     other development tools.

WinPython(4)

     Windows-specific distribution with prebuilt scientific packages and
     tools for building packages.

Note that these packages may not include the latest versions of Python
or other libraries, and are not maintained or supported by the core
Python team.

   ---------- Footnotes ----------

   (1) https://www.activestate.com/activepython/

   (2) https://www.continuum.io/downloads/

   (3) https://www.enthought.com/products/canopy/

   (4) https://winpython.github.io/


File: python.info,  Node: Configuring Python,  Next: Python Launcher for Windows,  Prev: Alternative bundles,  Up: Using Python on Windows

3.3.3 Configuring Python
------------------------

To run Python conveniently from a command prompt, you might consider
changing some default environment variables in Windows.  While the
installer provides an option to configure the PATH and PATHEXT variables
for you, this is only reliable for a single, system-wide installation.
If you regularly use multiple versions of Python, consider using the
*note Python Launcher for Windows: 5ad.

* Menu:

* Excursus; Setting environment variables: Excursus Setting environment variables. 
* Finding the Python executable:: 


File: python.info,  Node: Excursus Setting environment variables,  Next: Finding the Python executable,  Up: Configuring Python

3.3.3.1 Excursus: Setting environment variables
...............................................

Windows allows environment variables to be configured permanently at
both the User level and the System level, or temporarily in a command
prompt.

To temporarily set environment variables, open Command Prompt and use
the ‘set’ command:

     C:\>set PATH=C:\Program Files\Python 3.5;%PATH%
     C:\>set PYTHONPATH=%PYTHONPATH%;C:\My_python_lib
     C:\>python

These changes will apply to any further commands executed in that
console, and will be inherited by any applications started from the
console.

Including the variable name within percent signs will expand to the
existing value, allowing you to add your new value at either the start
or the end.  Modifying ‘PATH’ by adding the directory containing
‘python.exe’ to the start is a common way to ensure the correct version
of Python is launched.

To permanently modify the default environment variables, click Start and
search for ’edit environment variables’, or open System properties,
Advanced system settings and click the Environment Variables button.  In
this dialog, you can add or modify User and System variables.  To change
System variables, you need non-restricted access to your machine (i.e.
Administrator rights).

     Note: Windows will concatenate User variables `after' System
     variables, which may cause unexpected results when modifying
     ‘PATH’.

     The *note PYTHONPATH: 567. variable is used by all versions of
     Python 2 and Python 3, so you should not permanently configure this
     variable unless it only includes code that is compatible with all
     of your installed Python versions.

See also
........

‘https://support.microsoft.com/kb/100843’

     Environment variables in Windows NT

‘https://technet.microsoft.com/en-us/library/cc754250.aspx’

     The SET command, for temporarily modifying environment variables

‘https://technet.microsoft.com/en-us/library/cc755104.aspx’

     The SETX command, for permanently modifying environment variables

‘https://support.microsoft.com/kb/310519’

     How To Manage Environment Variables in Windows XP

‘http://www.chem.gla.ac.uk/~louis/software/faq/q1.html’

     Setting Environment variables, Louis J. Farrugia


File: python.info,  Node: Finding the Python executable,  Prev: Excursus Setting environment variables,  Up: Configuring Python

3.3.3.2 Finding the Python executable
.....................................

Changed in version 3.5.

Besides using the automatically created start menu entry for the Python
interpreter, you might want to start Python in the command prompt.  The
installer for Python 3.5 and later has an option to set that up for you.

On the first page of the installer, an option labelled "Add Python 3.5
to PATH" can be selected to have the installer add the install location
into the ‘PATH’.  The location of the ‘Scripts\’ folder is also added.
This allows you to type ‘python’ to run the interpreter, and ‘pip’ or .
Thus, you can also execute your scripts with command line options, see
*note Command line: 532. documentation.

If you don’t enable this option at install time, you can always re-run
the installer, select Modify, and enable it.  Alternatively, you can
manually modify the ‘PATH’ using the directions in *note Excursus;
Setting environment variables: d3b.  You need to set your ‘PATH’
environment variable to include the directory of your Python
installation, delimited by a semicolon from other entries.  An example
variable could look like this (assuming the first two entries already
existed):

     C:\WINDOWS\system32;C:\WINDOWS;C:\Program Files\Python 3.5


File: python.info,  Node: Python Launcher for Windows,  Next: Finding modules,  Prev: Configuring Python,  Up: Using Python on Windows

3.3.4 Python Launcher for Windows
---------------------------------

New in version 3.3.

The Python launcher for Windows is a utility which aids in locating and
executing of different Python versions.  It allows scripts (or the
command-line) to indicate a preference for a specific Python version,
and will locate and execute that version.

Unlike the ‘PATH’ variable, the launcher will correctly select the most
appropriate version of Python.  It will prefer per-user installations
over system-wide ones, and orders by language version rather than using
the most recently installed version.

* Menu:

* Getting started:: 
* Shebang Lines:: 
* Arguments in shebang lines:: 
* Customization:: 
* Diagnostics:: 


File: python.info,  Node: Getting started,  Next: Shebang Lines,  Up: Python Launcher for Windows

3.3.4.1 Getting started
.......................

* Menu:

* From the command-line:: 
* Virtual environments:: 
* From a script:: 
* From file associations:: 


File: python.info,  Node: From the command-line,  Next: Virtual environments,  Up: Getting started

3.3.4.2 From the command-line
.............................

System-wide installations of Python 3.3 and later will put the launcher
on your ‘PATH’.  The launcher is compatible with all available versions
of Python, so it does not matter which version is installed.  To check
that the launcher is available, execute the following command in Command
Prompt:

     py

You should find that the latest version of Python 2.x you have installed
is started - it can be exited as normal, and any additional command-line
arguments specified will be sent directly to Python.

If you have multiple versions of Python 2.x installed (e.g., 2.6 and
2.7) you will have noticed that Python 2.7 was started - to launch
Python 2.6, try the command:

     py -2.6

If you have a Python 3.x installed, try the command:

     py -3

You should find the latest version of Python 3.x starts.

If you see the following error, you do not have the launcher installed:

     'py' is not recognized as an internal or external command,
     operable program or batch file.

Per-user installations of Python do not add the launcher to ‘PATH’
unless the option was selected on installation.


File: python.info,  Node: Virtual environments,  Next: From a script,  Prev: From the command-line,  Up: Getting started

3.3.4.3 Virtual environments
............................

New in version 3.5.

If the launcher is run with no explicit Python version specification,
and a virtual environment (created with the standard library *note venv:
122. module or the external ‘virtualenv’ tool) active, the launcher will
run the virtual environment’s interpreter rather than the global one.
To run the global interpreter, either deactivate the virtual
environment, or explicitly specify the global Python version.


File: python.info,  Node: From a script,  Next: From file associations,  Prev: Virtual environments,  Up: Getting started

3.3.4.4 From a script
.....................

Let’s create a test Python script - create a file called ‘hello.py’ with
the following contents

     #! python
     import sys
     sys.stdout.write("hello from Python %s\n" % (sys.version,))

From the directory in which hello.py lives, execute the command:

     py hello.py

You should notice the version number of your latest Python 2.x
installation is printed.  Now try changing the first line to be:

     #! python3

Re-executing the command should now print the latest Python 3.x
information.  As with the above command-line examples, you can specify a
more explicit version qualifier.  Assuming you have Python 2.6
installed, try changing the first line to ‘#! python2.6’ and you should
find the 2.6 version information printed.


File: python.info,  Node: From file associations,  Prev: From a script,  Up: Getting started

3.3.4.5 From file associations
..............................

The launcher should have been associated with Python files (i.e.  ‘.py’,
‘.pyw’, ‘.pyc’ files) when it was installed.  This means that when you
double-click on one of these files from Windows explorer the launcher
will be used, and therefore you can use the same facilities described
above to have the script specify the version which should be used.

The key benefit of this is that a single launcher can support multiple
Python versions at the same time depending on the contents of the first
line.


File: python.info,  Node: Shebang Lines,  Next: Arguments in shebang lines,  Prev: Getting started,  Up: Python Launcher for Windows

3.3.4.6 Shebang Lines
.....................

If the first line of a script file starts with ‘#!’, it is known as a
"shebang" line.  Linux and other Unix like operating systems have native
support for such lines and are commonly used on such systems to indicate
how a script should be executed.  This launcher allows the same
facilities to be using with Python scripts on Windows and the examples
above demonstrate their use.

To allow shebang lines in Python scripts to be portable between Unix and
Windows, this launcher supports a number of ’virtual’ commands to
specify which interpreter to use.  The supported virtual commands are:

   * ‘/usr/bin/env python’

   * ‘/usr/bin/python’

   * ‘/usr/local/bin/python’

   * ‘python’

For example, if the first line of your script starts with

     #! /usr/bin/python

The default Python will be located and used.  As many Python scripts
written to work on Unix will already have this line, you should find
these scripts can be used by the launcher without modification.  If you
are writing a new script on Windows which you hope will be useful on
Unix, you should use one of the shebang lines starting with ‘/usr’.

Any of the above virtual commands can be suffixed with an explicit
version (either just the major version, or the major and minor version)
- for example ‘/usr/bin/python2.7’ - which will cause that specific
version to be located and used.

The ‘/usr/bin/env’ form of shebang line has one further special
property.  Before looking for installed Python interpreters, this form
will search the executable ‘PATH’ for a Python executable.  This
corresponds to the behaviour of the Unix ‘env’ program, which performs a
‘PATH’ search.


File: python.info,  Node: Arguments in shebang lines,  Next: Customization,  Prev: Shebang Lines,  Up: Python Launcher for Windows

3.3.4.7 Arguments in shebang lines
..................................

The shebang lines can also specify additional options to be passed to
the Python interpreter.  For example, if you have a shebang line:

     #! /usr/bin/python -v

Then Python will be started with the ‘-v’ option


File: python.info,  Node: Customization,  Next: Diagnostics,  Prev: Arguments in shebang lines,  Up: Python Launcher for Windows

3.3.4.8 Customization
.....................

* Menu:

* Customization via INI files:: 
* Customizing default Python versions:: 


File: python.info,  Node: Customization via INI files,  Next: Customizing default Python versions,  Up: Customization

3.3.4.9 Customization via INI files
...................................

Two .ini files will be searched by the launcher - ‘py.ini’ in the
current user’s "application data" directory (i.e.  the directory
returned by calling the Windows function SHGetFolderPath with
CSIDL_LOCAL_APPDATA) and ‘py.ini’ in the same directory as the launcher.
The same .ini files are used for both the ’console’ version of the
launcher (i.e.  py.exe) and for the ’windows’ version (i.e.  pyw.exe)

Customization specified in the "application directory" will have
precedence over the one next to the executable, so a user, who may not
have write access to the .ini file next to the launcher, can override
commands in that global .ini file)


File: python.info,  Node: Customizing default Python versions,  Prev: Customization via INI files,  Up: Customization

3.3.4.10 Customizing default Python versions
............................................

In some cases, a version qualifier can be included in a command to
dictate which version of Python will be used by the command.  A version
qualifier starts with a major version number and can optionally be
followed by a period (’.’) and a minor version specifier.  If the minor
qualifier is specified, it may optionally be followed by "-32" to
indicate the 32-bit implementation of that version be used.

For example, a shebang line of ‘#!python’ has no version qualifier,
while ‘#!python3’ has a version qualifier which specifies only a major
version.

If no version qualifiers are found in a command, the environment
variable ‘PY_PYTHON’ can be set to specify the default version qualifier
- the default value is "2".  Note this value could specify just a major
version (e.g.  "2") or a major.minor qualifier (e.g.  "2.6"), or even
major.minor-32.

If no minor version qualifiers are found, the environment variable
‘PY_PYTHON{major}’ (where ‘{major}’ is the current major version
qualifier as determined above) can be set to specify the full version.
If no such option is found, the launcher will enumerate the installed
Python versions and use the latest minor release found for the major
version, which is likely, although not guaranteed, to be the most
recently installed version in that family.

On 64-bit Windows with both 32-bit and 64-bit implementations of the
same (major.minor) Python version installed, the 64-bit version will
always be preferred.  This will be true for both 32-bit and 64-bit
implementations of the launcher - a 32-bit launcher will prefer to
execute a 64-bit Python installation of the specified version if
available.  This is so the behavior of the launcher can be predicted
knowing only what versions are installed on the PC and without regard to
the order in which they were installed (i.e., without knowing whether a
32 or 64-bit version of Python and corresponding launcher was installed
last).  As noted above, an optional "-32" suffix can be used on a
version specifier to change this behaviour.

Examples:

   * If no relevant options are set, the commands ‘python’ and ‘python2’
     will use the latest Python 2.x version installed and the command
     ‘python3’ will use the latest Python 3.x installed.

   * The commands ‘python3.1’ and ‘python2.7’ will not consult any
     options at all as the versions are fully specified.

   * If ‘PY_PYTHON=3’, the commands ‘python’ and ‘python3’ will both use
     the latest installed Python 3 version.

   * If ‘PY_PYTHON=3.1-32’, the command ‘python’ will use the 32-bit
     implementation of 3.1 whereas the command ‘python3’ will use the
     latest installed Python (PY_PYTHON was not considered at all as a
     major version was specified.)

   * If ‘PY_PYTHON=3’ and ‘PY_PYTHON3=3.1’, the commands ‘python’ and
     ‘python3’ will both use specifically 3.1

In addition to environment variables, the same settings can be
configured in the .INI file used by the launcher.  The section in the
INI file is called ‘[defaults]’ and the key name will be the same as the
environment variables without the leading ‘PY_’ prefix (and note that
the key names in the INI file are case insensitive.)  The contents of an
environment variable will override things specified in the INI file.

For example:

   * Setting ‘PY_PYTHON=3.1’ is equivalent to the INI file containing:

     [defaults]
     python=3.1

   * Setting ‘PY_PYTHON=3’ and ‘PY_PYTHON3=3.1’ is equivalent to the INI
     file containing:

     [defaults]
     python=3
     python3=3.1


File: python.info,  Node: Diagnostics,  Prev: Customization,  Up: Python Launcher for Windows

3.3.4.11 Diagnostics
....................

If an environment variable ‘PYLAUNCH_DEBUG’ is set (to any value), the
launcher will print diagnostic information to stderr (i.e.  to the
console).  While this information manages to be simultaneously verbose
`and' terse, it should allow you to see what versions of Python were
located, why a particular version was chosen and the exact command-line
used to execute the target Python.


File: python.info,  Node: Finding modules,  Next: Additional modules,  Prev: Python Launcher for Windows,  Up: Using Python on Windows

3.3.5 Finding modules
---------------------

Python usually stores its library (and thereby your site-packages
folder) in the installation directory.  So, if you had installed Python
to ‘C:\Python\’, the default library would reside in ‘C:\Python\Lib\’
and third-party modules should be stored in
‘C:\Python\Lib\site-packages\’.

This is how *note sys.path: 16c. is populated on Windows:

   * An empty entry is added at the start, which corresponds to the
     current directory.

   * If the environment variable *note PYTHONPATH: 567. exists, as
     described in *note Environment variables: d14, its entries are
     added next.  Note that on Windows, paths in this variable must be
     separated by semicolons, to distinguish them from the colon used in
     drive identifiers (‘C:\’ etc.).

   * Additional "application paths" can be added in the registry as
     subkeys of ‘\SOFTWARE\Python\PythonCore\`version'\PythonPath’ under
     both the ‘HKEY_CURRENT_USER’ and ‘HKEY_LOCAL_MACHINE’ hives.
     Subkeys which have semicolon-delimited path strings as their
     default value will cause each path to be added to *note sys.path:
     16c.  (Note that all known installers only use HKLM, so HKCU is
     typically empty.)

   * If the environment variable *note PYTHONHOME: d04. is set, it is
     assumed as "Python Home".  Otherwise, the path of the main Python
     executable is used to locate a "landmark file" (‘Lib\os.py’) to
     deduce the "Python Home".  If a Python home is found, the relevant
     sub-directories added to *note sys.path: 16c. (‘Lib’, ‘plat-win’,
     etc) are based on that folder.  Otherwise, the core Python path is
     constructed from the PythonPath stored in the registry.

   * If the Python Home cannot be located, no *note PYTHONPATH: 567. is
     specified in the environment, and no registry entries can be found,
     a default path with relative entries is used (e.g.
     ‘.\Lib;.\plat-win’, etc).

If a ‘pyvenv.cfg’ file is found alongside the main executable or in the
directory one level above the executable, the following variations
apply:

   * If ‘home’ is an absolute path and *note PYTHONHOME: d04. is not
     set, this path is used instead of the path to the main executable
     when deducing the home location.

   * If ‘applocal’ is set to true, the ‘home’ property or the main
     executable is always used as the home path, and all environment
     variables or registry values affecting the path are ignored.  The
     landmark file is not checked.

The end result of all this is:

   * When running ‘python.exe’, or any other .exe in the main Python
     directory (either an installed version, or directly from the
     PCbuild directory), the core path is deduced, and the core paths in
     the registry are ignored.  Other "application paths" in the
     registry are always read.

   * When Python is hosted in another .exe (different directory,
     embedded via COM, etc), the "Python Home" will not be deduced, so
     the core path from the registry is used.  Other "application paths"
     in the registry are always read.

   * If Python can’t find its home and there are no registry value
     (frozen .exe, some very strange installation setup) you get a path
     with some default, but relative, paths.

For those who want to bundle Python into their application or
distribution, the following advice will prevent conflicts with other
installations:

   * Include a ‘pyvenv.cfg’ file alongside your executable containing
     ‘applocal = true’.  This will ensure that your own directory will
     be used to resolve paths even if you have included the standard
     library in a ZIP file.  It will also ignore user site-packages and
     other paths listed in the registry.

   * If you are loading ‘python3.dll’ or ‘python35.dll’ in your own
     executable, explicitly call *note Py_SetPath(): d4a. or (at least)
     *note Py_SetProgramName(): d4b. before *note Py_Initialize(): 876.

   * Clear and/or overwrite *note PYTHONPATH: 567. and set *note
     PYTHONHOME: d04. before launching ‘python.exe’ from your
     application.

   * If you cannot use the previous suggestions (for example, you are a
     distribution that allows people to run ‘python.exe’ directly),
     ensure that the landmark file (‘Lib\os.py’) exists in your install
     directory.  (Note that it will not be detected inside a ZIP file.)

These will ensure that the files in a system-wide installation will not
take precedence over the copy of the standard library bundled with your
application.  Otherwise, your users may experience problems using your
application.  Note that the first suggestion is the best, as the other
may still be susceptible to non-standard paths in the registry and user
site-packages.


File: python.info,  Node: Additional modules,  Next: Compiling Python on Windows,  Prev: Finding modules,  Up: Using Python on Windows

3.3.6 Additional modules
------------------------

Even though Python aims to be portable among all platforms, there are
features that are unique to Windows.  A couple of modules, both in the
standard library and external, and snippets exist to use these features.

The Windows-specific standard modules are documented in *note MS Windows
Specific Services: d4d.

* Menu:

* PyWin32:: 
* cx_Freeze:: 
* WConio:: 


File: python.info,  Node: PyWin32,  Next: cx_Freeze,  Up: Additional modules

3.3.6.1 PyWin32
...............

The PyWin32(1) module by Mark Hammond is a collection of modules for
advanced Windows-specific support.  This includes utilities for:

   * Component Object Model(2) (COM)

   * Win32 API calls

   * Registry

   * Event log

   * Microsoft Foundation Classes(3) (MFC) user interfaces

PythonWin(4) is a sample MFC application shipped with PyWin32.  It is an
embeddable IDE with a built-in debugger.

See also
........

Win32 How Do I...?(5)

     by Tim Golden

Python and COM(6)

     by David and Paul Boddie

   ---------- Footnotes ----------

   (1) https://pypi.python.org/pypi/pywin32

   (2) https://www.microsoft.com/com/

   (3) https://msdn.microsoft.com/en-us/library/fe1cf721%28VS.80%29.aspx

   (4) 
https://web.archive.org/web/20060524042422/https://www.python.org/windows/pythonwin/

   (5) http://timgolden.me.uk/python/win32_how_do_i.html

   (6) http://www.boddie.org.uk/python/COM.html


File: python.info,  Node: cx_Freeze,  Next: WConio,  Prev: PyWin32,  Up: Additional modules

3.3.6.2 cx_Freeze
.................

cx_Freeze(1) is a *note distutils: 37. extension (see *note Extending
Distutils: d50.) which wraps Python scripts into executable Windows
programs (‘`*'.exe’ files).  When you have done this, you can distribute
your application without requiring your users to install Python.

   ---------- Footnotes ----------

   (1) http://cx-freeze.sourceforge.net/


File: python.info,  Node: WConio,  Prev: cx_Freeze,  Up: Additional modules

3.3.6.3 WConio
..............

Since Python’s advanced terminal handling layer, *note curses: 2b, is
restricted to Unix-like systems, there is a library exclusive to Windows
as well: Windows Console I/O for Python.

WConio(1) is a wrapper for Turbo-C’s ‘CONIO.H’, used to create text user
interfaces.

   ---------- Footnotes ----------

   (1) http://newcenturycomputers.net/projects/wconio.html


File: python.info,  Node: Compiling Python on Windows,  Next: Embedded Distribution,  Prev: Additional modules,  Up: Using Python on Windows

3.3.7 Compiling Python on Windows
---------------------------------

If you want to compile CPython yourself, first thing you should do is
get the source(1).  You can download either the latest release’s source
or just grab a fresh checkout(2).

The source tree contains a build solution and project files for
Microsoft Visual Studio 2015, which is the compiler used to build the
official Python releases.  These files are in the ‘PCbuild’ directory.

Check ‘PCbuild/readme.txt’ for general information on the build process.

For extension modules, consult *note Building C and C++ Extensions on
Windows: d53.

See also
........

Python + Windows + distutils + SWIG + gcc MinGW(3)

     or "Creating Python extensions in C/C++ with SWIG and compiling
     them with MinGW gcc under Windows" or "Installing Python extension
     with distutils and without Microsoft Visual C++" by Sébastien
     Sauvage, 2003

MingW – Python extensions(4)

     by Trent Apted et al, 2007

   ---------- Footnotes ----------

   (1) https://www.python.org/downloads/source/

   (2) 
https://docs.python.org/devguide/setup.html#getting-the-source-code

   (3) http://sebsauvage.net/python/mingw.html

   (4) http://oldwiki.mingw.org/index.php/Python%20extensions


File: python.info,  Node: Embedded Distribution,  Next: Other resources,  Prev: Compiling Python on Windows,  Up: Using Python on Windows

3.3.8 Embedded Distribution
---------------------------

New in version 3.5.

The embedded distribution is a ZIP file containing a minimal Python
environment.  It is intended for acting as part of another application,
rather than being directly accessed by end-users.

When extracted, the embedded distribution is (almost) fully isolated
from the user’s system, including environment variables, system registry
settings, and installed packages.  The standard library is included as
pre-compiled and optimized ‘.pyc’ files in a ZIP, and ‘python3.dll’,
‘python35.dll’, ‘python.exe’ and ‘pythonw.exe’ are all provided.  Tcl/tk
(including all dependants, such as Idle), pip and the Python
documentation are not included.

     Note: The embedded distribution does not include the Microsoft C
     Runtime(1) and it is the responsibility of the application
     installer to provide this.  The runtime may have already been
     installed on a user’s system previously or automatically via
     Windows Update, and can be detected by finding ‘ucrtbase.dll’ in
     the system directory.

Third-party packages should be installed by the application installer
alongside the embedded distribution.  Using pip to manage dependencies
as for a regular Python installation is not supported with this
distribution, though with some care it may be possible to include and
use pip for automatic updates.  In general, third-party packages should
be treated as part of the application ("vendoring") so that the
developer can ensure compatibility with newer versions before providing
updates to users.

The two recommended use cases for this distribution are described below.

* Menu:

* Python Application:: 
* Embedding Python:: 

   ---------- Footnotes ----------

   (1) https://www.microsoft.com/en-us/download/details.aspx?id=48145


File: python.info,  Node: Python Application,  Next: Embedding Python,  Up: Embedded Distribution

3.3.8.1 Python Application
..........................

An application written in Python does not necessarily require users to
be aware of that fact.  The embedded distribution may be used in this
case to include a private version of Python in an install package.
Depending on how transparent it should be (or conversely, how
professional it should appear), there are two options.

Using a specialized executable as a launcher requires some coding, but
provides the most transparent experience for users.  With a customized
launcher, there are no obvious indications that the program is running
on Python: icons can be customized, company and version information can
be specified, and file associations behave properly.  In most cases, a
custom launcher should simply be able to call ‘Py_Main’ with a
hard-coded command line.

The simpler approach is to provide a batch file or generated shortcut
that directly calls the ‘python.exe’ or ‘pythonw.exe’ with the required
command-line arguments.  In this case, the application will appear to be
Python and not its actual name, and users may have trouble
distinguishing it from other running Python processes or file
associations.

With the latter approach, packages should be installed as directories
alongside the Python executable to ensure they are available on the
path.  With the specialized launcher, packages can be located in other
locations as there is an opportunity to specify the search path before
launching the application.


File: python.info,  Node: Embedding Python,  Prev: Python Application,  Up: Embedded Distribution

3.3.8.2 Embedding Python
........................

Applications written in native code often require some form of scripting
language, and the embedded Python distribution can be used for this
purpose.  In general, the majority of the application is in native code,
and some part will either invoke ‘python.exe’ or directly use
‘python3.dll’.  For either case, extracting the embedded distribution to
a subdirectory of the application installation is sufficient to provide
a loadable Python interpreter.

As with the application use, packages can be installed to any location
as there is an opportunity to specify search paths before initializing
the interpreter.  Otherwise, there is no fundamental differences between
using the embedded distribution and a regular installation.


File: python.info,  Node: Other resources,  Prev: Embedded Distribution,  Up: Using Python on Windows

3.3.9 Other resources
---------------------

See also
........

Python Programming On Win32(1)

     "Help for Windows Programmers" by Mark Hammond and Andy Robinson,
     O’Reilly Media, 2000, ISBN 1-56592-621-8

A Python for Windows Tutorial(2)

     by Amanda Birmingham, 2004

PEP 397(3) - Python launcher for Windows

     The proposal for the launcher to be included in the Python
     distribution.

   ---------- Footnotes ----------

   (1) http://shop.oreilly.com/product/9781565926219.do

   (2) http://www.imladris.com/Scripts/PythonForWindows.html

   (3) https://www.python.org/dev/peps/pep-0397


File: python.info,  Node: Using Python on a Macintosh,  Next: Additional Tools and Scripts,  Prev: Using Python on Windows,  Up: Python Setup and Usage

3.4 Using Python on a Macintosh
===============================


Author: Bob Savage <<bobsavage@mac.com>>

Python on a Macintosh running Mac OS X is in principle very similar to
Python on any other Unix platform, but there are a number of additional
features such as the IDE and the Package Manager that are worth pointing
out.

* Menu:

* Getting and Installing MacPython:: 
* The IDE:: 
* Installing Additional Python Packages:: 
* GUI Programming on the Mac:: 
* Distributing Python Applications on the Mac:: 
* Other Resources:: 


File: python.info,  Node: Getting and Installing MacPython,  Next: The IDE,  Up: Using Python on a Macintosh

3.4.1 Getting and Installing MacPython
--------------------------------------

Mac OS X 10.8 comes with Python 2.7 pre-installed by Apple.  If you
wish, you are invited to install the most recent version of Python 3
from the Python website (‘https://www.python.org’).  A current
"universal binary" build of Python, which runs natively on the Mac’s new
Intel and legacy PPC CPU’s, is available there.

What you get after installing is a number of things:

   * A ‘MacPython 3.6’ folder in your ‘Applications’ folder.  In here
     you find IDLE, the development environment that is a standard part
     of official Python distributions; PythonLauncher, which handles
     double-clicking Python scripts from the Finder; and the "Build
     Applet" tool, which allows you to package Python scripts as
     standalone applications on your system.

   * A framework ‘/Library/Frameworks/Python.framework’, which includes
     the Python executable and libraries.  The installer adds this
     location to your shell path.  To uninstall MacPython, you can
     simply remove these three things.  A symlink to the Python
     executable is placed in /usr/local/bin/.

The Apple-provided build of Python is installed in
‘/System/Library/Frameworks/Python.framework’ and ‘/usr/bin/python’,
respectively.  You should never modify or delete these, as they are
Apple-controlled and are used by Apple- or third-party software.
Remember that if you choose to install a newer Python version from
python.org, you will have two different but functional Python
installations on your computer, so it will be important that your paths
and usages are consistent with what you want to do.

IDLE includes a help menu that allows you to access Python
documentation.  If you are completely new to Python you should start
reading the tutorial introduction in that document.

If you are familiar with Python on other Unix platforms you should read
the section on running Python scripts from the Unix shell.

* Menu:

* How to run a Python script:: 
* Running scripts with a GUI:: 
* Configuration:: 


File: python.info,  Node: How to run a Python script,  Next: Running scripts with a GUI,  Up: Getting and Installing MacPython

3.4.1.1 How to run a Python script
..................................

Your best way to get started with Python on Mac OS X is through the IDLE
integrated development environment, see section *note The IDE: d5e. and
use the Help menu when the IDE is running.

If you want to run Python scripts from the Terminal window command line
or from the Finder you first need an editor to create your script.  Mac
OS X comes with a number of standard Unix command line editors, ‘vim’
and ‘emacs’ among them.  If you want a more Mac-like editor, ‘BBEdit’ or
‘TextWrangler’ from Bare Bones Software (see
‘http://www.barebones.com/products/bbedit/index.html’) are good choices,
as is ‘TextMate’ (see ‘http://macromates.com/’).  Other editors include
‘Gvim’ (‘http://macvim.org’) and ‘Aquamacs’ (‘http://aquamacs.org/’).

To run your script from the Terminal window you must make sure that
‘/usr/local/bin’ is in your shell search path.

To run your script from the Finder you have two options:

   * Drag it to ‘PythonLauncher’

   * Select ‘PythonLauncher’ as the default application to open your
     script (or any .py script) through the finder Info window and
     double-click it.  ‘PythonLauncher’ has various preferences to
     control how your script is launched.  Option-dragging allows you to
     change these for one invocation, or use its Preferences menu to
     change things globally.


File: python.info,  Node: Running scripts with a GUI,  Next: Configuration,  Prev: How to run a Python script,  Up: Getting and Installing MacPython

3.4.1.2 Running scripts with a GUI
..................................

With older versions of Python, there is one Mac OS X quirk that you need
to be aware of: programs that talk to the Aqua window manager (in other
words, anything that has a GUI) need to be run in a special way.  Use
‘pythonw’ instead of ‘python’ to start such scripts.

With Python 3.6, you can use either ‘python’ or ‘pythonw’.


File: python.info,  Node: Configuration,  Prev: Running scripts with a GUI,  Up: Getting and Installing MacPython

3.4.1.3 Configuration
.....................

Python on OS X honors all standard Unix environment variables such as
*note PYTHONPATH: 567, but setting these variables for programs started
from the Finder is non-standard as the Finder does not read your
‘.profile’ or ‘.cshrc’ at startup.  You need to create a file
‘~/.MacOSX/environment.plist’.  See Apple’s Technical Document QA1067
for details.

For more information on installation Python packages in MacPython, see
section *note Installing Additional Python Packages: d62.


File: python.info,  Node: The IDE,  Next: Installing Additional Python Packages,  Prev: Getting and Installing MacPython,  Up: Using Python on a Macintosh

3.4.2 The IDE
-------------

MacPython ships with the standard IDLE development environment.  A good
introduction to using IDLE can be found at
‘https://hkn.eecs.berkeley.edu/~dyoo/python/idle_intro/index.html’.


File: python.info,  Node: Installing Additional Python Packages,  Next: GUI Programming on the Mac,  Prev: The IDE,  Up: Using Python on a Macintosh

3.4.3 Installing Additional Python Packages
-------------------------------------------

There are several methods to install additional Python packages:

   * Packages can be installed via the standard Python distutils mode
     (‘python setup.py install’).

   * Many packages can also be installed via the ‘setuptools’ extension
     or ‘pip’ wrapper, see ‘https://pip.pypa.io/’.


File: python.info,  Node: GUI Programming on the Mac,  Next: Distributing Python Applications on the Mac,  Prev: Installing Additional Python Packages,  Up: Using Python on a Macintosh

3.4.4 GUI Programming on the Mac
--------------------------------

There are several options for building GUI applications on the Mac with
Python.

`PyObjC' is a Python binding to Apple’s Objective-C/Cocoa framework,
which is the foundation of most modern Mac development.  Information on
PyObjC is available from ‘https://pythonhosted.org/pyobjc/’.

The standard Python GUI toolkit is *note tkinter: 109, based on the
cross-platform Tk toolkit (‘http://www.tcl.tk’).  An Aqua-native version
of Tk is bundled with OS X by Apple, and the latest version can be
downloaded and installed from ‘http://www.activestate.com’; it can also
be built from source.

`wxPython' is another popular cross-platform GUI toolkit that runs
natively on Mac OS X. Packages and documentation are available from
‘http://www.wxpython.org’.

`PyQt' is another popular cross-platform GUI toolkit that runs natively
on Mac OS X. More information can be found at
‘https://riverbankcomputing.com/software/pyqt/intro’.


File: python.info,  Node: Distributing Python Applications on the Mac,  Next: Other Resources,  Prev: GUI Programming on the Mac,  Up: Using Python on a Macintosh

3.4.5 Distributing Python Applications on the Mac
-------------------------------------------------

The "Build Applet" tool that is placed in the MacPython 3.6 folder is
fine for packaging small Python scripts on your own machine to run as a
standard Mac application.  This tool, however, is not robust enough to
distribute Python applications to other users.

The standard tool for deploying standalone Python applications on the
Mac is ‘py2app’.  More information on installing and using py2app can be
found at ‘http://undefined.org/python/#py2app’.


File: python.info,  Node: Other Resources,  Prev: Distributing Python Applications on the Mac,  Up: Using Python on a Macintosh

3.4.6 Other Resources
---------------------

The MacPython mailing list is an excellent support resource for Python
users and developers on the Mac:

‘https://www.python.org/community/sigs/current/pythonmac-sig/’

Another useful resource is the MacPython wiki:

‘https://wiki.python.org/moin/MacPython’


File: python.info,  Node: Additional Tools and Scripts,  Prev: Using Python on a Macintosh,  Up: Python Setup and Usage

3.5 Additional Tools and Scripts
================================

* Menu:

* pyvenv - Creating virtual environments:: 


File: python.info,  Node: pyvenv - Creating virtual environments,  Up: Additional Tools and Scripts

3.5.1 pyvenv - Creating virtual environments
--------------------------------------------

Creation of *note virtual environments: d6c. is done by executing the
‘pyvenv’ script:

     pyvenv /path/to/new/virtual/environment

Running this command creates the target directory (creating any parent
directories that don’t exist already) and places a ‘pyvenv.cfg’ file in
it with a ‘home’ key pointing to the Python installation the command was
run from.  It also creates a ‘bin’ (or ‘Scripts’ on Windows)
subdirectory containing a copy of the ‘python’ binary (or binaries, in
the case of Windows).  It also creates an (initially empty)
‘lib/pythonX.Y/site-packages’ subdirectory (on Windows, this is
‘Lib\site-packages’).

See also
........

Python Packaging User Guide: Creating and using virtual environments(1)

On Windows, you may have to invoke the ‘pyvenv’ script as follows, if
you don’t have the relevant PATH and PATHEXT settings:

     c:\Temp>c:\Python35\python c:\Python35\Tools\Scripts\pyvenv.py myenv

or equivalently:

     c:\Temp>c:\Python35\python -m venv myenv

The command, if run with ‘-h’, will show the available options:

     usage: venv [-h] [--system-site-packages] [--symlinks | --copies] [--clear]
                 [--upgrade] [--without-pip]
                 ENV_DIR [ENV_DIR ...]

     Creates virtual Python environments in one or more target directories.

     positional arguments:
       ENV_DIR             A directory to create the environment in.

     optional arguments:
       -h, --help             show this help message and exit
       --system-site-packages Give the virtual environment access to the system
                              site-packages dir.
       --symlinks             Try to use symlinks rather than copies, when symlinks
                              are not the default for the platform.
       --copies               Try to use copies rather than symlinks, even when
                              symlinks are the default for the platform.
       --clear                Delete the contents of the environment directory if it
                              already exists, before environment creation.
       --upgrade              Upgrade the environment directory to use this version
                              of Python, assuming Python has been upgraded in-place.
       --without-pip          Skips installing or upgrading pip in the virtual
                              environment (pip is bootstrapped by default)

Depending on how the ‘venv’ functionality has been invoked, the usage
message may vary slightly, e.g.  referencing ‘pyvenv’ rather than
‘venv’.

Changed in version 3.4: Installs pip by default, added the
‘--without-pip’ and ‘--copies’ options

Changed in version 3.4: In earlier versions, if the target directory
already existed, an error was raised, unless the ‘--clear’ or
‘--upgrade’ option was provided.  Now, if an existing directory is
specified, its contents are removed and the directory is processed as if
it had been newly created.

The created ‘pyvenv.cfg’ file also includes the
‘include-system-site-packages’ key, set to ‘true’ if ‘venv’ is run with
the ‘--system-site-packages’ option, ‘false’ otherwise.

Unless the ‘--without-pip’ option is given, *note ensurepip: 78. will be
invoked to bootstrap ‘pip’ into the virtual environment.

Multiple paths can be given to ‘pyvenv’, in which case an identical
virtualenv will be created, according to the given options, at each
provided path.

Once a venv has been created, it can be "activated" using a script in
the venv’s binary directory.  The invocation of the script is
platform-specific:

Platform          Shell                 Command to activate virtual environment
                                        
--------------------------------------------------------------------------------------
                                        
Posix             bash/zsh              $ source <venv>/bin/activate
                                        
                                        
                  fish                  $ .  <venv>/bin/activate.fish
                                        
                                        
                  csh/tcsh              $ source <venv>/bin/activate.csh
                                        
                                        
Windows           cmd.exe               C:> <venv>/Scripts/activate.bat
                                        
                                        
                  PowerShell            PS C:> <venv>/Scripts/Activate.ps1
                                        

You don’t specifically `need' to activate an environment; activation
just prepends the venv’s binary directory to your path, so that "python"
invokes the venv’s Python interpreter and you can run installed scripts
without having to use their full path.  However, all scripts installed
in a venv should be runnable without activating it, and run with the
venv’s Python automatically.

You can deactivate a venv by typing "deactivate" in your shell.  The
exact mechanism is platform-specific: for example, the Bash activation
script defines a "deactivate" function, whereas on Windows there are
separate scripts called ‘deactivate.bat’ and ‘Deactivate.ps1’ which are
installed when the venv is created.

New in version 3.4: ‘fish’ and ‘csh’ activation scripts.

   ---------- Footnotes ----------

   (1) 
https://packaging.python.org/en/latest/installing/#creating-virtual-environments


File: python.info,  Node: The Python Language Reference,  Next: The Python Standard Library,  Prev: Python Setup and Usage,  Up: Top

4 The Python Language Reference
*******************************

This reference manual describes the syntax and "core semantics" of the
language.  It is terse, but attempts to be exact and complete.  The
semantics of non-essential built-in object types and of the built-in
functions and modules are described in *note The Python Standard
Library: bc5.  For an informal introduction to the language, see *note
The Python Tutorial: bc4.  For C or C++ programmers, two additional
manuals exist: *note Extending and Embedding the Python Interpreter:
bc7. describes the high-level picture of how to write a Python extension
module, and the *note Python/C API Reference Manual: bc8. describes the
interfaces available to C/C++ programmers in detail.

* Menu:

* Introduction: Introduction<5>. 
* Lexical analysis:: 
* Data model:: 
* Execution model:: 
* The import system:: 
* Expressions:: 
* Simple statements:: 
* Compound statements:: 
* Top-level components:: 
* Full Grammar specification:: 


File: python.info,  Node: Introduction<5>,  Next: Lexical analysis,  Up: The Python Language Reference

4.1 Introduction
================

This reference manual describes the Python programming language.  It is
not intended as a tutorial.

While I am trying to be as precise as possible, I chose to use English
rather than formal specifications for everything except syntax and
lexical analysis.  This should make the document more understandable to
the average reader, but will leave room for ambiguities.  Consequently,
if you were coming from Mars and tried to re-implement Python from this
document alone, you might have to guess things and in fact you would
probably end up implementing quite a different language.  On the other
hand, if you are using Python and wonder what the precise rules about a
particular area of the language are, you should definitely be able to
find them here.  If you would like to see a more formal definition of
the language, maybe you could volunteer your time — or invent a cloning
machine :-).

It is dangerous to add too many implementation details to a language
reference document — the implementation may change, and other
implementations of the same language may work differently.  On the other
hand, CPython is the one Python implementation in widespread use
(although alternate implementations continue to gain support), and its
particular quirks are sometimes worth being mentioned, especially where
the implementation imposes additional limitations.  Therefore, you’ll
find short "implementation notes" sprinkled throughout the text.

Every Python implementation comes with a number of built-in and standard
modules.  These are documented in *note The Python Standard Library:
bc5.  A few built-in modules are mentioned when they interact in a
significant way with the language definition.

* Menu:

* Alternate Implementations:: 
* Notation:: 

