This is python.info, produced by makeinfo version 6.0 from python.texi.

     Python 3.6.0a0, May 06, 2016

     Georg Brandl

     Copyright © 2001-2016, Python Software Foundation

INFO-DIR-SECTION Documentation tools
START-INFO-DIR-ENTRY
* Python: (python.info). The Python Programming Language
END-INFO-DIR-ENTRY


   Generated by Sphinx 1.4.1.


File: python.info,  Node: Internet Data Handling,  Next: Structured Markup Processing Tools,  Prev: Interprocess Communication and Networking,  Up: The Python Standard Library

5.19 Internet Data Handling
===========================

This chapter describes modules which support handling data formats
commonly used on the Internet.

* Menu:

* email: email --- An email and MIME handling package. An email and MIME handling package
* json: json --- JSON encoder and decoder. JSON encoder and decoder
* mailcap: mailcap --- Mailcap file handling. Mailcap file handling
* mailbox: mailbox --- Manipulate mailboxes in various formats. Manipulate mailboxes in various formats
* mimetypes: mimetypes --- Map filenames to MIME types. Map filenames to MIME types
* base64: base64 --- Base16 Base32 Base64 Base85 Data Encodings. Base16, Base32, Base64, Base85 Data Encodings
* binhex: binhex --- Encode and decode binhex4 files. Encode and decode binhex4 files
* binascii: binascii --- Convert between binary and ASCII. Convert between binary and ASCII
* quopri: quopri --- Encode and decode MIME quoted-printable data. Encode and decode MIME quoted-printable data
* uu: uu --- Encode and decode uuencode files. Encode and decode uuencode files


File: python.info,  Node: email --- An email and MIME handling package,  Next: json --- JSON encoder and decoder,  Up: Internet Data Handling

5.19.1 ‘email’ — An email and MIME handling package
---------------------------------------------------

The *note email: 67. package is a library for managing email messages,
including MIME and other RFC 2822(1)-based message documents.  It is
specifically `not' designed to do any sending of email messages to SMTP
( RFC 2821(2)), NNTP, or other servers; those are functions of modules
such as *note smtplib: eb. and *note nntplib: be.  The *note email: 67.
package attempts to be as RFC-compliant as possible, supporting in
addition to RFC 2822(3), such MIME-related RFCs as RFC 2045(4), RFC
2046(5), RFC 2047(6), and RFC 2231(7).

The primary distinguishing feature of the *note email: 67. package is
that it splits the parsing and generating of email messages from the
internal `object model' representation of email.  Applications using the
*note email: 67. package deal primarily with objects; you can add
sub-objects to messages, remove sub-objects from messages, completely
re-arrange the contents, etc.  There is a separate parser and a separate
generator which handles the transformation from flat text to the object
model, and then back to flat text again.  There are also handy
subclasses for some common MIME object types, and a few miscellaneous
utilities that help with such common tasks as extracting and parsing
message field values, creating RFC-compliant dates, etc.

The following sections describe the functionality of the *note email:
67. package.  The ordering follows a progression that should be common
in applications: an email message is read as flat text from a file or
other source, the text is parsed to produce the object structure of the
email message, this structure is manipulated, and finally, the object
tree is rendered back into flat text.

It is perfectly feasible to create the object structure out of whole
cloth — i.e.  completely from scratch.  From there, a similar
progression can be taken as above.

Also included are detailed specifications of all the classes and modules
that the *note email: 67. package provides, the exception classes you
might encounter while using the *note email: 67. package, some auxiliary
utilities, and a few examples.  For users of the older ‘mimelib’
package, or previous versions of the *note email: 67. package, a section
on differences and porting is provided.

Contents of the *note email: 67. package documentation:

* Menu:

* email.message; Representing an email message: email message Representing an email message. 
* email.parser; Parsing email messages: email parser Parsing email messages. 
* email.generator; Generating MIME documents: email generator Generating MIME documents. 
* email.policy; Policy Objects: email policy Policy Objects. 
* email.headerregistry; Custom Header Objects: email headerregistry Custom Header Objects. 
* email.contentmanager; Managing MIME Content: email contentmanager Managing MIME Content. 
* email.mime; Creating email and MIME objects from scratch: email mime Creating email and MIME objects from scratch. 
* email.header; Internationalized headers: email header Internationalized headers. 
* email.charset; Representing character sets: email charset Representing character sets. 
* email.encoders; Encoders: email encoders Encoders. 
* email.errors; Exception and Defect classes: email errors Exception and Defect classes. 
* email.utils; Miscellaneous utilities: email utils Miscellaneous utilities. 
* email.iterators; Iterators: email iterators Iterators. 
* email; Examples: email Examples. 
* Package History:: 
* Differences from mimelib:: 

   ---------- Footnotes ----------

   (1) https://tools.ietf.org/html/rfc2822.html

   (2) https://tools.ietf.org/html/rfc2821.html

   (3) https://tools.ietf.org/html/rfc2822.html

   (4) https://tools.ietf.org/html/rfc2045.html

   (5) https://tools.ietf.org/html/rfc2046.html

   (6) https://tools.ietf.org/html/rfc2047.html

   (7) https://tools.ietf.org/html/rfc2231.html


File: python.info,  Node: email message Representing an email message,  Next: email parser Parsing email messages,  Up: email --- An email and MIME handling package

5.19.1.1 ‘email.message’: Representing an email message
.......................................................

The central class in the *note email: 67. package is the *note Message:
3d2. class, imported from the *note email.message: 70. module.  It is
the base class for the *note email: 67. object model.  *note Message:
3d2. provides the core functionality for setting and querying header
fields, and for accessing message bodies.

Conceptually, a *note Message: 3d2. object consists of `headers' and
`payloads'.  Headers are RFC 2822(1) style field names and values where
the field name and value are separated by a colon.  The colon is not
part of either the field name or the field value.

Headers are stored and returned in case-preserving form but are matched
case-insensitively.  There may also be a single envelope header, also
known as the `Unix-From' header or the ‘From_’ header.  The payload is
either a string in the case of simple message objects or a list of *note
Message: 3d2. objects for MIME container documents (e.g.  ‘multipart/*’
and ‘message/rfc822’).

*note Message: 3d2. objects provide a mapping style interface for
accessing the message headers, and an explicit interface for accessing
both the headers and the payload.  It provides convenience methods for
generating a flat text representation of the message object tree, for
accessing commonly used header parameters, and for recursively walking
over the object tree.

Here are the methods of the *note Message: 3d2. class:

 -- Class: email.message.Message (policy=compat32)

     If `policy' is specified (it must be an instance of a *note policy:
     73. class) use the rules it specifies to update and serialize the
     representation of the message.  If `policy' is not set, use the
     *note compat32: 623. policy, which maintains backward compatibility
     with the Python 3.2 version of the email package.  For more
     information see the *note policy: 73. documentation.

     Changed in version 3.3: The `policy' keyword argument was added.

      -- Method: as_string (unixfrom=False, maxheaderlen=0, policy=None)

          Return the entire message flattened as a string.  When
          optional `unixfrom' is true, the envelope header is included
          in the returned string.  `unixfrom' defaults to ‘False’.  For
          backward compabitility reasons, `maxheaderlen' defaults to
          ‘0’, so if you want a different value you must override it
          explicitly (the value specified for `max_line_length' in the
          policy will be ignored by this method).  The `policy' argument
          may be used to override the default policy obtained from the
          message instance.  This can be used to control some of the
          formatting produced by the method, since the specified
          `policy' will be passed to the ‘Generator’.

          Flattening the message may trigger changes to the *note
          Message: 3d2. if defaults need to be filled in to complete the
          transformation to a string (for example, MIME boundaries may
          be generated or modified).

          Note that this method is provided as a convenience and may not
          always format the message the way you want.  For example, by
          default it does not do the mangling of lines that begin with
          ‘From’ that is required by the unix mbox format.  For more
          flexibility, instantiate a *note Generator: 795. instance and
          use its *note flatten(): 20a1. method directly.  For example:

               from io import StringIO
               from email.generator import Generator
               fp = StringIO()
               g = Generator(fp, mangle_from_=True, maxheaderlen=60)
               g.flatten(msg)
               text = fp.getvalue()

          If the message object contains binary data that is not encoded
          according to RFC standards, the non-compliant data will be
          replaced by unicode "unknown character" code points.  (See
          also *note as_bytes(): 432. and *note BytesGenerator: 796.)

          Changed in version 3.4: the `policy' keyword argument was
          added.

      -- Method: __str__ ()

          Equivalent to *note as_string(): 431.  Allows ‘str(msg)’ to
          produce a string containing the formatted message.

      -- Method: as_bytes (unixfrom=False, policy=None)

          Return the entire message flattened as a bytes object.  When
          optional `unixfrom' is true, the envelope header is included
          in the returned string.  `unixfrom' defaults to ‘False’.  The
          `policy' argument may be used to override the default policy
          obtained from the message instance.  This can be used to
          control some of the formatting produced by the method, since
          the specified `policy' will be passed to the ‘BytesGenerator’.

          Flattening the message may trigger changes to the *note
          Message: 3d2. if defaults need to be filled in to complete the
          transformation to a string (for example, MIME boundaries may
          be generated or modified).

          Note that this method is provided as a convenience and may not
          always format the message the way you want.  For example, by
          default it does not do the mangling of lines that begin with
          ‘From’ that is required by the unix mbox format.  For more
          flexibility, instantiate a *note BytesGenerator: 796. instance
          and use its *note flatten(): 20a3. method directly.  For
          example:

               from io import BytesIO
               from email.generator import BytesGenerator
               fp = BytesIO()
               g = BytesGenerator(fp, mangle_from_=True, maxheaderlen=60)
               g.flatten(msg)
               text = fp.getvalue()

          New in version 3.4.

      -- Method: __bytes__ ()

          Equivalent to *note as_bytes(): 432.  Allows ‘bytes(msg)’ to
          produce a bytes object containing the formatted message.

          New in version 3.4.

      -- Method: is_multipart ()

          Return ‘True’ if the message’s payload is a list of sub-*note
          Message: 3d2. objects, otherwise return ‘False’.  When *note
          is_multipart(): 20a4. returns ‘False’, the payload should be a
          string object.  (Note that *note is_multipart(): 20a4.
          returning ‘True’ does not necessarily mean that
          "msg.get_content_maintype() == ’multipart’" will return the
          ‘True’.  For example, ‘is_multipart’ will return ‘True’ when
          the *note Message: 3d2. is of type ‘message/rfc822’.)

      -- Method: set_unixfrom (unixfrom)

          Set the message’s envelope header to `unixfrom', which should
          be a string.

      -- Method: get_unixfrom ()

          Return the message’s envelope header.  Defaults to ‘None’ if
          the envelope header was never set.

      -- Method: attach (payload)

          Add the given `payload' to the current payload, which must be
          ‘None’ or a list of *note Message: 3d2. objects before the
          call.  After the call, the payload will always be a list of
          *note Message: 3d2. objects.  If you want to set the payload
          to a scalar object (e.g.  a string), use *note set_payload():
          20a8. instead.

      -- Method: get_payload (i=None, decode=False)

          Return the current payload, which will be a list of *note
          Message: 3d2. objects when *note is_multipart(): 20a4. is
          ‘True’, or a string when *note is_multipart(): 20a4. is
          ‘False’.  If the payload is a list and you mutate the list
          object, you modify the message’s payload in place.

          With optional argument `i', *note get_payload(): 794. will
          return the `i'-th element of the payload, counting from zero,
          if *note is_multipart(): 20a4. is ‘True’.  An *note
          IndexError: afb. will be raised if `i' is less than 0 or
          greater than or equal to the number of items in the payload.
          If the payload is a string (i.e.  *note is_multipart(): 20a4.
          is ‘False’) and `i' is given, a *note TypeError: 562. is
          raised.

          Optional `decode' is a flag indicating whether the payload
          should be decoded or not, according to the
          ‘Content-Transfer-Encoding’ header.  When ‘True’ and the
          message is not a multipart, the payload will be decoded if
          this header’s value is ‘quoted-printable’ or ‘base64’.  If
          some other encoding is used, or ‘Content-Transfer-Encoding’
          header is missing, the payload is returned as-is (undecoded).
          In all cases the returned value is binary data.  If the
          message is a multipart and the `decode' flag is ‘True’, then
          ‘None’ is returned.  If the payload is base64 and it was not
          perfectly formed (missing padding, characters outside the
          base64 alphabet), then an appropriate defect will be added to
          the message’s defect property (‘InvalidBase64PaddingDefect’ or
          ‘InvalidBase64CharactersDefect’, respectively).

          When `decode' is ‘False’ (the default) the body is returned as
          a string without decoding the ‘Content-Transfer-Encoding’.
          However, for a ‘Content-Transfer-Encoding’ of 8bit, an attempt
          is made to decode the original bytes using the ‘charset’
          specified by the ‘Content-Type’ header, using the ‘replace’
          error handler.  If no ‘charset’ is specified, or if the
          ‘charset’ given is not recognized by the email package, the
          body is decoded using the default ASCII charset.

      -- Method: set_payload (payload, charset=None)

          Set the entire message object’s payload to `payload'.  It is
          the client’s responsibility to ensure the payload invariants.
          Optional `charset' sets the message’s default character set;
          see *note set_charset(): 20a9. for details.

      -- Method: set_charset (charset)

          Set the character set of the payload to `charset', which can
          either be a *note Charset: 284. instance (see *note
          email.charset: 68.), a string naming a character set, or
          ‘None’.  If it is a string, it will be converted to a *note
          Charset: 284. instance.  If `charset' is ‘None’, the ‘charset’
          parameter will be removed from the ‘Content-Type’ header (the
          message will not be otherwise modified).  Anything else will
          generate a *note TypeError: 562.

          If there is no existing ‘MIME-Version’ header one will be
          added.  If there is no existing ‘Content-Type’ header, one
          will be added with a value of ‘text/plain’.  Whether the
          ‘Content-Type’ header already exists or not, its ‘charset’
          parameter will be set to `charset.output_charset'.  If
          `charset.input_charset' and `charset.output_charset' differ,
          the payload will be re-encoded to the `output_charset'.  If
          there is no existing ‘Content-Transfer-Encoding’ header, then
          the payload will be transfer-encoded, if needed, using the
          specified *note Charset: 284, and a header with the
          appropriate value will be added.  If a
          ‘Content-Transfer-Encoding’ header already exists, the payload
          is assumed to already be correctly encoded using that
          ‘Content-Transfer-Encoding’ and is not modified.

      -- Method: get_charset ()

          Return the *note Charset: 284. instance associated with the
          message’s payload.

     The following methods implement a mapping-like interface for
     accessing the message’s RFC 2822(2) headers.  Note that there are
     some semantic differences between these methods and a normal
     mapping (i.e.  dictionary) interface.  For example, in a dictionary
     there are no duplicate keys, but here there may be duplicate
     message headers.  Also, in dictionaries there is no guaranteed
     order to the keys returned by *note keys(): 20ab, but in a *note
     Message: 3d2. object, headers are always returned in the order they
     appeared in the original message, or were added to the message
     later.  Any header deleted and then re-added are always appended to
     the end of the header list.

     These semantic differences are intentional and are biased toward
     maximal convenience.

     Note that in all cases, any envelope header present in the message
     is not included in the mapping interface.

     In a model generated from bytes, any header values that (in
     contravention of the RFCs) contain non-ASCII bytes will, when
     retrieved through this interface, be represented as *note Header:
     20ac. objects with a charset of ‘unknown-8bit’.

      -- Method: __len__ ()

          Return the total number of headers, including duplicates.

      -- Method: __contains__ (name)

          Return true if the message object has a field named `name'.
          Matching is done case-insensitively and `name' should not
          include the trailing colon.  Used for the ‘in’ operator, e.g.:

               if 'message-id' in myMessage:
                  print('Message-ID:', myMessage['message-id'])

      -- Method: __getitem__ (name)

          Return the value of the named header field.  `name' should not
          include the colon field separator.  If the header is missing,
          ‘None’ is returned; a *note KeyError: 1a7. is never raised.

          Note that if the named field appears more than once in the
          message’s headers, exactly which of those field values will be
          returned is undefined.  Use the *note get_all(): 20b0. method
          to get the values of all the extant named headers.

      -- Method: __setitem__ (name, val)

          Add a header to the message with field name `name' and value
          `val'.  The field is appended to the end of the message’s
          existing fields.

          Note that this does `not' overwrite or delete any existing
          header with the same name.  If you want to ensure that the new
          header is the only one present in the message with field name
          `name', delete the field first, e.g.:

               del msg['subject']
               msg['subject'] = 'Python roolz!'

      -- Method: __delitem__ (name)

          Delete all occurrences of the field with name `name' from the
          message’s headers.  No exception is raised if the named field
          isn’t present in the headers.

      -- Method: keys ()

          Return a list of all the message’s header field names.

      -- Method: values ()

          Return a list of all the message’s field values.

      -- Method: items ()

          Return a list of 2-tuples containing all the message’s field
          headers and values.

      -- Method: get (name, failobj=None)

          Return the value of the named header field.  This is identical
          to *note __getitem__(): 20af. except that optional `failobj'
          is returned if the named header is missing (defaults to
          ‘None’).

     Here are some additional useful methods:

      -- Method: get_all (name, failobj=None)

          Return a list of all the values for the field named `name'.
          If there are no such named headers in the message, `failobj'
          is returned (defaults to ‘None’).

      -- Method: add_header (_name, _value, **_params)

          Extended header setting.  This method is similar to *note
          __setitem__(): 20b1. except that additional header parameters
          can be provided as keyword arguments.  `_name' is the header
          field to add and `_value' is the `primary' value for the
          header.

          For each item in the keyword argument dictionary `_params',
          the key is taken as the parameter name, with underscores
          converted to dashes (since dashes are illegal in Python
          identifiers).  Normally, the parameter will be added as
          ‘key="value"’ unless the value is ‘None’, in which case only
          the key will be added.  If the value contains non-ASCII
          characters, it can be specified as a three tuple in the format
          ‘(CHARSET, LANGUAGE, VALUE)’, where ‘CHARSET’ is a string
          naming the charset to be used to encode the value, ‘LANGUAGE’
          can usually be set to ‘None’ or the empty string (see RFC
          2231(3) for other possibilities), and ‘VALUE’ is the string
          value containing non-ASCII code points.  If a three tuple is
          not passed and the value contains non-ASCII characters, it is
          automatically encoded in RFC 2231(4) format using a ‘CHARSET’
          of ‘utf-8’ and a ‘LANGUAGE’ of ‘None’.

          Here’s an example:

               msg.add_header('Content-Disposition', 'attachment', filename='bud.gif')

          This will add a header that looks like

               Content-Disposition: attachment; filename="bud.gif"

          An example with non-ASCII characters:

               msg.add_header('Content-Disposition', 'attachment',
                              filename=('iso-8859-1', '', 'Fußballer.ppt'))

          Which produces

               Content-Disposition: attachment; filename*="iso-8859-1''Fu%DFballer.ppt"

      -- Method: replace_header (_name, _value)

          Replace a header.  Replace the first header found in the
          message that matches `_name', retaining header order and field
          name case.  If no matching header was found, a *note KeyError:
          1a7. is raised.

      -- Method: get_content_type ()

          Return the message’s content type.  The returned string is
          coerced to lower case of the form ‘maintype/subtype’.  If
          there was no ‘Content-Type’ header in the message the default
          type as given by *note get_default_type(): 20b9. will be
          returned.  Since according to RFC 2045(5), messages always
          have a default type, *note get_content_type(): 20b8. will
          always return a value.

          RFC 2045(6) defines a message’s default type to be
          ‘text/plain’ unless it appears inside a ‘multipart/digest’
          container, in which case it would be ‘message/rfc822’.  If the
          ‘Content-Type’ header has an invalid type specification, RFC
          2045(7) mandates that the default type be ‘text/plain’.

      -- Method: get_content_maintype ()

          Return the message’s main content type.  This is the
          ‘maintype’ part of the string returned by *note
          get_content_type(): 20b8.

      -- Method: get_content_subtype ()

          Return the message’s sub-content type.  This is the ‘subtype’
          part of the string returned by *note get_content_type(): 20b8.

      -- Method: get_default_type ()

          Return the default content type.  Most messages have a default
          content type of ‘text/plain’, except for messages that are
          subparts of ‘multipart/digest’ containers.  Such subparts have
          a default content type of ‘message/rfc822’.

      -- Method: set_default_type (ctype)

          Set the default content type.  `ctype' should either be
          ‘text/plain’ or ‘message/rfc822’, although this is not
          enforced.  The default content type is not stored in the
          ‘Content-Type’ header.

      -- Method: get_params (failobj=None, header='content-type',
               unquote=True)

          Return the message’s ‘Content-Type’ parameters, as a list.
          The elements of the returned list are 2-tuples of key/value
          pairs, as split on the ‘'='’ sign.  The left hand side of the
          ‘'='’ is the key, while the right hand side is the value.  If
          there is no ‘'='’ sign in the parameter the value is the empty
          string, otherwise the value is as described in *note
          get_param(): 20be. and is unquoted if optional `unquote' is
          ‘True’ (the default).

          Optional `failobj' is the object to return if there is no
          ‘Content-Type’ header.  Optional `header' is the header to
          search instead of ‘Content-Type’.

      -- Method: get_param (param, failobj=None, header='content-type',
               unquote=True)

          Return the value of the ‘Content-Type’ header’s parameter
          `param' as a string.  If the message has no ‘Content-Type’
          header or if there is no such parameter, then `failobj' is
          returned (defaults to ‘None’).

          Optional `header' if given, specifies the message header to
          use instead of ‘Content-Type’.

          Parameter keys are always compared case insensitively.  The
          return value can either be a string, or a 3-tuple if the
          parameter was RFC 2231(8) encoded.  When it’s a 3-tuple, the
          elements of the value are of the form ‘(CHARSET, LANGUAGE,
          VALUE)’.  Note that both ‘CHARSET’ and ‘LANGUAGE’ can be
          ‘None’, in which case you should consider ‘VALUE’ to be
          encoded in the ‘us-ascii’ charset.  You can usually ignore
          ‘LANGUAGE’.

          If your application doesn’t care whether the parameter was
          encoded as in RFC 2231(9), you can collapse the parameter
          value by calling *note email.utils.collapse_rfc2231_value():
          20bf, passing in the return value from *note get_param():
          20be.  This will return a suitably decoded Unicode string when
          the value is a tuple, or the original string unquoted if it
          isn’t.  For example:

               rawparam = msg.get_param('foo')
               param = email.utils.collapse_rfc2231_value(rawparam)

          In any case, the parameter value (either the returned string,
          or the ‘VALUE’ item in the 3-tuple) is always unquoted, unless
          `unquote' is set to ‘False’.

      -- Method: set_param (param, value, header='Content-Type',
               requote=True, charset=None, language='', replace=False)

          Set a parameter in the ‘Content-Type’ header.  If the
          parameter already exists in the header, its value will be
          replaced with `value'.  If the ‘Content-Type’ header as not
          yet been defined for this message, it will be set to
          ‘text/plain’ and the new parameter value will be appended as
          per RFC 2045(10).

          Optional `header' specifies an alternative header to
          ‘Content-Type’, and all parameters will be quoted as necessary
          unless optional `requote' is ‘False’ (the default is ‘True’).

          If optional `charset' is specified, the parameter will be
          encoded according to RFC 2231(11).  Optional `language'
          specifies the RFC 2231 language, defaulting to the empty
          string.  Both `charset' and `language' should be strings.

          If `replace' is ‘False’ (the default) the header is moved to
          the end of the list of headers.  If `replace' is ‘True’, the
          header will be updated in place.

          Changed in version 3.4: ‘replace’ keyword was added.

      -- Method: del_param (param, header='content-type', requote=True)

          Remove the given parameter completely from the ‘Content-Type’
          header.  The header will be re-written in place without the
          parameter or its value.  All values will be quoted as
          necessary unless `requote' is ‘False’ (the default is ‘True’).
          Optional `header' specifies an alternative to ‘Content-Type’.

      -- Method: set_type (type, header='Content-Type', requote=True)

          Set the main type and subtype for the ‘Content-Type’ header.
          `type' must be a string in the form ‘maintype/subtype’,
          otherwise a *note ValueError: 19c. is raised.

          This method replaces the ‘Content-Type’ header, keeping all
          the parameters in place.  If `requote' is ‘False’, this leaves
          the existing header’s quoting as is, otherwise the parameters
          will be quoted (the default).

          An alternative header can be specified in the `header'
          argument.  When the ‘Content-Type’ header is set a
          ‘MIME-Version’ header is also added.

      -- Method: get_filename (failobj=None)

          Return the value of the ‘filename’ parameter of the
          ‘Content-Disposition’ header of the message.  If the header
          does not have a ‘filename’ parameter, this method falls back
          to looking for the ‘name’ parameter on the ‘Content-Type’
          header.  If neither is found, or the header is missing, then
          `failobj' is returned.  The returned string will always be
          unquoted as per *note email.utils.unquote(): 20c3.

      -- Method: get_boundary (failobj=None)

          Return the value of the ‘boundary’ parameter of the
          ‘Content-Type’ header of the message, or `failobj' if either
          the header is missing, or has no ‘boundary’ parameter.  The
          returned string will always be unquoted as per *note
          email.utils.unquote(): 20c3.

      -- Method: set_boundary (boundary)

          Set the ‘boundary’ parameter of the ‘Content-Type’ header to
          `boundary'.  *note set_boundary(): 20c5. will always quote
          `boundary' if necessary.  A *note HeaderParseError: 20c6. is
          raised if the message object has no ‘Content-Type’ header.

          Note that using this method is subtly different than deleting
          the old ‘Content-Type’ header and adding a new one with the
          new boundary via *note add_header(): 20b6, because *note
          set_boundary(): 20c5. preserves the order of the
          ‘Content-Type’ header in the list of headers.  However, it
          does `not' preserve any continuation lines which may have been
          present in the original ‘Content-Type’ header.

      -- Method: get_content_charset (failobj=None)

          Return the ‘charset’ parameter of the ‘Content-Type’ header,
          coerced to lower case.  If there is no ‘Content-Type’ header,
          or if that header has no ‘charset’ parameter, `failobj' is
          returned.

          Note that this method differs from *note get_charset(): 20aa.
          which returns the *note Charset: 284. instance for the default
          encoding of the message body.

      -- Method: get_charsets (failobj=None)

          Return a list containing the character set names in the
          message.  If the message is a ‘multipart’, then the list will
          contain one element for each subpart in the payload,
          otherwise, it will be a list of length 1.

          Each item in the list will be a string which is the value of
          the ‘charset’ parameter in the ‘Content-Type’ header for the
          represented subpart.  However, if the subpart has no
          ‘Content-Type’ header, no ‘charset’ parameter, or is not of
          the ‘text’ main MIME type, then that item in the returned list
          will be `failobj'.

      -- Method: get_content_disposition ()

          Return the lowercased value (without parameters) of the
          message’s ‘Content-Disposition’ header if it has one, or
          ‘None’.  The possible values for this method are `inline',
          `attachment' or ‘None’ if the message follows RFC 2183(12).

          New in version 3.5.

      -- Method: walk ()

          The *note walk(): 20c9. method is an all-purpose generator
          which can be used to iterate over all the parts and subparts
          of a message object tree, in depth-first traversal order.  You
          will typically use *note walk(): 20c9. as the iterator in a
          ‘for’ loop; each iteration returns the next subpart.

          Here’s an example that prints the MIME type of every part of a
          multipart message structure:

               >>> for part in msg.walk():
               ...     print(part.get_content_type())
               multipart/report
               text/plain
               message/delivery-status
               text/plain
               text/plain
               message/rfc822
               text/plain

          ‘walk’ iterates over the subparts of any part where *note
          is_multipart(): 20a4. returns ‘True’, even though
          ‘msg.get_content_maintype() == 'multipart'’ may return
          ‘False’.  We can see this in our example by making use of the
          ‘_structure’ debug helper function:

               >>> for part in msg.walk():
               ...     print(part.get_content_maintype() == 'multipart'),
               ...           part.is_multipart())
               True True
               False False
               False True
               False False
               False False
               False True
               False False
               >>> _structure(msg)
               multipart/report
                   text/plain
               message/delivery-status
                   text/plain
                   text/plain
               message/rfc822
                   text/plain

          Here the ‘message’ parts are not ‘multiparts’, but they do
          contain subparts.  ‘is_multipart()’ returns ‘True’ and ‘walk’
          descends into the subparts.

     *note Message: 3d2. objects can also optionally contain two
     instance attributes, which can be used when generating the plain
     text of a MIME message.

      -- Attribute: preamble

          The format of a MIME document allows for some text between the
          blank line following the headers, and the first multipart
          boundary string.  Normally, this text is never visible in a
          MIME-aware mail reader because it falls outside the standard
          MIME armor.  However, when viewing the raw text of the
          message, or when viewing the message in a non-MIME aware
          reader, this text can become visible.

          The `preamble' attribute contains this leading extra-armor
          text for MIME documents.  When the *note Parser: 75a.
          discovers some text after the headers but before the first
          boundary string, it assigns this text to the message’s
          `preamble' attribute.  When the *note Generator: 795. is
          writing out the plain text representation of a MIME message,
          and it finds the message has a `preamble' attribute, it will
          write this text in the area between the headers and the first
          boundary.  See *note email.parser: 72. and *note
          email.generator: 6c. for details.

          Note that if the message object has no preamble, the
          `preamble' attribute will be ‘None’.

      -- Attribute: epilogue

          The `epilogue' attribute acts the same way as the `preamble'
          attribute, except that it contains text that appears between
          the last boundary and the end of the message.

          You do not need to set the epilogue to the empty string in
          order for the *note Generator: 795. to print a newline at the
          end of the file.

      -- Attribute: defects

          The `defects' attribute contains a list of all the problems
          found when parsing this message.  See *note email.errors: 6b.
          for a detailed description of the possible parsing defects.

   ---------- Footnotes ----------

   (1) https://tools.ietf.org/html/rfc2822.html

   (2) https://tools.ietf.org/html/rfc2822.html

   (3) https://tools.ietf.org/html/rfc2231.html

   (4) https://tools.ietf.org/html/rfc2231.html

   (5) https://tools.ietf.org/html/rfc2045.html

   (6) https://tools.ietf.org/html/rfc2045.html

   (7) https://tools.ietf.org/html/rfc2045.html

   (8) https://tools.ietf.org/html/rfc2231.html

   (9) https://tools.ietf.org/html/rfc2231.html

   (10) https://tools.ietf.org/html/rfc2045.html

   (11) https://tools.ietf.org/html/rfc2231.html

   (12) https://tools.ietf.org/html/rfc2183.html


File: python.info,  Node: email parser Parsing email messages,  Next: email generator Generating MIME documents,  Prev: email message Representing an email message,  Up: email --- An email and MIME handling package

5.19.1.2 ‘email.parser’: Parsing email messages
...............................................

Message object structures can be created in one of two ways: they can be
created from whole cloth by instantiating *note Message: 3d2. objects
and stringing them together via *note attach(): 20a7. and *note
set_payload(): 20a8. calls, or they can be created by parsing a flat
text representation of the email message.

The *note email: 67. package provides a standard parser that understands
most email document structures, including MIME documents.  You can pass
the parser a string or a file object, and the parser will return to you
the root *note Message: 3d2. instance of the object structure.  For
simple, non-MIME messages the payload of this root object will likely be
a string containing the text of the message.  For MIME messages, the
root object will return ‘True’ from its *note is_multipart(): 20a4.
method, and the subparts can be accessed via the *note get_payload():
794. and *note walk(): 20c9. methods.

There are actually two parser interfaces available for use, the classic
*note Parser: 75a. API and the incremental *note FeedParser: 20cf. API.
The classic *note Parser: 75a. API is fine if you have the entire text
of the message in memory as a string, or if the entire message lives in
a file on the file system.  *note FeedParser: 20cf. is more appropriate
for when you’re reading the message from a stream which might block
waiting for more input (e.g.  reading an email message from a socket).
The *note FeedParser: 20cf. can consume and parse the message
incrementally, and only returns the root object when you close the
parser (1).

Note that the parser can be extended in limited ways, and of course you
can implement your own parser completely from scratch.  There is no
magical connection between the *note email: 67. package’s bundled parser
and the *note Message: 3d2. class, so your custom parser can create
message object trees any way it finds necessary.

* Menu:

* FeedParser API:: 
* Parser class API:: 
* Additional notes:: 

   ---------- Footnotes ----------

   (1) As of email package version 3.0, introduced in Python 2.4, the
classic *note Parser: 75a. was re-implemented in terms of the *note
FeedParser: 20cf, so the semantics and results are identical between the
two parsers.


File: python.info,  Node: FeedParser API,  Next: Parser class API,  Up: email parser Parsing email messages

5.19.1.3 FeedParser API
.......................

The *note FeedParser: 20cf, imported from the ‘email.feedparser’ module,
provides an API that is conducive to incremental parsing of email
messages, such as would be necessary when reading the text of an email
message from a source that can block (e.g.  a socket).  The *note
FeedParser: 20cf. can of course be used to parse an email message fully
contained in a string or a file, but the classic *note Parser: 75a. API
may be more convenient for such use cases.  The semantics and results of
the two parser APIs are identical.

The *note FeedParser: 20cf.’s API is simple; you create an instance,
feed it a bunch of text until there’s no more to feed it, then close the
parser to retrieve the root message object.  The *note FeedParser: 20cf.
is extremely accurate when parsing standards-compliant messages, and it
does a very good job of parsing non-compliant messages, providing
information about how a message was deemed broken.  It will populate a
message object’s `defects' attribute with a list of any problems it
found in a message.  See the *note email.errors: 6b. module for the list
of defects that it can find.

Here is the API for the *note FeedParser: 20cf.:

 -- Class: email.parser.FeedParser (_factory=email.message.Message, *,
          policy=policy.compat32)

     Create a *note FeedParser: 20cf. instance.  Optional `_factory' is
     a no-argument callable that will be called whenever a new message
     object is needed.  It defaults to the *note email.message.Message:
     3d2. class.

     If `policy' is specified (it must be an instance of a *note policy:
     73. class) use the rules it specifies to update the representation
     of the message.  If `policy' is not set, use the *note compat32:
     623. policy, which maintains backward compatibility with the Python
     3.2 version of the email package.  For more information see the
     *note policy: 73. documentation.

     Changed in version 3.3: Added the `policy' keyword.

      -- Method: feed (data)

          Feed the *note FeedParser: 20cf. some more data.  `data'
          should be a string containing one or more lines.  The lines
          can be partial and the *note FeedParser: 20cf. will stitch
          such partial lines together properly.  The lines in the string
          can have any of the common three line endings, carriage
          return, newline, or carriage return and newline (they can even
          be mixed).

      -- Method: close ()

          Closing a *note FeedParser: 20cf. completes the parsing of all
          previously fed data, and returns the root message object.  It
          is undefined what happens if you feed more data to a closed
          *note FeedParser: 20cf.

 -- Class: email.parser.BytesFeedParser (_factory=email.message.Message)

     Works exactly like *note FeedParser: 20cf. except that the input to
     the *note feed(): 20d1. method must be bytes and not string.

     New in version 3.2.


File: python.info,  Node: Parser class API,  Next: Additional notes,  Prev: FeedParser API,  Up: email parser Parsing email messages

5.19.1.4 Parser class API
.........................

The *note Parser: 75a. class, imported from the *note email.parser: 72.
module, provides an API that can be used to parse a message when the
complete contents of the message are available in a string or file.  The
*note email.parser: 72. module also provides header-only parsers, called
‘HeaderParser’ and ‘BytesHeaderParser’, which can be used if you’re only
interested in the headers of the message.  ‘HeaderParser’ and
‘BytesHeaderParser’ can be much faster in these situations, since they
do not attempt to parse the message body, instead setting the payload to
the raw body as a string.  They have the same API as the *note Parser:
75a. and *note BytesParser: 793. classes.

New in version 3.3: The BytesHeaderParser class.

 -- Class: email.parser.Parser (_class=email.message.Message, *,
          policy=policy.compat32)

     The constructor for the *note Parser: 75a. class takes an optional
     argument `_class'.  This must be a callable factory (such as a
     function or a class), and it is used whenever a sub-message object
     needs to be created.  It defaults to *note Message: 3d2. (see *note
     email.message: 70.).  The factory will be called without arguments.

     If `policy' is specified (it must be an instance of a *note policy:
     73. class) use the rules it specifies to update the representation
     of the message.  If `policy' is not set, use the *note compat32:
     623. policy, which maintains backward compatibility with the Python
     3.2 version of the email package.  For more information see the
     *note policy: 73. documentation.

     Changed in version 3.3: Removed the `strict' argument that was
     deprecated in 2.4.  Added the `policy' keyword.

     The other public *note Parser: 75a. methods are:

      -- Method: parse (fp, headersonly=False)

          Read all the data from the file-like object `fp', parse the
          resulting text, and return the root message object.  `fp' must
          support both the *note readline(): faa. and the *note read():
          1966. methods on file-like objects.

          The text contained in `fp' must be formatted as a block of RFC
          2822(1) style headers and header continuation lines,
          optionally preceded by an envelope header.  The header block
          is terminated either by the end of the data or by a blank
          line.  Following the header block is the body of the message
          (which may contain MIME-encoded subparts).

          Optional `headersonly' is a flag specifying whether to stop
          parsing after reading the headers or not.  The default is
          ‘False’, meaning it parses the entire contents of the file.

      -- Method: parsestr (text, headersonly=False)

          Similar to the *note parse(): 20d4. method, except it takes a
          string object instead of a file-like object.  Calling this
          method on a string is exactly equivalent to wrapping `text' in
          a *note StringIO: 41e. instance first and calling *note
          parse(): 20d4.

          Optional `headersonly' is as with the *note parse(): 20d4.
          method.

 -- Class: email.parser.BytesParser (_class=email.message.Message, *,
          policy=policy.compat32)

     This class is exactly parallel to *note Parser: 75a, but handles
     bytes input.  The `_class' and `strict' arguments are interpreted
     in the same way as for the *note Parser: 75a. constructor.

     If `policy' is specified (it must be an instance of a *note policy:
     73. class) use the rules it specifies to update the representation
     of the message.  If `policy' is not set, use the *note compat32:
     623. policy, which maintains backward compatibility with the Python
     3.2 version of the email package.  For more information see the
     *note policy: 73. documentation.

     Changed in version 3.3: Removed the `strict' argument.  Added the
     `policy' keyword.

      -- Method: parse (fp, headersonly=False)

          Read all the data from the binary file-like object `fp', parse
          the resulting bytes, and return the message object.  `fp' must
          support both the *note readline(): 10b8. and the ‘read()’
          methods on file-like objects.

          The bytes contained in `fp' must be formatted as a block of
          RFC 2822(2) style headers and header continuation lines,
          optionally preceded by an envelope header.  The header block
          is terminated either by the end of the data or by a blank
          line.  Following the header block is the body of the message
          (which may contain MIME-encoded subparts, including subparts
          with a ‘Content-Transfer-Encoding’ of ‘8bit’.

          Optional `headersonly' is a flag specifying whether to stop
          parsing after reading the headers or not.  The default is
          ‘False’, meaning it parses the entire contents of the file.

      -- Method: parsebytes (bytes, headersonly=False)

          Similar to the *note parse(): 20d6. method, except it takes a
          byte string object instead of a file-like object.  Calling
          this method on a byte string is exactly equivalent to wrapping
          `text' in a *note BytesIO: 371. instance first and calling
          *note parse(): 20d6.

          Optional `headersonly' is as with the *note parse(): 20d6.
          method.

     New in version 3.2.

Since creating a message object structure from a string or a file object
is such a common task, four functions are provided as a convenience.
They are available in the top-level *note email: 67. package namespace.

 -- Function: email.message_from_string (s,
          _class=email.message.Message, *, policy=policy.compat32)

     Return a message object structure from a string.  This is exactly
     equivalent to ‘Parser().parsestr(s)’.  `_class' and `policy' are
     interpreted as with the *note Parser: 75a. class constructor.

     Changed in version 3.3: Removed the `strict' argument.  Added the
     `policy' keyword.

 -- Function: email.message_from_bytes (s, _class=email.message.Message,
          *, policy=policy.compat32)

     Return a message object structure from a byte string.  This is
     exactly equivalent to ‘BytesParser().parsebytes(s)’.  Optional
     `_class' and `strict' are interpreted as with the *note Parser:
     75a. class constructor.

     New in version 3.2.

     Changed in version 3.3: Removed the `strict' argument.  Added the
     `policy' keyword.

 -- Function: email.message_from_file (fp, _class=email.message.Message,
          *, policy=policy.compat32)

     Return a message object structure tree from an open *note file
     object: 78b.  This is exactly equivalent to ‘Parser().parse(fp)’.
     `_class' and `policy' are interpreted as with the *note Parser:
     75a. class constructor.

     Changed in version Removed: the `strict' argument.  Added the
     `policy' keyword.

 -- Function: email.message_from_binary_file (fp,
          _class=email.message.Message, *, policy=policy.compat32)

     Return a message object structure tree from an open binary *note
     file object: 78b.  This is exactly equivalent to
     ‘BytesParser().parse(fp)’.  `_class' and `policy' are interpreted
     as with the *note Parser: 75a. class constructor.

     New in version 3.2.

     Changed in version 3.3: Removed the `strict' argument.  Added the
     `policy' keyword.

Here’s an example of how you might use this at an interactive Python
prompt:

     >>> import email
     >>> msg = email.message_from_string(myString)  # doctest: +SKIP

   ---------- Footnotes ----------

   (1) https://tools.ietf.org/html/rfc2822.html

   (2) https://tools.ietf.org/html/rfc2822.html


File: python.info,  Node: Additional notes,  Prev: Parser class API,  Up: email parser Parsing email messages

5.19.1.5 Additional notes
.........................

Here are some notes on the parsing semantics:

   * Most non-‘multipart’ type messages are parsed as a single message
     object with a string payload.  These objects will return ‘False’
     for *note is_multipart(): 20a4.  Their *note get_payload(): 794.
     method will return a string object.

   * All ‘multipart’ type messages will be parsed as a container message
     object with a list of sub-message objects for their payload.  The
     outer container message will return ‘True’ for *note
     is_multipart(): 20a4. and their *note get_payload(): 794. method
     will return the list of *note Message: 3d2. subparts.

   * Most messages with a content type of ‘message/*’ (e.g.
     ‘message/delivery-status’ and ‘message/rfc822’) will also be parsed
     as container object containing a list payload of length 1.  Their
     *note is_multipart(): 20a4. method will return ‘True’.  The single
     element in the list payload will be a sub-message object.

   * Some non-standards compliant messages may not be internally
     consistent about their ‘multipart’-edness.  Such messages may have
     a ‘Content-Type’ header of type ‘multipart’, but their *note
     is_multipart(): 20a4. method may return ‘False’.  If such messages
     were parsed with the *note FeedParser: 20cf, they will have an
     instance of the ‘MultipartInvariantViolationDefect’ class in their
     `defects' attribute list.  See *note email.errors: 6b. for details.


File: python.info,  Node: email generator Generating MIME documents,  Next: email policy Policy Objects,  Prev: email parser Parsing email messages,  Up: email --- An email and MIME handling package

5.19.1.6 ‘email.generator’: Generating MIME documents
.....................................................

One of the most common tasks is to generate the flat text of the email
message represented by a message object structure.  You will need to do
this if you want to send your message via the *note smtplib: eb. module
or the *note nntplib: be. module, or print the message on the console.
Taking a message object structure and producing a flat text document is
the job of the *note Generator: 795. class.

Again, as with the *note email.parser: 72. module, you aren’t limited to
the functionality of the bundled generator; you could write one from
scratch yourself.  However the bundled generator knows how to generate
most email in a standards-compliant way, should handle MIME and non-MIME
email messages just fine, and is designed so that the transformation
from flat text, to a message structure via the *note Parser: 75a. class,
and back to flat text, is idempotent (the input is identical to the
output) (1).  On the other hand, using the Generator on a *note Message:
3d2. constructed by program may result in changes to the *note Message:
3d2. object as defaults are filled in.

*note bytes: 1db. output can be generated using the *note
BytesGenerator: 796. class.  If the message object structure contains
non-ASCII bytes, this generator’s *note flatten(): 20a3. method will
emit the original bytes.  Parsing a binary message and then flattening
it with *note BytesGenerator: 796. should be idempotent for standards
compliant messages.

Here are the public methods of the *note Generator: 795. class, imported
from the *note email.generator: 6c. module:

 -- Class: email.generator.Generator (outfp, mangle_from_=True,
          maxheaderlen=78, *, policy=None)

     The constructor for the *note Generator: 795. class takes a *note
     file-like object: 160e. called `outfp' for an argument.  `outfp'
     must support the *note write(): 20dd. method and be usable as the
     output file for the *note print(): 481. function.

     Optional `mangle_from_' is a flag that, when ‘True’, puts a ‘>’
     character in front of any line in the body that starts exactly as
     ‘From’, i.e.  ‘From’ followed by a space at the beginning of the
     line.  This is the only guaranteed portable way to avoid having
     such lines be mistaken for a Unix mailbox format envelope header
     separator (see WHY THE CONTENT-LENGTH FORMAT IS BAD(2) for
     details).  `mangle_from_' defaults to ‘True’, but you might want to
     set this to ‘False’ if you are not writing Unix mailbox format
     files.

     Optional `maxheaderlen' specifies the longest length for a
     non-continued header.  When a header line is longer than
     `maxheaderlen' (in characters, with tabs expanded to 8 spaces), the
     header will be split as defined in the *note Header: 20ac. class.
     Set to zero to disable header wrapping.  The default is 78, as
     recommended (but not required) by RFC 2822(3).

     The `policy' keyword specifies a *note policy: 73. object that
     controls a number of aspects of the generator’s operation.  If no
     `policy' is specified, then the `policy' attached to the message
     object passed to *note flatten: 20a1. is used.

     Changed in version 3.3: Added the `policy' keyword.

     The other public *note Generator: 795. methods are:

      -- Method: flatten (msg, unixfrom=False, linesep=None)

          Print the textual representation of the message object
          structure rooted at `msg' to the output file specified when
          the *note Generator: 795. instance was created.  Subparts are
          visited depth-first and the resulting text will be properly
          MIME encoded.

          Optional `unixfrom' is a flag that forces the printing of the
          envelope header delimiter before the first RFC 2822(4) header
          of the root message object.  If the root object has no
          envelope header, a standard one is crafted.  By default, this
          is set to ‘False’ to inhibit the printing of the envelope
          delimiter.

          Note that for subparts, no envelope header is ever printed.

          Optional `linesep' specifies the line separator character used
          to terminate lines in the output.  If specified it overrides
          the value specified by the `msg'’s or ‘Generator’’s ‘policy’.

          Because strings cannot represent non-ASCII bytes, if the
          policy that applies when ‘flatten’ is run has *note cte_type:
          20de. set to ‘8bit’, ‘Generator’ will operate as if it were
          set to ‘7bit’.  This means that messages parsed with a Bytes
          parser that have a ‘Content-Transfer-Encoding’ of ‘8bit’ will
          be converted to a use a ‘7bit’ Content-Transfer-Encoding.
          Non-ASCII bytes in the headers will be RFC 2047(5) encoded
          with a charset of ‘unknown-8bit’.

          Changed in version 3.2: Added support for re-encoding ‘8bit’
          message bodies, and the `linesep' argument.

      -- Method: clone (fp)

          Return an independent clone of this *note Generator: 795.
          instance with the exact same options.

      -- Method: write (s)

          Write the string `s' to the underlying file object, i.e.
          `outfp' passed to *note Generator: 795.’s constructor.  This
          provides just enough file-like API for *note Generator: 795.
          instances to be used in the *note print(): 481. function.

As a convenience, see the *note Message: 3d2. methods *note as_string():
431. and ‘str(aMessage)’, a.k.a.  *note __str__(): 20a2, which simplify
the generation of a formatted string representation of a message object.
For more detail, see *note email.message: 70.

 -- Class: email.generator.BytesGenerator (outfp, mangle_from_=True,
          maxheaderlen=78, *, policy=None)

     The constructor for the *note BytesGenerator: 796. class takes a
     binary *note file-like object: 160e. called `outfp' for an
     argument.  `outfp' must support a *note write(): 20e0. method that
     accepts binary data.

     Optional `mangle_from_' is a flag that, when ‘True’, puts a ‘>’
     character in front of any line in the body that starts exactly as
     ‘From’, i.e.  ‘From’ followed by a space at the beginning of the
     line.  This is the only guaranteed portable way to avoid having
     such lines be mistaken for a Unix mailbox format envelope header
     separator (see WHY THE CONTENT-LENGTH FORMAT IS BAD(6) for
     details).  `mangle_from_' defaults to ‘True’, but you might want to
     set this to ‘False’ if you are not writing Unix mailbox format
     files.

     Optional `maxheaderlen' specifies the longest length for a
     non-continued header.  When a header line is longer than
     `maxheaderlen' (in characters, with tabs expanded to 8 spaces), the
     header will be split as defined in the *note Header: 20ac. class.
     Set to zero to disable header wrapping.  The default is 78, as
     recommended (but not required) by RFC 2822(7).

     The `policy' keyword specifies a *note policy: 73. object that
     controls a number of aspects of the generator’s operation.  If no
     `policy' is specified, then the `policy' attached to the message
     object passed to *note flatten: 20a3. is used.

     Changed in version 3.3: Added the `policy' keyword.

     The other public *note BytesGenerator: 796. methods are:

      -- Method: flatten (msg, unixfrom=False, linesep=None)

          Print the textual representation of the message object
          structure rooted at `msg' to the output file specified when
          the *note BytesGenerator: 796. instance was created.  Subparts
          are visited depth-first and the resulting text will be
          properly MIME encoded.  If the *note policy: 73. option *note
          cte_type: 20de. is ‘8bit’ (the default), then any bytes with
          the high bit set in the original parsed message that have not
          been modified will be copied faithfully to the output.  If
          ‘cte_type’ is ‘7bit’, the bytes will be converted as needed
          using an ASCII-compatible Content-Transfer-Encoding.  In
          particular, RFC-invalid non-ASCII bytes in headers will be
          encoded using the MIME ‘unknown-8bit’ character set, thus
          rendering them RFC-compliant.

          Messages parsed with a Bytes parser that have a
          ‘Content-Transfer-Encoding’ of 8bit will be reconstructed as
          8bit if they have not been modified.

          Optional `unixfrom' is a flag that forces the printing of the
          envelope header delimiter before the first RFC 2822(8) header
          of the root message object.  If the root object has no
          envelope header, a standard one is crafted.  By default, this
          is set to ‘False’ to inhibit the printing of the envelope
          delimiter.

          Note that for subparts, no envelope header is ever printed.

          Optional `linesep' specifies the line separator character used
          to terminate lines in the output.  If specified it overrides
          the value specified by the ‘Generator’or `msg'’s ‘policy’.

      -- Method: clone (fp)

          Return an independent clone of this *note BytesGenerator: 796.
          instance with the exact same options.

      -- Method: write (s)

          Write the string `s' to the underlying file object.  `s' is
          encoded using the ‘ASCII’ codec and written to the `write'
          method of the `outfp' `outfp' passed to the *note
          BytesGenerator: 796.’s constructor.  This provides just enough
          file-like API for *note BytesGenerator: 796. instances to be
          used in the *note print(): 481. function.

     New in version 3.2.

The *note email.generator: 6c. module also provides a derived class,
called *note DecodedGenerator: 20e2. which is like the *note Generator:
795. base class, except that non-‘text’ parts are substituted with a
format string representing the part.

 -- Class: email.generator.DecodedGenerator (outfp, mangle_from_=True,
          maxheaderlen=78, fmt=None)

     This class, derived from *note Generator: 795. walks through all
     the subparts of a message.  If the subpart is of main type ‘text’,
     then it prints the decoded payload of the subpart.  Optional
     `_mangle_from_' and `maxheaderlen' are as with the *note Generator:
     795. base class.

     If the subpart is not of main type ‘text’, optional `fmt' is a
     format string that is used instead of the message payload.  `fmt'
     is expanded with the following keywords, ‘%(keyword)s’ format:

        * ‘type’ – Full MIME type of the non-‘text’ part

        * ‘maintype’ – Main MIME type of the non-‘text’ part

        * ‘subtype’ – Sub-MIME type of the non-‘text’ part

        * ‘filename’ – Filename of the non-‘text’ part

        * ‘description’ – Description associated with the non-‘text’
          part

        * ‘encoding’ – Content transfer encoding of the non-‘text’ part

     The default value for `fmt' is ‘None’, meaning

          [Non-text (%(type)s) part of message omitted, filename %(filename)s]

   ---------- Footnotes ----------

   (1) This statement assumes that you use the appropriate setting for
the ‘unixfrom’ argument, and that you set maxheaderlen=0 (which will
preserve whatever the input line lengths were).  It is also not strictly
true, since in many cases runs of whitespace in headers are collapsed
into single blanks.  The latter is a bug that will eventually be fixed.

   (2) https://www.jwz.org/doc/content-length.html

   (3) https://tools.ietf.org/html/rfc2822.html

   (4) https://tools.ietf.org/html/rfc2822.html

   (5) https://tools.ietf.org/html/rfc2047.html

   (6) https://www.jwz.org/doc/content-length.html

   (7) https://tools.ietf.org/html/rfc2822.html

   (8) https://tools.ietf.org/html/rfc2822.html


File: python.info,  Node: email policy Policy Objects,  Next: email headerregistry Custom Header Objects,  Prev: email generator Generating MIME documents,  Up: email --- An email and MIME handling package

5.19.1.7 ‘email.policy’: Policy Objects
.......................................

New in version 3.3.

The *note email: 67. package’s prime focus is the handling of email
messages as described by the various email and MIME RFCs.  However, the
general format of email messages (a block of header fields each
consisting of a name followed by a colon followed by a value, the whole
block followed by a blank line and an arbitrary ’body’), is a format
that has found utility outside of the realm of email.  Some of these
uses conform fairly closely to the main RFCs, some do not.  And even
when working with email, there are times when it is desirable to break
strict compliance with the RFCs.

Policy objects give the email package the flexibility to handle all
these disparate use cases.

A *note Policy: 622. object encapsulates a set of attributes and methods
that control the behavior of various components of the email package
during use.  *note Policy: 622. instances can be passed to various
classes and methods in the email package to alter the default behavior.
The settable values and their defaults are described below.

There is a default policy used by all classes in the email package.
This policy is named *note Compat32: 623, with a corresponding
pre-defined instance named *note compat32: 280.  It provides for
complete backward compatibility (in some cases, including bug
compatibility) with the pre-Python3.3 version of the email package.

The first part of this documentation covers the features of *note
Policy: 622, an *note abstract base class: 776. that defines the
features that are common to all policy objects, including *note
compat32: 280.  This includes certain hook methods that are called
internally by the email package, which a custom policy could override to
obtain different behavior.

When a *note Message: 3d2. object is created, it acquires a policy.  By
default this will be *note compat32: 280, but a different policy can be
specified.  If the ‘Message’ is created by a *note parser: 72, a policy
passed to the parser will be the policy used by the ‘Message’ it
creates.  If the ‘Message’ is created by the program, then the policy
can be specified when it is created.  When a ‘Message’ is passed to a
*note generator: 6c, the generator uses the policy from the ‘Message’ by
default, but you can also pass a specific policy to the generator that
will override the one stored on the ‘Message’ object.

*note Policy: 622. instances are immutable, but they can be cloned,
accepting the same keyword arguments as the class constructor and
returning a new *note Policy: 622. instance that is a copy of the
original but with the specified attributes values changed.

As an example, the following code could be used to read an email message
from a file on disk and pass it to the system ‘sendmail’ program on a
Unix system:

     >>> from email import message_from_binary_file
     >>> from email.generator import BytesGenerator
     >>> from email import policy
     >>> from subprocess import Popen, PIPE
     >>> with open('mymsg.txt', 'rb') as f:
     ...     msg = message_from_binary_file(f, policy=policy.default)
     >>> p = Popen(['sendmail', msg['To'].addresses[0]], stdin=PIPE)
     >>> g = BytesGenerator(p.stdin, policy=msg.policy.clone(linesep='\r\n'))
     >>> g.flatten(msg)
     >>> p.stdin.close()
     >>> rc = p.wait()

Here we are telling *note BytesGenerator: 796. to use the RFC correct
line separator characters when creating the binary string to feed into
‘sendmail's’ ‘stdin’, where the default policy would use ‘\n’ line
separators.

Some email package methods accept a `policy' keyword argument, allowing
the policy to be overridden for that method.  For example, the following
code uses the *note as_bytes(): 432. method of the `msg' object from the
previous example and writes the message to a file using the native line
separators for the platform on which it is running:

     >>> import os
     >>> with open('converted.txt', 'wb') as f:
     ...     f.write(msg.as_bytes(policy=msg.policy.clone(linesep=os.linesep)))
     17

Policy objects can also be combined using the addition operator,
producing a policy object whose settings are a combination of the
non-default values of the summed objects:

     >>> compat_SMTP = policy.compat32.clone(linesep='\r\n')
     >>> compat_strict = policy.compat32.clone(raise_on_defect=True)
     >>> compat_strict_SMTP = compat_SMTP + compat_strict

This operation is not commutative; that is, the order in which the
objects are added matters.  To illustrate:

     >>> policy100 = policy.compat32.clone(max_line_length=100)
     >>> policy80 = policy.compat32.clone(max_line_length=80)
     >>> apolicy = policy100 + policy80
     >>> apolicy.max_line_length
     80
     >>> apolicy = policy80 + policy100
     >>> apolicy.max_line_length
     100

 -- Class: email.policy.Policy (**kw)

     This is the *note abstract base class: 776. for all policy classes.
     It provides default implementations for a couple of trivial
     methods, as well as the implementation of the immutability
     property, the *note clone(): 624. method, and the constructor
     semantics.

     The constructor of a policy class can be passed various keyword
     arguments.  The arguments that may be specified are any non-method
     properties on this class, plus any additional non-method properties
     on the concrete class.  A value specified in the constructor will
     override the default value for the corresponding attribute.

     This class defines the following properties, and thus values for
     the following may be passed in the constructor of any policy class:

      -- Attribute: max_line_length

          The maximum length of any line in the serialized output, not
          counting the end of line character(s).  Default is 78, per RFC
          5322(1).  A value of ‘0’ or *note None: 19d. indicates that no
          line wrapping should be done at all.

      -- Attribute: linesep

          The string to be used to terminate lines in serialized output.
          The default is ‘\n’ because that’s the internal end-of-line
          discipline used by Python, though ‘\r\n’ is required by the
          RFCs.

      -- Attribute: cte_type

          Controls the type of Content Transfer Encodings that may be or
          are required to be used.  The possible values are:

          ‘7bit’       all data must be "7 bit clean" (ASCII-only).  This means that
                       where necessary data will be encoded using either
                       quoted-printable or base64 encoding.
                       
                       
          ‘8bit’       data is not constrained to be 7 bit clean.  Data in headers is
                       still required to be ASCII-only and so will be encoded (see
                       ’binary_fold’ below for an exception), but body parts may use the
                       ‘8bit’ CTE.
                       

          A ‘cte_type’ value of ‘8bit’ only works with ‘BytesGenerator’,
          not ‘Generator’, because strings cannot contain binary data.
          If a ‘Generator’ is operating under a policy that specifies
          ‘cte_type=8bit’, it will act as if ‘cte_type’ is ‘7bit’.

      -- Attribute: raise_on_defect

          If *note True: 9ff, any defects encountered will be raised as
          errors.  If *note False: 60d. (the default), defects will be
          passed to the *note register_defect(): 20e8. method.

      -- Attribute: mangle_from_

          If *note True: 9ff, lines starting with `"From "' in the body
          are escaped by putting a ‘>’ in front of them.  This parameter
          is used when the message is being serialized by a generator.
          Default: *note False: 60d.

          New in version 3.5: The `mangle_from_' parameter.

     The following *note Policy: 622. method is intended to be called by
     code using the email library to create policy instances with custom
     settings:

      -- Method: clone (**kw)

          Return a new *note Policy: 622. instance whose attributes have
          the same values as the current instance, except where those
          attributes are given new values by the keyword arguments.

     The remaining *note Policy: 622. methods are called by the email
     package code, and are not intended to be called by an application
     using the email package.  A custom policy must implement all of
     these methods.

      -- Method: handle_defect (obj, defect)

          Handle a `defect' found on `obj'.  When the email package
          calls this method, `defect' will always be a subclass of
          ‘Defect’.

          The default implementation checks the *note raise_on_defect:
          20e7. flag.  If it is ‘True’, `defect' is raised as an
          exception.  If it is ‘False’ (the default), `obj' and `defect'
          are passed to *note register_defect(): 20e8.

      -- Method: register_defect (obj, defect)

          Register a `defect' on `obj'.  In the email package, `defect'
          will always be a subclass of ‘Defect’.

          The default implementation calls the ‘append’ method of the
          ‘defects’ attribute of `obj'.  When the email package calls
          *note handle_defect: 20e9, `obj' will normally have a
          ‘defects’ attribute that has an ‘append’ method.  Custom
          object types used with the email package (for example, custom
          ‘Message’ objects) should also provide such an attribute,
          otherwise defects in parsed messages will raise unexpected
          errors.

      -- Method: header_max_count (name)

          Return the maximum allowed number of headers named `name'.

          Called when a header is added to a *note Message: 3d2. object.
          If the returned value is not ‘0’ or ‘None’, and there are
          already a number of headers with the name `name' equal to the
          value returned, a *note ValueError: 19c. is raised.

          Because the default behavior of ‘Message.__setitem__’ is to
          append the value to the list of headers, it is easy to create
          duplicate headers without realizing it.  This method allows
          certain headers to be limited in the number of instances of
          that header that may be added to a ‘Message’ programmatically.
          (The limit is not observed by the parser, which will
          faithfully produce as many headers as exist in the message
          being parsed.)

          The default implementation returns ‘None’ for all header
          names.

      -- Method: header_source_parse (sourcelines)

          The email package calls this method with a list of strings,
          each string ending with the line separation characters found
          in the source being parsed.  The first line includes the field
          header name and separator.  All whitespace in the source is
          preserved.  The method should return the ‘(name, value)’ tuple
          that is to be stored in the ‘Message’ to represent the parsed
          header.

          If an implementation wishes to retain compatibility with the
          existing email package policies, `name' should be the case
          preserved name (all characters up to the ’‘:’’ separator),
          while `value' should be the unfolded value (all line separator
          characters removed, but whitespace kept intact), stripped of
          leading whitespace.

          `sourcelines' may contain surrogateescaped binary data.

          There is no default implementation

      -- Method: header_store_parse (name, value)

          The email package calls this method with the name and value
          provided by the application program when the application
          program is modifying a ‘Message’ programmatically (as opposed
          to a ‘Message’ created by a parser).  The method should return
          the ‘(name, value)’ tuple that is to be stored in the
          ‘Message’ to represent the header.

          If an implementation wishes to retain compatibility with the
          existing email package policies, the `name' and `value' should
          be strings or string subclasses that do not change the content
          of the passed in arguments.

          There is no default implementation

      -- Method: header_fetch_parse (name, value)

          The email package calls this method with the `name' and
          `value' currently stored in the ‘Message’ when that header is
          requested by the application program, and whatever the method
          returns is what is passed back to the application as the value
          of the header being retrieved.  Note that there may be more
          than one header with the same name stored in the ‘Message’;
          the method is passed the specific name and value of the header
          destined to be returned to the application.

          `value' may contain surrogateescaped binary data.  There
          should be no surrogateescaped binary data in the value
          returned by the method.

          There is no default implementation

      -- Method: fold (name, value)

          The email package calls this method with the `name' and
          `value' currently stored in the ‘Message’ for a given header.
          The method should return a string that represents that header
          "folded" correctly (according to the policy settings) by
          composing the `name' with the `value' and inserting *note
          linesep: 20e6. characters at the appropriate places.  See RFC
          5322(2) for a discussion of the rules for folding email
          headers.

          `value' may contain surrogateescaped binary data.  There
          should be no surrogateescaped binary data in the string
          returned by the method.

      -- Method: fold_binary (name, value)

          The same as *note fold(): 20ee, except that the returned value
          should be a bytes object rather than a string.

          `value' may contain surrogateescaped binary data.  These could
          be converted back into binary data in the returned bytes
          object.

 -- Class: email.policy.Compat32 (**kw)

     This concrete *note Policy: 622. is the backward compatibility
     policy.  It replicates the behavior of the email package in Python
     3.2.  The *note policy: 73. module also defines an instance of this
     class, *note compat32: 280, that is used as the default policy.
     Thus the default behavior of the email package is to maintain
     compatibility with Python 3.2.

     The following attributes have values that are different from the
     *note Policy: 622. default:

      -- Attribute: mangle_from_

          The default is ‘True’.

     The class provides the following concrete implementations of the
     abstract methods of *note Policy: 622.:

      -- Method: header_source_parse (sourcelines)

          The name is parsed as everything up to the ’‘:’’ and returned
          unmodified.  The value is determined by stripping leading
          whitespace off the remainder of the first line, joining all
          subsequent lines together, and stripping any trailing carriage
          return or linefeed characters.

      -- Method: header_store_parse (name, value)

          The name and value are returned unmodified.

      -- Method: header_fetch_parse (name, value)

          If the value contains binary data, it is converted into a
          *note Header: 20ac. object using the ‘unknown-8bit’ charset.
          Otherwise it is returned unmodified.

      -- Method: fold (name, value)

          Headers are folded using the *note Header: 20ac. folding
          algorithm, which preserves existing line breaks in the value,
          and wraps each resulting line to the ‘max_line_length’.
          Non-ASCII binary data are CTE encoded using the ‘unknown-8bit’
          charset.

      -- Method: fold_binary (name, value)

          Headers are folded using the *note Header: 20ac. folding
          algorithm, which preserves existing line breaks in the value,
          and wraps each resulting line to the ‘max_line_length’.  If
          ‘cte_type’ is ‘7bit’, non-ascii binary data is CTE encoded
          using the ‘unknown-8bit’ charset.  Otherwise the original
          source header is used, with its existing line breaks and any
          (RFC invalid) binary data it may contain.

An instance of *note Compat32: 623. is provided as a module constant:

 -- Data: email.policy.compat32

     An instance of *note Compat32: 623, providing backward
     compatibility with the behavior of the email package in Python 3.2.

     Note: The documentation below describes new policies that are
     included in the standard library on a *note provisional basis: 59d.
     Backwards incompatible changes (up to and including removal of the
     feature) may occur if deemed necessary by the core developers.

 -- Class: email.policy.EmailPolicy (**kw)

     This concrete *note Policy: 622. provides behavior that is intended
     to be fully compliant with the current email RFCs.  These include
     (but are not limited to) RFC 5322(3), RFC 2047(4), and the current
     MIME RFCs.

     This policy adds new header parsing and folding algorithms.
     Instead of simple strings, headers are ‘str’ subclasses with
     attributes that depend on the type of the field.  The parsing and
     folding algorithm fully implement RFC 2047(5) and RFC 5322(6).

     In addition to the settable attributes listed above that apply to
     all policies, this policy adds the following additional attributes:

      -- Attribute: utf8

          If ‘False’, follow RFC 5322(7), supporting non-ASCII
          characters in headers by encoding them as "encoded words".  If
          ‘True’, follow RFC 6532(8) and use ‘utf-8’ encoding for
          headers.  Messages formatted in this way may be passed to SMTP
          servers that support the ‘SMTPUTF8’ extension ( RFC 6531(9)).

      -- Attribute: refold_source

          If the value for a header in the ‘Message’ object originated
          from a *note parser: 72. (as opposed to being set by a
          program), this attribute indicates whether or not a generator
          should refold that value when transforming the message back
          into stream form.  The possible values are:

          ‘none’       all source values use original folding
                       
                       
          ‘long’       source values that have any line that is longer than
                       ‘max_line_length’ will be refolded
                       
                       
          ‘all’        all values are refolded.
                       

          The default is ‘long’.

      -- Attribute: header_factory

          A callable that takes two arguments, ‘name’ and ‘value’, where
          ‘name’ is a header field name and ‘value’ is an unfolded
          header field value, and returns a string subclass that
          represents that header.  A default ‘header_factory’ (see *note
          headerregistry: 6e.) is provided that understands some of the
          RFC 5322(10) header field types.  (Currently address fields
          and date fields have special treatment, while all other fields
          are treated as unstructured.  This list will be completed
          before the extension is marked stable.)

      -- Attribute: content_manager

          An object with at least two methods: get_content and
          set_content.  When the ‘get_content()’ or ‘set_content()’
          method of a *note Message: 3d2. object is called, it calls the
          corresponding method of this object, passing it the message
          object as its first argument, and any arguments or keywords
          that were passed to it as additional arguments.  By default
          ‘content_manager’ is set to *note raw_data_manager: 20f8.

          New in version 3.4.

     The class provides the following concrete implementations of the
     abstract methods of *note Policy: 622.:

      -- Method: header_max_count (name)

          Returns the value of the *note max_count: 20fa. attribute of
          the specialized class used to represent the header with the
          given name.

      -- Method: header_source_parse (sourcelines)

          The implementation of this method is the same as that for the
          *note Compat32: 623. policy.

      -- Method: header_store_parse (name, value)

          The name is returned unchanged.  If the input value has a
          ‘name’ attribute and it matches `name' ignoring case, the
          value is returned unchanged.  Otherwise the `name' and `value'
          are passed to ‘header_factory’, and the resulting header
          object is returned as the value.  In this case a ‘ValueError’
          is raised if the input value contains CR or LF characters.

      -- Method: header_fetch_parse (name, value)

          If the value has a ‘name’ attribute, it is returned to
          unmodified.  Otherwise the `name', and the `value' with any CR
          or LF characters removed, are passed to the ‘header_factory’,
          and the resulting header object is returned.  Any
          surrogateescaped bytes get turned into the unicode
          unknown-character glyph.

      -- Method: fold (name, value)

          Header folding is controlled by the *note refold_source: 20f6.
          policy setting.  A value is considered to be a ’source value’
          if and only if it does not have a ‘name’ attribute (having a
          ‘name’ attribute means it is a header object of some sort).
          If a source value needs to be refolded according to the
          policy, it is converted into a header object by passing the
          `name' and the `value' with any CR and LF characters removed
          to the ‘header_factory’.  Folding of a header object is done
          by calling its ‘fold’ method with the current policy.

          Source values are split into lines using *note splitlines():
          1011.  If the value is not to be refolded, the lines are
          rejoined using the ‘linesep’ from the policy and returned.
          The exception is lines containing non-ascii binary data.  In
          that case the value is refolded regardless of the
          ‘refold_source’ setting, which causes the binary data to be
          CTE encoded using the ‘unknown-8bit’ charset.

      -- Method: fold_binary (name, value)

          The same as *note fold(): 20fe. if *note cte_type: 20de. is
          ‘7bit’, except that the returned value is bytes.

          If *note cte_type: 20de. is ‘8bit’, non-ASCII binary data is
          converted back into bytes.  Headers with binary data are not
          refolded, regardless of the ‘refold_header’ setting, since
          there is no way to know whether the binary data consists of
          single byte characters or multibyte characters.

The following instances of *note EmailPolicy: 626. provide defaults
suitable for specific application domains.  Note that in the future the
behavior of these instances (in particular the ‘HTTP’ instance) may be
adjusted to conform even more closely to the RFCs relevant to their
domains.

 -- Data: email.policy.default

     An instance of ‘EmailPolicy’ with all defaults unchanged.  This
     policy uses the standard Python ‘\n’ line endings rather than the
     RFC-correct ‘\r\n’.

 -- Data: email.policy.SMTP

     Suitable for serializing messages in conformance with the email
     RFCs.  Like ‘default’, but with ‘linesep’ set to ‘\r\n’, which is
     RFC compliant.

 -- Data: email.policy.SMTPUTF8

     The same as ‘SMTP’ except that *note utf8: 282. is ‘True’.  Useful
     for serializing messages to a message store without using encoded
     words in the headers.  Should only be used for SMTP trasmission if
     the sender or recipient addresses have non-ASCII characters (the
     *note smtplib.SMTP.send_message(): 310. method handles this
     automatically).

 -- Data: email.policy.HTTP

     Suitable for serializing headers with for use in HTTP traffic.
     Like ‘SMTP’ except that ‘max_line_length’ is set to ‘None’
     (unlimited).

 -- Data: email.policy.strict

     Convenience instance.  The same as ‘default’ except that
     ‘raise_on_defect’ is set to ‘True’.  This allows any policy to be
     made strict by writing:

          somepolicy + policy.strict

With all of these *note EmailPolicies: 626, the effective API of the
email package is changed from the Python 3.2 API in the following ways:

        * Setting a header on a *note Message: 3d2. results in that
          header being parsed and a header object created.

        * Fetching a header value from a *note Message: 3d2. results in
          that header being parsed and a header object created and
          returned.

        * Any header object, or any header that is refolded due to the
          policy settings, is folded using an algorithm that fully
          implements the RFC folding algorithms, including knowing where
          encoded words are required and allowed.

From the application view, this means that any header obtained through
the *note Message: 3d2. is a header object with extra attributes, whose
string value is the fully decoded unicode value of the header.
Likewise, a header may be assigned a new value, or a new header created,
using a unicode string, and the policy will take care of converting the
unicode string into the correct RFC encoded form.

The header objects and their attributes are described in *note
headerregistry: 6e.

   ---------- Footnotes ----------

   (1) https://tools.ietf.org/html/rfc5322.html

   (2) https://tools.ietf.org/html/rfc5322.html

   (3) https://tools.ietf.org/html/rfc5322.html

   (4) https://tools.ietf.org/html/rfc2047.html

   (5) https://tools.ietf.org/html/rfc2047.html

   (6) https://tools.ietf.org/html/rfc5322.html

   (7) https://tools.ietf.org/html/rfc5322.html

   (8) https://tools.ietf.org/html/rfc6532.html

   (9) https://tools.ietf.org/html/rfc6531.html

   (10) https://tools.ietf.org/html/rfc5322.html


File: python.info,  Node: email headerregistry Custom Header Objects,  Next: email contentmanager Managing MIME Content,  Prev: email policy Policy Objects,  Up: email --- An email and MIME handling package

5.19.1.8 ‘email.headerregistry’: Custom Header Objects
......................................................

     Note: The headerregistry module has been included in the standard
     library on a *note provisional basis: 59d.  Backwards incompatible
     changes (up to and including removal of the module) may occur if
     deemed necessary by the core developers.

New in version 3.3: as a *note provisional module: 59d.

Headers are represented by customized subclasses of *note str: 25a.  The
particular class used to represent a given header is determined by the
*note header_factory: 20f7. of the *note policy: 73. in effect when the
headers are created.  This section documents the particular
‘header_factory’ implemented by the email package for handling RFC
5322(1) compliant email messages, which not only provides customized
header objects for various header types, but also provides an extension
mechanism for applications to add their own custom header types.

When using any of the policy objects derived from *note EmailPolicy:
626, all headers are produced by *note HeaderRegistry: 2107. and have
*note BaseHeader: 2108. as their last base class.  Each header class has
an additional base class that is determined by the type of the header.
For example, many headers have the class *note UnstructuredHeader: 2109.
as their other base class.  The specialized second class for a header is
determined by the name of the header, using a lookup table stored in the
*note HeaderRegistry: 2107.  All of this is managed transparently for
the typical application program, but interfaces are provided for
modifying the default behavior for use by more complex applications.

The sections below first document the header base classes and their
attributes, followed by the API for modifying the behavior of *note
HeaderRegistry: 2107, and finally the support classes used to represent
the data parsed from structured headers.

 -- Class: email.headerregistry.BaseHeader (name, value)

     `name' and `value' are passed to ‘BaseHeader’ from the *note
     header_factory: 20f7. call.  The string value of any header object
     is the `value' fully decoded to unicode.

     This base class defines the following read-only properties:

      -- Attribute: name

          The name of the header (the portion of the field before the
          ’:’).  This is exactly the value passed in the *note
          header_factory: 20f7. call for `name'; that is, case is
          preserved.

      -- Attribute: defects

          A tuple of ‘HeaderDefect’ instances reporting any RFC
          compliance problems found during parsing.  The email package
          tries to be complete about detecting compliance issues.  See
          the *note errors: 6b. module for a discussion of the types of
          defects that may be reported.

      -- Attribute: max_count

          The maximum number of headers of this type that can have the
          same ‘name’.  A value of ‘None’ means unlimited.  The
          ‘BaseHeader’ value for this attribute is ‘None’; it is
          expected that specialized header classes will override this
          value as needed.

     ‘BaseHeader’ also provides the following method, which is called by
     the email library code and should not in general be called by
     application programs:

      -- Method: fold (*, policy)

          Return a string containing *note linesep: 20e6. characters as
          required to correctly fold the header according to `policy'.
          A *note cte_type: 20de. of ‘8bit’ will be treated as if it
          were ‘7bit’, since strings may not contain binary data.

     ‘BaseHeader’ by itself cannot be used to create a header object.
     It defines a protocol that each specialized header cooperates with
     in order to produce the header object.  Specifically, ‘BaseHeader’
     requires that the specialized class provide a *note classmethod():
     5f4. named ‘parse’.  This method is called as follows:

          parse(string, kwds)

     ‘kwds’ is a dictionary containing one pre-initialized key,
     ‘defects’.  ‘defects’ is an empty list.  The parse method should
     append any detected defects to this list.  On return, the ‘kwds’
     dictionary `must' contain values for at least the keys ‘decoded’
     and ‘defects’.  ‘decoded’ should be the string value for the header
     (that is, the header value fully decoded to unicode).  The parse
     method should assume that `string' may contain transport encoded
     parts, but should correctly handle all valid unicode characters as
     well so that it can parse un-encoded header values.

     ‘BaseHeader’’s ‘__new__’ then creates the header instance, and
     calls its ‘init’ method.  The specialized class only needs to
     provide an ‘init’ method if it wishes to set additional attributes
     beyond those provided by ‘BaseHeader’ itself.  Such an ‘init’
     method should look like this:

          def init(self, *args, **kw):
              self._myattr = kw.pop('myattr')
              super().init(*args, **kw)

     That is, anything extra that the specialized class puts in to the
     ‘kwds’ dictionary should be removed and handled, and the remaining
     contents of ‘kw’ (and ‘args’) passed to the ‘BaseHeader’ ‘init’
     method.

 -- Class: email.headerregistry.UnstructuredHeader

     An "unstructured" header is the default type of header in RFC
     5322(2).  Any header that does not have a specified syntax is
     treated as unstructured.  The classic example of an unstructured
     header is the ‘Subject’ header.

     In RFC 5322(3), an unstructured header is a run of arbitrary text
     in the ASCII character set.  RFC 2047(4), however, has an RFC
     5322(5) compatible mechanism for encoding non-ASCII text as ASCII
     characters within a header value.  When a `value' containing
     encoded words is passed to the constructor, the
     ‘UnstructuredHeader’ parser converts such encoded words back in to
     the original unicode, following the RFC 2047(6) rules for
     unstructured text.  The parser uses heuristics to attempt to decode
     certain non-compliant encoded words.  Defects are registered in
     such cases, as well as defects for issues such as invalid
     characters within the encoded words or the non-encoded text.

     This header type provides no additional attributes.

 -- Class: email.headerregistry.DateHeader

     RFC 5322(7) specifies a very specific format for dates within email
     headers.  The ‘DateHeader’ parser recognizes that date format, as
     well as recognizing a number of variant forms that are sometimes
     found "in the wild".

     This header type provides the following additional attributes:

      -- Attribute: datetime

          If the header value can be recognized as a valid date of one
          form or another, this attribute will contain a *note datetime:
          60c. instance representing that date.  If the timezone of the
          input date is specified as ‘-0000’ (indicating it is in UTC
          but contains no information about the source timezone), then
          *note datetime: 210e. will be a naive *note datetime: 60c.  If
          a specific timezone offset is found (including ‘+0000’), then
          *note datetime: 210e. will contain an aware ‘datetime’ that
          uses *note datetime.timezone: 62d. to record the timezone
          offset.

     The ‘decoded’ value of the header is determined by formatting the
     ‘datetime’ according to the RFC 5322(8) rules; that is, it is set
     to:

          email.utils.format_datetime(self.datetime)

     When creating a ‘DateHeader’, `value' may be *note datetime: 60c.
     instance.  This means, for example, that the following code is
     valid and does what one would expect:

          msg['Date']  = datetime(2011, 7, 15, 21)

     Because this is a naive ‘datetime’ it will be interpreted as a UTC
     timestamp, and the resulting value will have a timezone of ‘-0000’.
     Much more useful is to use the *note localtime(): 62c. function
     from the *note utils: 74. module:

          msg['Date'] = utils.localtime()

     This example sets the date header to the current time and date
     using the current timezone offset.

 -- Class: email.headerregistry.AddressHeader

     Address headers are one of the most complex structured header
     types.  The ‘AddressHeader’ class provides a generic interface to
     any address header.

     This header type provides the following additional attributes:

      -- Attribute: groups

          A tuple of *note Group: 2111. objects encoding the addresses
          and groups found in the header value.  Addresses that are not
          part of a group are represented in this list as single-address
          ‘Groups’ whose *note display_name: 2112. is ‘None’.

      -- Attribute: addresses

          A tuple of *note Address: 2114. objects encoding all of the
          individual addresses from the header value.  If the header
          value contains any groups, the individual addresses from the
          group are included in the list at the point where the group
          occurs in the value (that is, the list of addresses is
          "flattened" into a one dimensional list).

     The ‘decoded’ value of the header will have all encoded words
     decoded to unicode.  *note idna: 75. encoded domain names are also
     decoded to unicode.  The ‘decoded’ value is set by *note join:
     fe9.ing the *note str: 25a. value of the elements of the ‘groups’
     attribute with ‘', '’.

     A list of *note Address: 2114. and *note Group: 2111. objects in
     any combination may be used to set the value of an address header.
     ‘Group’ objects whose ‘display_name’ is ‘None’ will be interpreted
     as single addresses, which allows an address list to be copied with
     groups intact by using the list obtained ‘groups’ attribute of the
     source header.

 -- Class: email.headerregistry.SingleAddressHeader

     A subclass of *note AddressHeader: 210f. that adds one additional
     attribute:

      -- Attribute: address

          The single address encoded by the header value.  If the header
          value actually contains more than one address (which would be
          a violation of the RFC under the default *note policy: 73.),
          accessing this attribute will result in a *note ValueError:
          19c.

Many of the above classes also have a ‘Unique’ variant (for example,
‘UniqueUnstructuredHeader’).  The only difference is that in the
‘Unique’ variant, *note max_count: 20fa. is set to 1.

 -- Class: email.headerregistry.MIMEVersionHeader

     There is really only one valid value for the ‘MIME-Version’ header,
     and that is ‘1.0’.  For future proofing, this header class supports
     other valid version numbers.  If a version number has a valid value
     per RFC 2045(9), then the header object will have non-‘None’ values
     for the following attributes:

      -- Attribute: version

          The version number as a string, with any whitespace and/or
          comments removed.

      -- Attribute: major

          The major version number as an integer

      -- Attribute: minor

          The minor version number as an integer

 -- Class: email.headerregistry.ParameterizedMIMEHeader

     MOME headers all start with the prefix ’Content-’.  Each specific
     header has a certain value, described under the class for that
     header.  Some can also take a list of supplemental parameters,
     which have a common format.  This class serves as a base for all
     the MIME headers that take parameters.

      -- Attribute: params

          A dictionary mapping parameter names to parameter values.

 -- Class: email.headerregistry.ContentTypeHeader

     A *note ParameterizedMIMEHeader: 211b. class that handles the
     ‘Content-Type’ header.

      -- Attribute: content_type

          The content type string, in the form ‘maintype/subtype’.

      -- Attribute: maintype

      -- Attribute: subtype

 -- Class: email.headerregistry.ContentDispositionHeader

     A *note ParameterizedMIMEHeader: 211b. class that handles the
     ‘Content-Disposition’ header.

      -- Attribute: content-disposition

          ‘inline’ and ‘attachment’ are the only valid values in common
          use.

 -- Class: email.headerregistry.ContentTransferEncoding

     Handles the ‘Content-Transfer-Encoding’ header.

      -- Attribute: cte

          Valid values are ‘7bit’, ‘8bit’, ‘base64’, and
          ‘quoted-printable’.  See RFC 2045(10) for more information.

 -- Class: email.headerregistry.HeaderRegistry (base_class=BaseHeader,
          default_class=UnstructuredHeader, use_default_map=True)

     This is the factory used by *note EmailPolicy: 626. by default.
     ‘HeaderRegistry’ builds the class used to create a header instance
     dynamically, using `base_class' and a specialized class retrieved
     from a registry that it holds.  When a given header name does not
     appear in the registry, the class specified by `default_class' is
     used as the specialized class.  When `use_default_map' is ‘True’
     (the default), the standard mapping of header names to classes is
     copied in to the registry during initialization.  `base_class' is
     always the last class in the generated class’s ‘__bases__’ list.

     The default mappings are:


          subject: UniqueUnstructuredHeader


          date: UniqueDateHeader


          resent-date: DateHeader


          orig-date: UniqueDateHeader


          sender: UniqueSingleAddressHeader


          resent-sender: SingleAddressHeader


          to: UniqueAddressHeader


          resent-to: AddressHeader


          cc: UniqueAddressHeader


          resent-cc: AddressHeader


          from: UniqueAddressHeader


          resent-from: AddressHeader


          reply-to: UniqueAddressHeader

     ‘HeaderRegistry’ has the following methods:

      -- Method: map_to_type (self, name, cls)

          `name' is the name of the header to be mapped.  It will be
          converted to lower case in the registry.  `cls' is the
          specialized class to be used, along with `base_class', to
          create the class used to instantiate headers that match
          `name'.

      -- Method: __getitem__ (name)

          Construct and return a class to handle creating a `name'
          header.

      -- Method: __call__ (name, value)

          Retrieves the specialized header associated with `name' from
          the registry (using `default_class' if `name' does not appear
          in the registry) and composes it with `base_class' to produce
          a class, calls the constructed class’s constructor, passing it
          the same argument list, and finally returns the class instance
          created thereby.

The following classes are the classes used to represent data parsed from
structured headers and can, in general, be used by an application
program to construct structured values to assign to specific headers.

 -- Class: email.headerregistry.Address (display_name='', username='',
          domain='', addr_spec=None)

     The class used to represent an email address.  The general form of
     an address is:

          [display_name] <username@domain>

     or:

          username@domain

     where each part must conform to specific syntax rules spelled out
     in RFC 5322(11).

     As a convenience `addr_spec' can be specified instead of `username'
     and `domain', in which case `username' and `domain' will be parsed
     from the `addr_spec'.  An `addr_spec' must be a properly RFC quoted
     string; if it is not ‘Address’ will raise an error.  Unicode
     characters are allowed and will be property encoded when
     serialized.  However, per the RFCs, unicode is `not' allowed in the
     username portion of the address.

      -- Attribute: display_name

          The display name portion of the address, if any, with all
          quoting removed.  If the address does not have a display name,
          this attribute will be an empty string.

      -- Attribute: username

          The ‘username’ portion of the address, with all quoting
          removed.

      -- Attribute: domain

          The ‘domain’ portion of the address.

      -- Attribute: addr_spec

          The ‘username@domain’ portion of the address, correctly quoted
          for use as a bare address (the second form shown above).  This
          attribute is not mutable.

      -- Method: __str__ ()

          The ‘str’ value of the object is the address quoted according
          to RFC 5322(12) rules, but with no Content Transfer Encoding
          of any non-ASCII characters.

     To support SMTP ( RFC 5321(13)), ‘Address’ handles one special
     case: if ‘username’ and ‘domain’ are both the empty string (or
     ‘None’), then the string value of the ‘Address’ is ‘<>’.

 -- Class: email.headerregistry.Group (display_name=None,
          addresses=None)

     The class used to represent an address group.  The general form of
     an address group is:

          display_name: [address-list];

     As a convenience for processing lists of addresses that consist of
     a mixture of groups and single addresses, a ‘Group’ may also be
     used to represent single addresses that are not part of a group by
     setting `display_name' to ‘None’ and providing a list of the single
     address as `addresses'.

      -- Attribute: display_name

          The ‘display_name’ of the group.  If it is ‘None’ and there is
          exactly one ‘Address’ in ‘addresses’, then the ‘Group’
          represents a single address that is not in a group.

      -- Attribute: addresses

          A possibly empty tuple of *note Address: 2114. objects
          representing the addresses in the group.

      -- Method: __str__ ()

          The ‘str’ value of a ‘Group’ is formatted according to RFC
          5322(14), but with no Content Transfer Encoding of any
          non-ASCII characters.  If ‘display_name’ is none and there is
          a single ‘Address’ in the ‘addresses’ list, the ‘str’ value
          will be the same as the ‘str’ of that single ‘Address’.

   ---------- Footnotes ----------

   (1) https://tools.ietf.org/html/rfc5322.html

   (2) https://tools.ietf.org/html/rfc5322.html

   (3) https://tools.ietf.org/html/rfc5322.html

   (4) https://tools.ietf.org/html/rfc2047.html

   (5) https://tools.ietf.org/html/rfc5322.html

   (6) https://tools.ietf.org/html/rfc2047.html

   (7) https://tools.ietf.org/html/rfc5322.html

   (8) https://tools.ietf.org/html/rfc5322.html

   (9) https://tools.ietf.org/html/rfc2045.html

   (10) https://tools.ietf.org/html/rfc2045.html

   (11) https://tools.ietf.org/html/rfc5322.html

   (12) https://tools.ietf.org/html/rfc5322.html

   (13) https://tools.ietf.org/html/rfc5321.html

   (14) https://tools.ietf.org/html/rfc5322.html


File: python.info,  Node: email contentmanager Managing MIME Content,  Next: email mime Creating email and MIME objects from scratch,  Prev: email headerregistry Custom Header Objects,  Up: email --- An email and MIME handling package

5.19.1.9 ‘email.contentmanager’: Managing MIME Content
......................................................

     Note: The contentmanager module has been included in the standard
     library on a *note provisional basis: 59d.  Backwards incompatible
     changes (up to and including removal of the module) may occur if
     deemed necessary by the core developers.

New in version 3.4: as a *note provisional module: 59d.

The *note message: 70. module provides a class that can represent an
arbitrary email message.  That basic message model has a useful and
flexible API, but it provides only a lower-level API for interacting
with the generic parts of a message (the headers, generic header
parameters, and the payload, which may be a list of sub-parts).  This
module provides classes and tools that provide an enhanced and
extensible API for dealing with various specific types of content,
including the ability to retrieve the content of the message as a
specialized object type rather than as a simple bytes object.  The
module automatically takes care of the RFC-specified MIME details
(required headers and parameters, etc.)  for the certain common content
types content properties, and support for additional types can be added
by an application using the extension mechanisms.

This module defines the eponymous "Content Manager" classes.  The base
*note ContentManager: 2130. class defines an API for registering content
management functions which extract data from ‘Message’ objects or insert
data and headers into ‘Message’ objects, thus providing a way of
converting between ‘Message’ objects containing data and other
representations of that data (Python data types, specialized Python
objects, external files, etc).  The module also defines one concrete
content manager: *note raw_data_manager: 20f8. converts between MIME
content types and ‘str’ or ‘bytes’ data.  It also provides a convenient
API for managing the MIME parameters when inserting content into
‘Message’s.  It also handles inserting and extracting ‘Message’ objects
when dealing with the ‘message/rfc822’ content type.

Another part of the enhanced interface is subclasses of *note Message:
3d2. that provide new convenience API functions, including convenience
methods for calling the Content Managers derived from this module.

     Note: Although *note EmailMessage: 435. and *note MIMEPart: 436.
     are currently documented in this module because of the provisional
     nature of the code, the implementation lives in the *note
     email.message: 70. module.

 -- Class: email.message.EmailMessage (policy=default)

     If `policy' is specified (it must be an instance of a *note policy:
     73. class) use the rules it specifies to udpate and serialize the
     representation of the message.  If `policy' is not set, use the
     *note default: 2100. policy, which follows the rules of the email
     RFCs except for line endings (instead of the RFC mandated ‘\r\n’,
     it uses the Python standard ‘\n’ line endings).  For more
     information see the *note policy: 73. documentation.

     This class is a subclass of *note Message: 3d2.  It adds the
     following methods:

      -- Method: is_attachment ()

          Return ‘True’ if there is a ‘Content-Disposition’ header and
          its (case insensitive) value is ‘attachment’, ‘False’
          otherwise.

          Changed in version 3.4.2: is_attachment is now a method
          instead of a property, for consistency with *note
          is_multipart(): 20a4.

      -- Method: get_body (preferencelist=('related', 'html', 'plain'))

          Return the MIME part that is the best candidate to be the
          "body" of the message.

          `preferencelist' must be a sequence of strings from the set
          ‘related’, ‘html’, and ‘plain’, and indicates the order of
          preference for the content type of the part returned.

          Start looking for candidate matches with the object on which
          the ‘get_body’ method is called.

          If ‘related’ is not included in `preferencelist', consider the
          root part (or subpart of the root part) of any related
          encountered as a candidate if the (sub-)part matches a
          preference.

          When encountering a ‘multipart/related’, check the ‘start’
          parameter and if a part with a matching ‘Content-ID’ is found,
          consider only it when looking for candidate matches.
          Otherwise consider only the first (default root) part of the
          ‘multipart/related’.

          If a part has a ‘Content-Disposition’ header, only consider
          the part a candidate match if the value of the header is
          ‘inline’.

          If none of the candidates matches any of the preferences in
          `preferneclist', return ‘None’.

          Notes: (1) For most applications the only `preferencelist'
          combinations that really make sense are ‘('plain',)’,
          ‘('html', 'plain')’, and the default, ‘('related', 'html',
          'plain')’.  (2) Because matching starts with the object on
          which ‘get_body’ is called, calling ‘get_body’ on a
          ‘multipart/related’ will return the object itself unless
          `preferencelist' has a non-default value.  (3) Messages (or
          message parts) that do not specify a ‘Content-Type’ or whose
          ‘Content-Type’ header is invalid will be treated as if they
          are of type ‘text/plain’, which may occasionally cause
          ‘get_body’ to return unexpected results.

      -- Method: iter_attachments ()

          Return an iterator over all of the parts of the message that
          are not candidate "body" parts.  That is, skip the first
          occurrence of each of ‘text/plain’, ‘text/html’,
          ‘multipart/related’, or ‘multipart/alternative’ (unless they
          are explicitly marked as attachments via ‘Content-Disposition:
          attachment’), and return all remaining parts.  When applied
          directly to a ‘multipart/related’, return an iterator over the
          all the related parts except the root part (ie: the part
          pointed to by the ‘start’ parameter, or the first part if
          there is no ‘start’ parameter or the ‘start’ parameter doesn’t
          match the ‘Content-ID’ of any of the parts).  When applied
          directly to a ‘multipart/alternative’ or a non-‘multipart’,
          return an empty iterator.

      -- Method: iter_parts ()

          Return an iterator over all of the immediate sub-parts of the
          message, which will be empty for a non-‘multipart’.  (See also
          ‘walk()’.)

      -- Method: get_content (*args, content_manager=None, **kw)

          Call the ‘get_content’ method of the `content_manager',
          passing self as the message object, and passing along any
          other arguments or keywords as additional arguments.  If
          `content_manager' is not specified, use the ‘content_manager’
          specified by the current *note policy: 73.

      -- Method: set_content (*args, content_manager=None, **kw)

          Call the ‘set_content’ method of the `content_manager',
          passing self as the message object, and passing along any
          other arguments or keywords as additional arguments.  If
          `content_manager' is not specified, use the ‘content_manager’
          specified by the current *note policy: 73.

      -- Method: make_related (boundary=None)

          Convert a non-‘multipart’ message into a ‘multipart/related’
          message, moving any existing ‘Content-’ headers and payload
          into a (new) first part of the ‘multipart’.  If `boundary' is
          specified, use it as the boundary string in the multipart,
          otherwise leave the boundary to be automatically created when
          it is needed (for example, when the message is serialized).

      -- Method: make_alternative (boundary=None)

          Convert a non-‘multipart’ or a ‘multipart/related’ into a
          ‘multipart/alternative’, moving any existing ‘Content-’
          headers and payload into a (new) first part of the
          ‘multipart’.  If `boundary' is specified, use it as the
          boundary string in the multipart, otherwise leave the boundary
          to be automatically created when it is needed (for example,
          when the message is serialized).

      -- Method: make_mixed (boundary=None)

          Convert a non-‘multipart’, a ‘multipart/related’, or a
          ‘multipart-alternative’ into a ‘multipart/mixed’, moving any
          existing ‘Content-’ headers and payload into a (new) first
          part of the ‘multipart’.  If `boundary' is specified, use it
          as the boundary string in the multipart, otherwise leave the
          boundary to be automatically created when it is needed (for
          example, when the message is serialized).

      -- Method: add_related (*args, content_manager=None, **kw)

          If the message is a ‘multipart/related’, create a new message
          object, pass all of the arguments to its *note set_content():
          2136. method, and *note attach(): 20a7. it to the ‘multipart’.
          If the message is a non-‘multipart’, call *note
          make_related(): 2137. and then proceed as above.  If the
          message is any other type of ‘multipart’, raise a *note
          TypeError: 562.  If `content_manager' is not specified, use
          the ‘content_manager’ specified by the current *note policy:
          73.  If the added part has no ‘Content-Disposition’ header,
          add one with the value ‘inline’.

      -- Method: add_alternative (*args, content_manager=None, **kw)

          If the message is a ‘multipart/alternative’, create a new
          message object, pass all of the arguments to its *note
          set_content(): 2136. method, and *note attach(): 20a7. it to
          the ‘multipart’.  If the message is a non-‘multipart’ or
          ‘multipart/related’, call *note make_alternative(): 2138. and
          then proceed as above.  If the message is any other type of
          ‘multipart’, raise a *note TypeError: 562.  If
          `content_manager' is not specified, use the ‘content_manager’
          specified by the current *note policy: 73.

      -- Method: add_attachment (*args, content_manager=None, **kw)

          If the message is a ‘multipart/mixed’, create a new message
          object, pass all of the arguments to its *note set_content():
          2136. method, and *note attach(): 20a7. it to the ‘multipart’.
          If the message is a non-‘multipart’, ‘multipart/related’, or
          ‘multipart/alternative’, call *note make_mixed(): 2139. and
          then proceed as above.  If `content_manager' is not specified,
          use the ‘content_manager’ specified by the current *note
          policy: 73.  If the added part has no ‘Content-Disposition’
          header, add one with the value ‘attachment’.  This method can
          be used both for explicit attachments (‘Content-Disposition:
          attachment’ and ‘inline’ attachments (‘Content-Disposition:
          inline’), by passing appropriate options to the
          ‘content_manager’.

      -- Method: clear ()

          Remove the payload and all of the headers.

      -- Method: clear_content ()

          Remove the payload and all of the ‘Content-’ headers, leaving
          all other headers intact and in their original order.

 -- Class: email.message.MIMEPart (policy=default)

     This class represents a subpart of a MIME message.  It is identical
     to *note EmailMessage: 435, except that no ‘MIME-Version’ headers
     are added when *note set_content(): 2136. is called, since
     sub-parts do not need their own ‘MIME-Version’ headers.

 -- Class: email.contentmanager.ContentManager

     Base class for content managers.  Provides the standard registry
     mechanisms to register converters between MIME content and other
     representations, as well as the ‘get_content’ and ‘set_content’
     dispatch methods.

      -- Method: get_content (msg, *args, **kw)

          Look up a handler function based on the ‘mimetype’ of `msg'
          (see next paragraph), call it, passing through all arguments,
          and return the result of the call.  The expectation is that
          the handler will extract the payload from `msg' and return an
          object that encodes information about the extracted data.

          To find the handler, look for the following keys in the
          registry, stopping with the first one found:

                  * the string representing the full MIME type
                    (‘maintype/subtype’)

                  * the string representing the ‘maintype’

                  * the empty string

          If none of these keys produce a handler, raise a *note
          KeyError: 1a7. for the full MIME type.

      -- Method: set_content (msg, obj, *args, **kw)

          If the ‘maintype’ is ‘multipart’, raise a *note TypeError:
          562.; otherwise look up a handler function based on the type
          of `obj' (see next paragraph), call *note clear_content():
          213e. on the `msg', and call the handler function, passing
          through all arguments.  The expectation is that the handler
          will transform and store `obj' into `msg', possibly making
          other changes to `msg' as well, such as adding various MIME
          headers to encode information needed to interpret the stored
          data.

          To find the handler, obtain the type of `obj' (‘typ =
          type(obj)’), and look for the following keys in the registry,
          stopping with the first one found:

                  * the type itself (‘typ’)

                  * the type’s fully qualified name (‘typ.__module__ +
                    '.' + typ.__qualname__’).

                  * the type’s qualname (‘typ.__qualname__’)

                  * the type’s name (‘typ.__name__’).

          If none of the above match, repeat all of the checks above for
          each of the types in the *note MRO: 2141. (‘typ.__mro__’).
          Finally, if no other key yields a handler, check for a handler
          for the key ‘None’.  If there is no handler for ‘None’, raise
          a *note KeyError: 1a7. for the fully qualified name of the
          type.

          Also add a ‘MIME-Version’ header if one is not present (see
          also *note MIMEPart: 436.).

      -- Method: add_get_handler (key, handler)

          Record the function `handler' as the handler for `key'.  For
          the possible values of `key', see *note get_content(): 2143.

      -- Method: add_set_handler (typekey, handler)

          Record `handler' as the function to call when an object of a
          type matching `typekey' is passed to *note set_content():
          2145.  For the possible values of `typekey', see *note
          set_content(): 2145.

* Menu:

* Content Manager Instances:: 


File: python.info,  Node: Content Manager Instances,  Up: email contentmanager Managing MIME Content

5.19.1.10 Content Manager Instances
...................................

Currently the email package provides only one concrete content manager,
*note raw_data_manager: 20f8, although more may be added in the future.
*note raw_data_manager: 20f8. is the *note content_manager: 437.
provided by *note EmailPolicy: 626. and its derivatives.

 -- Data: email.contentmanager.raw_data_manager

     This content manager provides only a minimum interface beyond that
     provided by *note Message: 3d2. itself: it deals only with text,
     raw byte strings, and *note Message: 3d2. objects.  Nevertheless,
     it provides significant advantages compared to the base API:
     ‘get_content’ on a text part will return a unicode string without
     the application needing to manually decode it, ‘set_content’
     provides a rich set of options for controlling the headers added to
     a part and controlling the content transfer encoding, and it
     enables the use of the various ‘add_’ methods, thereby simplifying
     the creation of multipart messages.

      -- Method: email.contentmanager.get_content (msg,
               errors='replace')

          Return the payload of the part as either a string (for ‘text’
          parts), a *note EmailMessage: 435. object (for
          ‘message/rfc822’ parts), or a ‘bytes’ object (for all other
          non-multipart types).  Raise a *note KeyError: 1a7. if called
          on a ‘multipart’.  If the part is a ‘text’ part and `errors'
          is specified, use it as the error handler when decoding the
          payload to unicode.  The default error handler is ‘replace’.

      -- Method: email.contentmanager.set_content (msg, <'str'>,
               subtype="plain", charset='utf-8' cte=None,
               disposition=None, filename=None, cid=None, params=None,
               headers=None)

      -- Method: email.contentmanager.set_content (msg, <'bytes'>,
               maintype, subtype, cte="base64", disposition=None,
               filename=None, cid=None, params=None, headers=None)

      -- Method: email.contentmanager.set_content (msg, <'Message'>,
               cte=None, disposition=None, filename=None, cid=None,
               params=None, headers=None)

      -- Method: email.contentmanager.set_content (msg, <'list'>,
               subtype='mixed', disposition=None, filename=None,
               cid=None, params=None, headers=None)

          Add headers and payload to `msg':

          Add a ‘Content-Type’ header with a ‘maintype/subtype’ value.

                  * For ‘str’, set the MIME ‘maintype’ to ‘text’, and
                    set the subtype to `subtype' if it is specified, or
                    ‘plain’ if it is not.

                  * For ‘bytes’, use the specified `maintype' and
                    `subtype', or raise a *note TypeError: 562. if they
                    are not specified.

                  * For *note Message: 3d2. objects, set the maintype to
                    ‘message’, and set the subtype to `subtype' if it is
                    specified or ‘rfc822’ if it is not.  If `subtype' is
                    ‘partial’, raise an error (‘bytes’ objects must be
                    used to construct ‘message/partial’ parts).

                  * For `<’list’>', which should be a list of *note
                    Message: 3d2. objects, set the ‘maintype’ to
                    ‘multipart’, and the ‘subtype’ to `subtype' if it is
                    specified, and ‘mixed’ if it is not.  If the message
                    parts in the `<’list’>' have ‘MIME-Version’ headers,
                    remove them.

          If `charset' is provided (which is valid only for ‘str’),
          encode the string to bytes using the specified character set.
          The default is ‘utf-8’.  If the specified `charset' is a known
          alias for a standard MIME charset name, use the standard
          charset instead.

          If `cte' is set, encode the payload using the specified
          content transfer encoding, and set the
          ‘Content-Transfer-Endcoding’ header to that value.  For ‘str’
          objects, if it is not set use heuristics to determine the most
          compact encoding.  Possible values for `cte' are
          ‘quoted-printable’, ‘base64’, ‘7bit’, ‘8bit’, and ‘binary’.
          If the input cannot be encoded in the specified encoding (eg:
          ‘7bit’), raise a *note ValueError: 19c.  For *note Message:
          3d2, per RFC 2046(1), raise an error if a `cte' of
          ‘quoted-printable’ or ‘base64’ is requested for `subtype'
          ‘rfc822’, and for any `cte' other than ‘7bit’ for `subtype'
          ‘external-body’.  For ‘message/rfc822’, use ‘8bit’ if `cte' is
          not specified.  For all other values of `subtype', use ‘7bit’.

               Note: A `cte' of ‘binary’ does not actually work
               correctly yet.  The ‘Message’ object as modified by
               ‘set_content’ is correct, but *note BytesGenerator: 796.
               does not serialize it correctly.

          If `disposition' is set, use it as the value of the
          ‘Content-Disposition’ header.  If not specified, and
          `filename' is specified, add the header with the value
          ‘attachment’.  If it is not specified and `filename' is also
          not specified, do not add the header.  The only valid values
          for `disposition' are ‘attachment’ and ‘inline’.

          If `filename' is specified, use it as the value of the
          ‘filename’ parameter of the ‘Content-Disposition’ header.
          There is no default.

          If `cid' is specified, add a ‘Content-ID’ header with `cid' as
          its value.

          If `params' is specified, iterate its ‘items’ method and use
          the resulting ‘(key, value)’ pairs to set additional
          parameters on the ‘Content-Type’ header.

          If `headers' is specified and is a list of strings of the form
          ‘headername: headervalue’ or a list of ‘header’ objects
          (distinguised from strings by having a ‘name’ attribute), add
          the headers to `msg'.

   ---------- Footnotes ----------

   (1) https://tools.ietf.org/html/rfc2046.html


File: python.info,  Node: email mime Creating email and MIME objects from scratch,  Next: email header Internationalized headers,  Prev: email contentmanager Managing MIME Content,  Up: email --- An email and MIME handling package

5.19.1.11 ‘email.mime’: Creating email and MIME objects from scratch
....................................................................

Ordinarily, you get a message object structure by passing a file or some
text to a parser, which parses the text and returns the root message
object.  However you can also build a complete message structure from
scratch, or even individual *note Message: 3d2. objects by hand.  In
fact, you can also take an existing structure and add new *note Message:
3d2. objects, move them around, etc.  This makes a very convenient
interface for slicing-and-dicing MIME messages.

You can create a new object structure by creating *note Message: 3d2.
instances, adding attachments and all the appropriate headers manually.
For MIME messages though, the *note email: 67. package provides some
convenient subclasses to make things easier.

Here are the classes:

 -- Class: email.mime.base.MIMEBase (_maintype, _subtype, **_params)

     Module: ‘email.mime.base’

     This is the base class for all the MIME-specific subclasses of
     *note Message: 3d2.  Ordinarily you won’t create instances
     specifically of *note MIMEBase: 2149, although you could.  *note
     MIMEBase: 2149. is provided primarily as a convenient base class
     for more specific MIME-aware subclasses.

     `_maintype' is the ‘Content-Type’ major type (e.g.  ‘text’ or
     ‘image’), and `_subtype' is the ‘Content-Type’ minor type (e.g.
     ‘plain’ or ‘gif’).  `_params' is a parameter key/value dictionary
     and is passed directly to *note Message.add_header: 20b6.

     The *note MIMEBase: 2149. class always adds a ‘Content-Type’ header
     (based on `_maintype', `_subtype', and `_params'), and a
     ‘MIME-Version’ header (always set to ‘1.0’).

 -- Class: email.mime.nonmultipart.MIMENonMultipart

     Module: ‘email.mime.nonmultipart’

     A subclass of *note MIMEBase: 2149, this is an intermediate base
     class for MIME messages that are not ‘multipart’.  The primary
     purpose of this class is to prevent the use of the *note attach():
     20a7. method, which only makes sense for ‘multipart’ messages.  If
     *note attach(): 20a7. is called, a *note MultipartConversionError:
     214b. exception is raised.

 -- Class: email.mime.multipart.MIMEMultipart (_subtype='mixed',
          boundary=None, _subparts=None, **_params)

     Module: ‘email.mime.multipart’

     A subclass of *note MIMEBase: 2149, this is an intermediate base
     class for MIME messages that are ‘multipart’.  Optional `_subtype'
     defaults to ‘mixed’, but can be used to specify the subtype of the
     message.  A ‘Content-Type’ header of ‘multipart/_subtype’ will be
     added to the message object.  A ‘MIME-Version’ header will also be
     added.

     Optional `boundary' is the multipart boundary string.  When ‘None’
     (the default), the boundary is calculated when needed (for example,
     when the message is serialized).

     `_subparts' is a sequence of initial subparts for the payload.  It
     must be possible to convert this sequence to a list.  You can
     always attach new subparts to the message by using the *note
     Message.attach: 20a7. method.

     Additional parameters for the ‘Content-Type’ header are taken from
     the keyword arguments, or passed into the `_params' argument, which
     is a keyword dictionary.

 -- Class: email.mime.application.MIMEApplication (_data,
          _subtype='octet-stream',
          _encoder=email.encoders.encode_base64, **_params)

     Module: ‘email.mime.application’

     A subclass of *note MIMENonMultipart: 214a, the *note
     MIMEApplication: 214d. class is used to represent MIME message
     objects of major type ‘application’.  `_data' is a string
     containing the raw byte data.  Optional `_subtype' specifies the
     MIME subtype and defaults to ‘octet-stream’.

     Optional `_encoder' is a callable (i.e.  function) which will
     perform the actual encoding of the data for transport.  This
     callable takes one argument, which is the *note MIMEApplication:
     214d. instance.  It should use *note get_payload(): 794. and *note
     set_payload(): 20a8. to change the payload to encoded form.  It
     should also add any ‘Content-Transfer-Encoding’ or other headers to
     the message object as necessary.  The default encoding is base64.
     See the *note email.encoders: 6a. module for a list of the built-in
     encoders.

     `_params' are passed straight through to the base class
     constructor.

 -- Class: email.mime.audio.MIMEAudio (_audiodata, _subtype=None,
          _encoder=email.encoders.encode_base64, **_params)

     Module: ‘email.mime.audio’

     A subclass of *note MIMENonMultipart: 214a, the *note MIMEAudio:
     214e. class is used to create MIME message objects of major type
     ‘audio’.  `_audiodata' is a string containing the raw audio data.
     If this data can be decoded by the standard Python module *note
     sndhdr: ec, then the subtype will be automatically included in the
     ‘Content-Type’ header.  Otherwise you can explicitly specify the
     audio subtype via the `_subtype' argument.  If the minor type could
     not be guessed and `_subtype' was not given, then *note TypeError:
     562. is raised.

     Optional `_encoder' is a callable (i.e.  function) which will
     perform the actual encoding of the audio data for transport.  This
     callable takes one argument, which is the *note MIMEAudio: 214e.
     instance.  It should use *note get_payload(): 794. and *note
     set_payload(): 20a8. to change the payload to encoded form.  It
     should also add any ‘Content-Transfer-Encoding’ or other headers to
     the message object as necessary.  The default encoding is base64.
     See the *note email.encoders: 6a. module for a list of the built-in
     encoders.

     `_params' are passed straight through to the base class
     constructor.

 -- Class: email.mime.image.MIMEImage (_imagedata, _subtype=None,
          _encoder=email.encoders.encode_base64, **_params)

     Module: ‘email.mime.image’

     A subclass of *note MIMENonMultipart: 214a, the *note MIMEImage:
     214f. class is used to create MIME message objects of major type
     ‘image’.  `_imagedata' is a string containing the raw image data.
     If this data can be decoded by the standard Python module *note
     imghdr: 98, then the subtype will be automatically included in the
     ‘Content-Type’ header.  Otherwise you can explicitly specify the
     image subtype via the `_subtype' argument.  If the minor type could
     not be guessed and `_subtype' was not given, then *note TypeError:
     562. is raised.

     Optional `_encoder' is a callable (i.e.  function) which will
     perform the actual encoding of the image data for transport.  This
     callable takes one argument, which is the *note MIMEImage: 214f.
     instance.  It should use *note get_payload(): 794. and *note
     set_payload(): 20a8. to change the payload to encoded form.  It
     should also add any ‘Content-Transfer-Encoding’ or other headers to
     the message object as necessary.  The default encoding is base64.
     See the *note email.encoders: 6a. module for a list of the built-in
     encoders.

     `_params' are passed straight through to the *note MIMEBase: 2149.
     constructor.

 -- Class: email.mime.message.MIMEMessage (_msg, _subtype='rfc822')

     Module: ‘email.mime.message’

     A subclass of *note MIMENonMultipart: 214a, the *note MIMEMessage:
     2150. class is used to create MIME objects of main type ‘message’.
     `_msg' is used as the payload, and must be an instance of class
     *note Message: 3d2. (or a subclass thereof), otherwise a *note
     TypeError: 562. is raised.

     Optional `_subtype' sets the subtype of the message; it defaults to
     ‘rfc822’.

 -- Class: email.mime.text.MIMEText (_text, _subtype='plain',
          _charset=None)

     Module: ‘email.mime.text’

     A subclass of *note MIMENonMultipart: 214a, the *note MIMEText:
     283. class is used to create MIME objects of major type ‘text’.
     `_text' is the string for the payload.  `_subtype' is the minor
     type and defaults to ‘plain’.  `_charset' is the character set of
     the text and is passed as an argument to the *note
     MIMENonMultipart: 214a. constructor; it defaults to ‘us-ascii’ if
     the string contains only ‘ascii’ code points, and ‘utf-8’
     otherwise.  The `_charset' parameter accepts either a string or a
     *note Charset: 284. instance.

     Unless the `_charset' argument is explicitly set to ‘None’, the
     MIMEText object created will have both a ‘Content-Type’ header with
     a ‘charset’ parameter, and a ‘Content-Transfer-Endcoding’ header.
     This means that a subsequent ‘set_payload’ call will not result in
     an encoded payload, even if a charset is passed in the
     ‘set_payload’ command.  You can "reset" this behavior by deleting
     the ‘Content-Transfer-Encoding’ header, after which a ‘set_payload’
     call will automatically encode the new payload (and add a new
     ‘Content-Transfer-Encoding’ header).

     Changed in version 3.5: `_charset' also accepts *note Charset: 284.
     instances.


File: python.info,  Node: email header Internationalized headers,  Next: email charset Representing character sets,  Prev: email mime Creating email and MIME objects from scratch,  Up: email --- An email and MIME handling package

5.19.1.12 ‘email.header’: Internationalized headers
...................................................

RFC 2822(1) is the base standard that describes the format of email
messages.  It derives from the older RFC 822(2) standard which came into
widespread use at a time when most email was composed of ASCII
characters only.  RFC 2822(3) is a specification written assuming email
contains only 7-bit ASCII characters.

Of course, as email has been deployed worldwide, it has become
internationalized, such that language specific character sets can now be
used in email messages.  The base standard still requires email messages
to be transferred using only 7-bit ASCII characters, so a slew of RFCs
have been written describing how to encode email containing non-ASCII
characters into RFC 2822(4)-compliant format.  These RFCs include RFC
2045(5), RFC 2046(6), RFC 2047(7), and RFC 2231(8).  The *note email:
67. package supports these standards in its *note email.header: 6d. and
*note email.charset: 68. modules.

If you want to include non-ASCII characters in your email headers, say
in the ‘Subject’ or ‘To’ fields, you should use the *note Header: 20ac.
class and assign the field in the *note Message: 3d2. object to an
instance of *note Header: 20ac. instead of using a string for the header
value.  Import the *note Header: 20ac. class from the *note
email.header: 6d. module.  For example:

     >>> from email.message import Message
     >>> from email.header import Header
     >>> msg = Message()
     >>> h = Header('p\xf6stal', 'iso-8859-1')
     >>> msg['Subject'] = h
     >>> msg.as_string()
     'Subject: =?iso-8859-1?q?p=F6stal?=\n\n'

Notice here how we wanted the ‘Subject’ field to contain a non-ASCII
character?  We did this by creating a *note Header: 20ac. instance and
passing in the character set that the byte string was encoded in.  When
the subsequent *note Message: 3d2. instance was flattened, the ‘Subject’
field was properly RFC 2047(9) encoded.  MIME-aware mail readers would
show this header using the embedded ISO-8859-1 character.

Here is the *note Header: 20ac. class description:

 -- Class: email.header.Header (s=None, charset=None, maxlinelen=None,
          header_name=None, continuation_ws=' ', errors='strict')

     Create a MIME-compliant header that can contain strings in
     different character sets.

     Optional `s' is the initial header value.  If ‘None’ (the default),
     the initial header value is not set.  You can later append to the
     header with *note append(): 2153. method calls.  `s' may be an
     instance of *note bytes: 1db. or *note str: 25a, but see the *note
     append(): 2153. documentation for semantics.

     Optional `charset' serves two purposes: it has the same meaning as
     the `charset' argument to the *note append(): 2153. method.  It
     also sets the default character set for all subsequent *note
     append(): 2153. calls that omit the `charset' argument.  If
     `charset' is not provided in the constructor (the default), the
     ‘us-ascii’ character set is used both as `s'’s initial charset and
     as the default for subsequent *note append(): 2153. calls.

     The maximum line length can be specified explicitly via
     `maxlinelen'.  For splitting the first line to a shorter value (to
     account for the field header which isn’t included in `s', e.g.
     ‘Subject’) pass in the name of the field in `header_name'.  The
     default `maxlinelen' is 76, and the default value for `header_name'
     is ‘None’, meaning it is not taken into account for the first line
     of a long, split header.

     Optional `continuation_ws' must be RFC 2822(10)-compliant folding
     whitespace, and is usually either a space or a hard tab character.
     This character will be prepended to continuation lines.
     `continuation_ws' defaults to a single space character.

     Optional `errors' is passed straight through to the *note append():
     2153. method.

      -- Method: append (s, charset=None, errors='strict')

          Append the string `s' to the MIME header.

          Optional `charset', if given, should be a *note Charset: 284.
          instance (see *note email.charset: 68.) or the name of a
          character set, which will be converted to a *note Charset:
          284. instance.  A value of ‘None’ (the default) means that the
          `charset' given in the constructor is used.

          `s' may be an instance of *note bytes: 1db. or *note str: 25a.
          If it is an instance of *note bytes: 1db, then `charset' is
          the encoding of that byte string, and a *note UnicodeError:
          8a2. will be raised if the string cannot be decoded with that
          character set.

          If `s' is an instance of *note str: 25a, then `charset' is a
          hint specifying the character set of the characters in the
          string.

          In either case, when producing an RFC 2822(11)-compliant
          header using RFC 2047(12) rules, the string will be encoded
          using the output codec of the charset.  If the string cannot
          be encoded using the output codec, a UnicodeError will be
          raised.

          Optional `errors' is passed as the errors argument to the
          decode call if `s' is a byte string.

      -- Method: encode (splitchars=';, \t', maxlinelen=None,
               linesep='\n')

          Encode a message header into an RFC-compliant format, possibly
          wrapping long lines and encapsulating non-ASCII parts in
          base64 or quoted-printable encodings.

          Optional `splitchars' is a string containing characters which
          should be given extra weight by the splitting algorithm during
          normal header wrapping.  This is in very rough support of RFC
          2822(13)’s ’higher level syntactic breaks’: split points
          preceded by a splitchar are preferred during line splitting,
          with the characters preferred in the order in which they
          appear in the string.  Space and tab may be included in the
          string to indicate whether preference should be given to one
          over the other as a split point when other split chars do not
          appear in the line being split.  Splitchars does not affect
          RFC 2047(14) encoded lines.

          `maxlinelen', if given, overrides the instance’s value for the
          maximum line length.

          `linesep' specifies the characters used to separate the lines
          of the folded header.  It defaults to the most useful value
          for Python application code (‘\n’), but ‘\r\n’ can be
          specified in order to produce headers with RFC-compliant line
          separators.

          Changed in version 3.2: Added the `linesep' argument.

     The *note Header: 20ac. class also provides a number of methods to
     support standard operators and built-in functions.

      -- Method: __str__ ()

          Returns an approximation of the *note Header: 20ac. as a
          string, using an unlimited line length.  All pieces are
          converted to unicode using the specified encoding and joined
          together appropriately.  Any pieces with a charset of
          ‘'unknown-8bit'’ are decoded as ASCII using the ‘'replace'’
          error handler.

          Changed in version 3.2: Added handling for the
          ‘'unknown-8bit'’ charset.

      -- Method: __eq__ (other)

          This method allows you to compare two *note Header: 20ac.
          instances for equality.

      -- Method: __ne__ (other)

          This method allows you to compare two *note Header: 20ac.
          instances for inequality.

The *note email.header: 6d. module also provides the following
convenient functions.

 -- Function: email.header.decode_header (header)

     Decode a message header value without converting the character set.
     The header value is in `header'.

     This function returns a list of ‘(decoded_string, charset)’ pairs
     containing each of the decoded parts of the header.  `charset' is
     ‘None’ for non-encoded parts of the header, otherwise a lower case
     string containing the name of the character set specified in the
     encoded string.

     Here’s an example:

          >>> from email.header import decode_header
          >>> decode_header('=?iso-8859-1?q?p=F6stal?=')
          [(b'p\xf6stal', 'iso-8859-1')]

 -- Function: email.header.make_header (decoded_seq, maxlinelen=None,
          header_name=None, continuation_ws=' ')

     Create a *note Header: 20ac. instance from a sequence of pairs as
     returned by *note decode_header(): 627.

     *note decode_header(): 627. takes a header value string and returns
     a sequence of pairs of the format ‘(decoded_string, charset)’ where
     `charset' is the name of the character set.

     This function takes one of those sequence of pairs and returns a
     *note Header: 20ac. instance.  Optional `maxlinelen',
     `header_name', and `continuation_ws' are as in the *note Header:
     20ac. constructor.

   ---------- Footnotes ----------

   (1) https://tools.ietf.org/html/rfc2822.html

   (2) https://tools.ietf.org/html/rfc822.html

   (3) https://tools.ietf.org/html/rfc2822.html

   (4) https://tools.ietf.org/html/rfc2822.html

   (5) https://tools.ietf.org/html/rfc2045.html

   (6) https://tools.ietf.org/html/rfc2046.html

   (7) https://tools.ietf.org/html/rfc2047.html

   (8) https://tools.ietf.org/html/rfc2231.html

   (9) https://tools.ietf.org/html/rfc2047.html

   (10) https://tools.ietf.org/html/rfc2822.html

   (11) https://tools.ietf.org/html/rfc2822.html

   (12) https://tools.ietf.org/html/rfc2047.html

   (13) https://tools.ietf.org/html/rfc2822.html

   (14) https://tools.ietf.org/html/rfc2047.html


File: python.info,  Node: email charset Representing character sets,  Next: email encoders Encoders,  Prev: email header Internationalized headers,  Up: email --- An email and MIME handling package

5.19.1.13 ‘email.charset’: Representing character sets
......................................................

This module provides a class *note Charset: 284. for representing
character sets and character set conversions in email messages, as well
as a character set registry and several convenience methods for
manipulating this registry.  Instances of *note Charset: 284. are used
in several other modules within the *note email: 67. package.

Import this class from the *note email.charset: 68. module.

 -- Class: email.charset.Charset (input_charset=DEFAULT_CHARSET)

     Map character sets to their email properties.

     This class provides information about the requirements imposed on
     email for a specific character set.  It also provides convenience
     routines for converting between character sets, given the
     availability of the applicable codecs.  Given a character set, it
     will do its best to provide information on how to use that
     character set in an email message in an RFC-compliant way.

     Certain character sets must be encoded with quoted-printable or
     base64 when used in email headers or bodies.  Certain character
     sets must be converted outright, and are not allowed in email.

     Optional `input_charset' is as described below; it is always
     coerced to lower case.  After being alias normalized it is also
     used as a lookup into the registry of character sets to find out
     the header encoding, body encoding, and output conversion codec to
     be used for the character set.  For example, if `input_charset' is
     ‘iso-8859-1’, then headers and bodies will be encoded using
     quoted-printable and no output conversion codec is necessary.  If
     `input_charset' is ‘euc-jp’, then headers will be encoded with
     base64, bodies will not be encoded, but output text will be
     converted from the ‘euc-jp’ character set to the ‘iso-2022-jp’
     character set.

     *note Charset: 284. instances have the following data attributes:

      -- Attribute: input_charset

          The initial character set specified.  Common aliases are
          converted to their `official' email names (e.g.  ‘latin_1’ is
          converted to ‘iso-8859-1’).  Defaults to 7-bit ‘us-ascii’.

      -- Attribute: header_encoding

          If the character set must be encoded before it can be used in
          an email header, this attribute will be set to ‘Charset.QP’
          (for quoted-printable), ‘Charset.BASE64’ (for base64
          encoding), or ‘Charset.SHORTEST’ for the shortest of QP or
          BASE64 encoding.  Otherwise, it will be ‘None’.

      -- Attribute: body_encoding

          Same as `header_encoding', but describes the encoding for the
          mail message’s body, which indeed may be different than the
          header encoding.  ‘Charset.SHORTEST’ is not allowed for
          `body_encoding'.

      -- Attribute: output_charset

          Some character sets must be converted before they can be used
          in email headers or bodies.  If the `input_charset' is one of
          them, this attribute will contain the name of the character
          set output will be converted to.  Otherwise, it will be
          ‘None’.

      -- Attribute: input_codec

          The name of the Python codec used to convert the
          `input_charset' to Unicode.  If no conversion codec is
          necessary, this attribute will be ‘None’.

      -- Attribute: output_codec

          The name of the Python codec used to convert Unicode to the
          `output_charset'.  If no conversion codec is necessary, this
          attribute will have the same value as the `input_codec'.

     *note Charset: 284. instances also have the following methods:

      -- Method: get_body_encoding ()

          Return the content transfer encoding used for body encoding.

          This is either the string ‘quoted-printable’ or ‘base64’
          depending on the encoding used, or it is a function, in which
          case you should call the function with a single argument, the
          Message object being encoded.  The function should then set
          the ‘Content-Transfer-Encoding’ header itself to whatever is
          appropriate.

          Returns the string ‘quoted-printable’ if `body_encoding' is
          ‘QP’, returns the string ‘base64’ if `body_encoding' is
          ‘BASE64’, and returns the string ‘7bit’ otherwise.

      -- Method: get_output_charset ()

          Return the output character set.

          This is the `output_charset' attribute if that is not ‘None’,
          otherwise it is `input_charset'.

      -- Method: header_encode (string)

          Header-encode the string `string'.

          The type of encoding (base64 or quoted-printable) will be
          based on the `header_encoding' attribute.

      -- Method: header_encode_lines (string, maxlengths)

          Header-encode a `string' by converting it first to bytes.

          This is similar to *note header_encode(): 2162. except that
          the string is fit into maximum line lengths as given by the
          argument `maxlengths', which must be an iterator: each element
          returned from this iterator will provide the next maximum line
          length.

      -- Method: body_encode (string)

          Body-encode the string `string'.

          The type of encoding (base64 or quoted-printable) will be
          based on the `body_encoding' attribute.

     The *note Charset: 284. class also provides a number of methods to
     support standard operations and built-in functions.

      -- Method: __str__ ()

          Returns `input_charset' as a string coerced to lower case.
          *note __repr__(): 7bd. is an alias for *note __str__(): 2165.

      -- Method: __eq__ (other)

          This method allows you to compare two *note Charset: 284.
          instances for equality.

      -- Method: __ne__ (other)

          This method allows you to compare two *note Charset: 284.
          instances for inequality.

The *note email.charset: 68. module also provides the following
functions for adding new entries to the global character set, alias, and
codec registries:

 -- Function: email.charset.add_charset (charset, header_enc=None,
          body_enc=None, output_charset=None)

     Add character properties to the global registry.

     `charset' is the input character set, and must be the canonical
     name of a character set.

     Optional `header_enc' and `body_enc' is either ‘Charset.QP’ for
     quoted-printable, ‘Charset.BASE64’ for base64 encoding,
     ‘Charset.SHORTEST’ for the shortest of quoted-printable or base64
     encoding, or ‘None’ for no encoding.  ‘SHORTEST’ is only valid for
     `header_enc'.  The default is ‘None’ for no encoding.

     Optional `output_charset' is the character set that the output
     should be in.  Conversions will proceed from input charset, to
     Unicode, to the output charset when the method ‘Charset.convert()’
     is called.  The default is to output in the same character set as
     the input.

     Both `input_charset' and `output_charset' must have Unicode codec
     entries in the module’s character set-to-codec mapping; use *note
     add_codec(): 2169. to add codecs the module does not know about.
     See the *note codecs: 1c. module’s documentation for more
     information.

     The global character set registry is kept in the module global
     dictionary ‘CHARSETS’.

 -- Function: email.charset.add_alias (alias, canonical)

     Add a character set alias.  `alias' is the alias name, e.g.
     ‘latin-1’.  `canonical' is the character set’s canonical name, e.g.
     ‘iso-8859-1’.

     The global charset alias registry is kept in the module global
     dictionary ‘ALIASES’.

 -- Function: email.charset.add_codec (charset, codecname)

     Add a codec that map characters in the given character set to and
     from Unicode.

     `charset' is the canonical name of a character set.  `codecname' is
     the name of a Python codec, as appropriate for the second argument
     to the *note str: 25a.’s *note encode(): 89d. method.


File: python.info,  Node: email encoders Encoders,  Next: email errors Exception and Defect classes,  Prev: email charset Representing character sets,  Up: email --- An email and MIME handling package

5.19.1.14 ‘email.encoders’: Encoders
....................................

When creating *note Message: 3d2. objects from scratch, you often need
to encode the payloads for transport through compliant mail servers.
This is especially true for ‘image/*’ and ‘text/*’ type messages
containing binary data.

The *note email: 67. package provides some convenient encodings in its
‘encoders’ module.  These encoders are actually used by the *note
MIMEAudio: 214e. and *note MIMEImage: 214f. class constructors to
provide default encodings.  All encoder functions take exactly one
argument, the message object to encode.  They usually extract the
payload, encode it, and reset the payload to this newly encoded value.
They should also set the ‘Content-Transfer-Encoding’ header as
appropriate.

Note that these functions are not meaningful for a multipart message.
They must be applied to individual subparts instead, and will raise a
*note TypeError: 562. if passed a message whose type is multipart.

Here are the encoding functions provided:

 -- Function: email.encoders.encode_quopri (msg)

     Encodes the payload into quoted-printable form and sets the
     ‘Content-Transfer-Encoding’ header to ‘quoted-printable’ (1).  This
     is a good encoding to use when most of your payload is normal
     printable data, but contains a few unprintable characters.

 -- Function: email.encoders.encode_base64 (msg)

     Encodes the payload into base64 form and sets the
     ‘Content-Transfer-Encoding’ header to ‘base64’.  This is a good
     encoding to use when most of your payload is unprintable data since
     it is a more compact form than quoted-printable.  The drawback of
     base64 encoding is that it renders the text non-human readable.

 -- Function: email.encoders.encode_7or8bit (msg)

     This doesn’t actually modify the message’s payload, but it does set
     the ‘Content-Transfer-Encoding’ header to either ‘7bit’ or ‘8bit’
     as appropriate, based on the payload data.

 -- Function: email.encoders.encode_noop (msg)

     This does nothing; it doesn’t even set the
     ‘Content-Transfer-Encoding’ header.

   ---------- Footnotes ----------

   (1) Note that encoding with *note encode_quopri(): 216d. also encodes
all tabs and space characters in the data.


File: python.info,  Node: email errors Exception and Defect classes,  Next: email utils Miscellaneous utilities,  Prev: email encoders Encoders,  Up: email --- An email and MIME handling package

5.19.1.15 ‘email.errors’: Exception and Defect classes
......................................................

The following exception classes are defined in the *note email.errors:
6b. module:

 -- Exception: email.errors.MessageError

     This is the base class for all exceptions that the *note email: 67.
     package can raise.  It is derived from the standard *note
     Exception: 1a1. class and defines no additional methods.

 -- Exception: email.errors.MessageParseError

     This is the base class for exceptions raised by the *note Parser:
     75a. class.  It is derived from *note MessageError: 2173.

 -- Exception: email.errors.HeaderParseError

     Raised under some error conditions when parsing the RFC 2822(1)
     headers of a message, this class is derived from *note
     MessageParseError: 2174.  It can be raised from the *note
     Parser.parse: 20d4. or *note Parser.parsestr: 20d5. methods.

     Situations where it can be raised include finding an envelope
     header after the first RFC 2822(2) header of the message, finding a
     continuation line before the first RFC 2822(3) header is found, or
     finding a line in the headers which is neither a header or a
     continuation line.

 -- Exception: email.errors.BoundaryError

     Raised under some error conditions when parsing the RFC 2822(4)
     headers of a message, this class is derived from *note
     MessageParseError: 2174.  It can be raised from the *note
     Parser.parse: 20d4. or *note Parser.parsestr: 20d5. methods.

     Situations where it can be raised include not being able to find
     the starting or terminating boundary in a ‘multipart/*’ message
     when strict parsing is used.

 -- Exception: email.errors.MultipartConversionError

     Raised when a payload is added to a *note Message: 3d2. object
     using ‘add_payload()’, but the payload is already a scalar and the
     message’s ‘Content-Type’ main type is not either ‘multipart’ or
     missing.  *note MultipartConversionError: 214b. multiply inherits
     from *note MessageError: 2173. and the built-in *note TypeError:
     562.

     Since ‘Message.add_payload()’ is deprecated, this exception is
     rarely raised in practice.  However the exception may also be
     raised if the *note attach(): 20a7. method is called on an instance
     of a class derived from *note MIMENonMultipart: 214a. (e.g.  *note
     MIMEImage: 214f.).

Here’s the list of the defects that the *note FeedParser: 20cf. can find
while parsing messages.  Note that the defects are added to the message
where the problem was found, so for example, if a message nested inside
a ‘multipart/alternative’ had a malformed header, that nested message
object would have a defect, but the containing messages would not.

All defect classes are subclassed from ‘email.errors.MessageDefect’, but
this class is `not' an exception!

   * ‘NoBoundaryInMultipartDefect’ – A message claimed to be a
     multipart, but had no ‘boundary’ parameter.

   * ‘StartBoundaryNotFoundDefect’ – The start boundary claimed in the
     ‘Content-Type’ header was never found.

   * ‘CloseBoundaryNotFoundDefect’ – A start boundary was found, but no
     corresponding close boundary was ever found.

     New in version 3.3.

   * ‘FirstHeaderLineIsContinuationDefect’ – The message had a
     continuation line as its first header line.

   * ‘MisplacedEnvelopeHeaderDefect’ - A "Unix From" header was found in
     the middle of a header block.

   * ‘MissingHeaderBodySeparatorDefect’ - A line was found while parsing
     headers that had no leading white space but contained no ’:’.
     Parsing continues assuming that the line represents the first line
     of the body.

     New in version 3.3.

   * ‘MalformedHeaderDefect’ – A header was found that was missing a
     colon, or was otherwise malformed.

     Deprecated since version 3.3: This defect has not been used for
     several Python versions.

   * ‘MultipartInvariantViolationDefect’ – A message claimed to be a
     ‘multipart’, but no subparts were found.  Note that when a message
     has this defect, its *note is_multipart(): 20a4. method may return
     false even though its content type claims to be ‘multipart’.

   * ‘InvalidBase64PaddingDefect’ – When decoding a block of base64
     enocded bytes, the padding was not correct.  Enough padding is
     added to perform the decode, but the resulting decoded bytes may be
     invalid.

   * ‘InvalidBase64CharactersDefect’ – When decoding a block of base64
     enocded bytes, characters outside the base64 alphebet were
     encountered.  The characters are ignored, but the resulting decoded
     bytes may be invalid.

   ---------- Footnotes ----------

   (1) https://tools.ietf.org/html/rfc2822.html

   (2) https://tools.ietf.org/html/rfc2822.html

   (3) https://tools.ietf.org/html/rfc2822.html

   (4) https://tools.ietf.org/html/rfc2822.html


File: python.info,  Node: email utils Miscellaneous utilities,  Next: email iterators Iterators,  Prev: email errors Exception and Defect classes,  Up: email --- An email and MIME handling package

5.19.1.16 ‘email.utils’: Miscellaneous utilities
................................................

There are several useful utilities provided in the *note email.utils:
74. module:

 -- Function: email.utils.quote (str)

     Return a new string with backslashes in `str' replaced by two
     backslashes, and double quotes replaced by backslash-double quote.

 -- Function: email.utils.unquote (str)

     Return a new string which is an `unquoted' version of `str'.  If
     `str' ends and begins with double quotes, they are stripped off.
     Likewise if `str' ends and begins with angle brackets, they are
     stripped off.

 -- Function: email.utils.parseaddr (address)

     Parse address – which should be the value of some
     address-containing field such as ‘To’ or ‘Cc’ – into its
     constituent `realname' and `email address' parts.  Returns a tuple
     of that information, unless the parse fails, in which case a
     2-tuple of ‘('', '')’ is returned.

 -- Function: email.utils.formataddr (pair, charset='utf-8')

     The inverse of *note parseaddr(): 2179, this takes a 2-tuple of the
     form ‘(realname, email_address)’ and returns the string value
     suitable for a ‘To’ or ‘Cc’ header.  If the first element of `pair'
     is false, then the second element is returned unmodified.

     Optional `charset' is the character set that will be used in the
     RFC 2047(1) encoding of the ‘realname’ if the ‘realname’ contains
     non-ASCII characters.  Can be an instance of *note str: 25a. or a
     *note Charset: 284.  Defaults to ‘utf-8’.

     Changed in version 3.3: Added the `charset' option.

 -- Function: email.utils.getaddresses (fieldvalues)

     This method returns a list of 2-tuples of the form returned by
     ‘parseaddr()’.  `fieldvalues' is a sequence of header field values
     as might be returned by *note Message.get_all: 20b0.  Here’s a
     simple example that gets all the recipients of a message:

          from email.utils import getaddresses

          tos = msg.get_all('to', [])
          ccs = msg.get_all('cc', [])
          resent_tos = msg.get_all('resent-to', [])
          resent_ccs = msg.get_all('resent-cc', [])
          all_recipients = getaddresses(tos + ccs + resent_tos + resent_ccs)

 -- Function: email.utils.parsedate (date)

     Attempts to parse a date according to the rules in RFC 2822(2).
     however, some mailers don’t follow that format as specified, so
     *note parsedate(): 217b. tries to guess correctly in such cases.
     `date' is a string containing an RFC 2822(3) date, such as ‘"Mon,
     20 Nov 1995 19:12:08 -0500"’.  If it succeeds in parsing the date,
     *note parsedate(): 217b. returns a 9-tuple that can be passed
     directly to *note time.mktime(): 7b0.; otherwise ‘None’ will be
     returned.  Note that indexes 6, 7, and 8 of the result tuple are
     not usable.

 -- Function: email.utils.parsedate_tz (date)

     Performs the same function as *note parsedate(): 217b, but returns
     either ‘None’ or a 10-tuple; the first 9 elements make up a tuple
     that can be passed directly to *note time.mktime(): 7b0, and the
     tenth is the offset of the date’s timezone from UTC (which is the
     official term for Greenwich Mean Time) (4).  If the input string
     has no timezone, the last element of the tuple returned is ‘None’.
     Note that indexes 6, 7, and 8 of the result tuple are not usable.

 -- Function: email.utils.parsedate_to_datetime (date)

     The inverse of *note format_datetime(): 62a.  Performs the same
     function as *note parsedate(): 217b, but on success returns a *note
     datetime: 60c.  If the input date has a timezone of ‘-0000’, the
     ‘datetime’ will be a naive ‘datetime’, and if the date is
     conforming to the RFCs it will represent a time in UTC but with no
     indication of the actual source timezone of the message the date
     comes from.  If the input date has any other valid timezone offset,
     the ‘datetime’ will be an aware ‘datetime’ with the corresponding a
     *note timezone: 62d. *note tzinfo: 7ad.

     New in version 3.3.

 -- Function: email.utils.mktime_tz (tuple)

     Turn a 10-tuple as returned by *note parsedate_tz(): 217c. into a
     UTC timestamp (seconds since the Epoch).  If the timezone item in
     the tuple is ‘None’, assume local time.

 -- Function: email.utils.formatdate (timeval=None, localtime=False,
          usegmt=False)

     Returns a date string as per RFC 2822(5), e.g.:

          Fri, 09 Nov 2001 01:08:47 -0000

     Optional `timeval' if given is a floating point time value as
     accepted by *note time.gmtime(): 786. and *note time.localtime():
     125d, otherwise the current time is used.

     Optional `localtime' is a flag that when ‘True’, interprets
     `timeval', and returns a date relative to the local timezone
     instead of UTC, properly taking daylight savings time into account.
     The default is ‘False’ meaning UTC is used.

     Optional `usegmt' is a flag that when ‘True’, outputs a date string
     with the timezone as an ascii string ‘GMT’, rather than a numeric
     ‘-0000’.  This is needed for some protocols (such as HTTP). This
     only applies when `localtime' is ‘False’.  The default is ‘False’.

 -- Function: email.utils.format_datetime (dt, usegmt=False)

     Like ‘formatdate’, but the input is a *note datetime: 2f. instance.
     If it is a naive datetime, it is assumed to be "UTC with no
     information about the source timezone", and the conventional
     ‘-0000’ is used for the timezone.  If it is an aware ‘datetime’,
     then the numeric timezone offset is used.  If it is an aware
     timezone with offset zero, then `usegmt' may be set to ‘True’, in
     which case the string ‘GMT’ is used instead of the numeric timezone
     offset.  This provides a way to generate standards conformant HTTP
     date headers.

     New in version 3.3.

 -- Function: email.utils.localtime (dt=None)

     Return local time as an aware datetime object.  If called without
     arguments, return current time.  Otherwise `dt' argument should be
     a *note datetime: 60c. instance, and it is converted to the local
     time zone according to the system time zone database.  If `dt' is
     naive (that is, ‘dt.tzinfo’ is ‘None’), it is assumed to be in
     local time.  In this case, a positive or zero value for `isdst'
     causes ‘localtime’ to presume initially that summer time (for
     example, Daylight Saving Time) is or is not (respectively) in
     effect for the specified time.  A negative value for `isdst' causes
     the ‘localtime’ to attempt to divine whether summer time is in
     effect for the specified time.

     New in version 3.3.

 -- Function: email.utils.make_msgid (idstring=None, domain=None)

     Returns a string suitable for an RFC 2822(6)-compliant ‘Message-ID’
     header.  Optional `idstring' if given, is a string used to
     strengthen the uniqueness of the message id.  Optional `domain' if
     given provides the portion of the msgid after the ’@’.  The default
     is the local hostname.  It is not normally necessary to override
     this default, but may be useful certain cases, such as a
     constructing distributed system that uses a consistent domain name
     across multiple hosts.

     Changed in version 3.2: Added the `domain' keyword.

 -- Function: email.utils.decode_rfc2231 (s)

     Decode the string `s' according to RFC 2231(7).

 -- Function: email.utils.encode_rfc2231 (s, charset=None,
          language=None)

     Encode the string `s' according to RFC 2231(8).  Optional `charset'
     and `language', if given is the character set name and language
     name to use.  If neither is given, `s' is returned as-is.  If
     `charset' is given but `language' is not, the string is encoded
     using the empty string for `language'.

 -- Function: email.utils.collapse_rfc2231_value (value,
          errors='replace', fallback_charset='us-ascii')

     When a header parameter is encoded in RFC 2231(9) format, *note
     Message.get_param: 20be. may return a 3-tuple containing the
     character set, language, and value.  *note
     collapse_rfc2231_value(): 20bf. turns this into a unicode string.
     Optional `errors' is passed to the `errors' argument of *note str:
     25a.’s *note encode(): 89d. method; it defaults to ‘'replace'’.
     Optional `fallback_charset' specifies the character set to use if
     the one in the RFC 2231(10) header is not known by Python; it
     defaults to ‘'us-ascii'’.

     For convenience, if the `value' passed to *note
     collapse_rfc2231_value(): 20bf. is not a tuple, it should be a
     string and it is returned unquoted.

 -- Function: email.utils.decode_params (params)

     Decode parameters list according to RFC 2231(11).  `params' is a
     sequence of 2-tuples containing elements of the form
     ‘(content-type, string-value)’.

   ---------- Footnotes ----------

   (1) https://tools.ietf.org/html/rfc2047.html

   (2) https://tools.ietf.org/html/rfc2822.html

   (3) https://tools.ietf.org/html/rfc2822.html

   (4) Note that the sign of the timezone offset is the opposite of the
sign of the ‘time.timezone’ variable for the same timezone; the latter
variable follows the POSIX standard while this module follows RFC 2822
(https://tools.ietf.org/html/rfc2822.html).

   (5) https://tools.ietf.org/html/rfc2822.html

   (6) https://tools.ietf.org/html/rfc2822.html

   (7) https://tools.ietf.org/html/rfc2231.html

   (8) https://tools.ietf.org/html/rfc2231.html

   (9) https://tools.ietf.org/html/rfc2231.html

   (10) https://tools.ietf.org/html/rfc2231.html

   (11) https://tools.ietf.org/html/rfc2231.html


File: python.info,  Node: email iterators Iterators,  Next: email Examples,  Prev: email utils Miscellaneous utilities,  Up: email --- An email and MIME handling package

5.19.1.17 ‘email.iterators’: Iterators
......................................

Iterating over a message object tree is fairly easy with the *note
Message.walk: 20c9. method.  The *note email.iterators: 6f. module
provides some useful higher level iterations over message object trees.

 -- Function: email.iterators.body_line_iterator (msg, decode=False)

     This iterates over all the payloads in all the subparts of `msg',
     returning the string payloads line-by-line.  It skips over all the
     subpart headers, and it skips over any subpart with a payload that
     isn’t a Python string.  This is somewhat equivalent to reading the
     flat text representation of the message from a file using *note
     readline(): faa, skipping over all the intervening headers.

     Optional `decode' is passed through to *note Message.get_payload:
     794.

 -- Function: email.iterators.typed_subpart_iterator (msg,
          maintype='text', subtype=None)

     This iterates over all the subparts of `msg', returning only those
     subparts that match the MIME type specified by `maintype' and
     `subtype'.

     Note that `subtype' is optional; if omitted, then subpart MIME type
     matching is done only with the main type.  `maintype' is optional
     too; it defaults to ‘text’.

     Thus, by default *note typed_subpart_iterator(): 2186. returns each
     subpart that has a MIME type of ‘text/*’.

The following function has been added as a useful debugging tool.  It
should `not' be considered part of the supported public interface for
the package.

 -- Function: email.iterators._structure (msg, fp=None, level=0,
          include_default=False)

     Prints an indented representation of the content types of the
     message object structure.  For example:

          >>> msg = email.message_from_file(somefile)
          >>> _structure(msg)
          multipart/mixed
              text/plain
              text/plain
              multipart/digest
                  message/rfc822
                      text/plain
                  message/rfc822
                      text/plain
                  message/rfc822
                      text/plain
                  message/rfc822
                      text/plain
                  message/rfc822
                      text/plain
              text/plain

     Optional `fp' is a file-like object to print the output to.  It
     must be suitable for Python’s *note print(): 481. function.
     `level' is used internally.  `include_default', if true, prints the
     default type as well.


File: python.info,  Node: email Examples,  Next: Package History,  Prev: email iterators Iterators,  Up: email --- An email and MIME handling package

5.19.1.18 ‘email’: Examples
...........................

Here are a few examples of how to use the *note email: 67. package to
read, write, and send simple email messages, as well as more complex
MIME messages.

First, let’s see how to create and send a simple text message:

     # Import smtplib for the actual sending function
     import smtplib

     # Import the email modules we'll need
     from email.mime.text import MIMEText

     # Open a plain text file for reading.  For this example, assume that
     # the text file contains only ASCII characters.
     with open(textfile) as fp:
         # Create a text/plain message
         msg = MIMEText(fp.read())

     # me == the sender's email address
     # you == the recipient's email address
     msg['Subject'] = 'The contents of %s' % textfile
     msg['From'] = me
     msg['To'] = you

     # Send the message via our own SMTP server.
     s = smtplib.SMTP('localhost')
     s.send_message(msg)
     s.quit()

And parsing RFC822 headers can easily be done by the parse(filename) or
parsestr(message_as_string) methods of the Parser() class:

     # Import the email modules we'll need
     from email.parser import Parser

     # If the e-mail headers are in a file, uncomment these two lines:
     # with open(messagefile) as fp:
     #     headers = Parser().parse(fp)

     #  Or for parsing headers in a string, use:
     headers = Parser().parsestr('From: <user@example.com>\n'
             'To: <someone_else@example.com>\n'
             'Subject: Test message\n'
             '\n'
             'Body would go here\n')

     #  Now the header items can be accessed as a dictionary:
     print('To: %s' % headers['to'])
     print('From: %s' % headers['from'])
     print('Subject: %s' % headers['subject'])

Here’s an example of how to send a MIME message containing a bunch of
family pictures that may be residing in a directory:

     # Import smtplib for the actual sending function
     import smtplib

     # Here are the email package modules we'll need
     from email.mime.image import MIMEImage
     from email.mime.multipart import MIMEMultipart

     COMMASPACE = ', '

     # Create the container (outer) email message.
     msg = MIMEMultipart()
     msg['Subject'] = 'Our family reunion'
     # me == the sender's email address
     # family = the list of all recipients' email addresses
     msg['From'] = me
     msg['To'] = COMMASPACE.join(family)
     msg.preamble = 'Our family reunion'

     # Assume we know that the image files are all in PNG format
     for file in pngfiles:
         # Open the files in binary mode.  Let the MIMEImage class automatically
         # guess the specific image type.
         with open(file, 'rb') as fp:
             img = MIMEImage(fp.read())
         msg.attach(img)

     # Send the email via our own SMTP server.
     s = smtplib.SMTP('localhost')
     s.send_message(msg)
     s.quit()

Here’s an example of how to send the entire contents of a directory as
an email message: (1)

     #!/usr/bin/env python3

     """Send the contents of a directory as a MIME message."""

     import os
     import sys
     import smtplib
     # For guessing MIME type based on file name extension
     import mimetypes

     from argparse import ArgumentParser

     from email import encoders
     from email.message import Message
     from email.mime.audio import MIMEAudio
     from email.mime.base import MIMEBase
     from email.mime.image import MIMEImage
     from email.mime.multipart import MIMEMultipart
     from email.mime.text import MIMEText

     COMMASPACE = ', '


     def main():
         parser = ArgumentParser(description="""\
     Send the contents of a directory as a MIME message.
     Unless the -o option is given, the email is sent by forwarding to your local
     SMTP server, which then does the normal delivery process.  Your local machine
     must be running an SMTP server.
     """)
         parser.add_argument('-d', '--directory',
                             help="""Mail the contents of the specified directory,
                             otherwise use the current directory.  Only the regular
                             files in the directory are sent, and we don't recurse to
                             subdirectories.""")
         parser.add_argument('-o', '--output',
                             metavar='FILE',
                             help="""Print the composed message to FILE instead of
                             sending the message to the SMTP server.""")
         parser.add_argument('-s', '--sender', required=True,
                             help='The value of the From: header (required)')
         parser.add_argument('-r', '--recipient', required=True,
                             action='append', metavar='RECIPIENT',
                             default=[], dest='recipients',
                             help='A To: header value (at least one required)')
         args = parser.parse_args()
         directory = args.directory
         if not directory:
             directory = '.'
         # Create the enclosing (outer) message
         outer = MIMEMultipart()
         outer['Subject'] = 'Contents of directory %s' % os.path.abspath(directory)
         outer['To'] = COMMASPACE.join(args.recipients)
         outer['From'] = args.sender
         outer.preamble = 'You will not see this in a MIME-aware mail reader.\n'

         for filename in os.listdir(directory):
             path = os.path.join(directory, filename)
             if not os.path.isfile(path):
                 continue
             # Guess the content type based on the file's extension.  Encoding
             # will be ignored, although we should check for simple things like
             # gzip'd or compressed files.
             ctype, encoding = mimetypes.guess_type(path)
             if ctype is None or encoding is not None:
                 # No guess could be made, or the file is encoded (compressed), so
                 # use a generic bag-of-bits type.
                 ctype = 'application/octet-stream'
             maintype, subtype = ctype.split('/', 1)
             if maintype == 'text':
                 with open(path) as fp:
                     # Note: we should handle calculating the charset
                     msg = MIMEText(fp.read(), _subtype=subtype)
             elif maintype == 'image':
                 with open(path, 'rb') as fp:
                     msg = MIMEImage(fp.read(), _subtype=subtype)
             elif maintype == 'audio':
                 with open(path, 'rb') as fp:
                     msg = MIMEAudio(fp.read(), _subtype=subtype)
             else:
                 with open(path, 'rb') as fp:
                     msg = MIMEBase(maintype, subtype)
                     msg.set_payload(fp.read())
                 # Encode the payload using Base64
                 encoders.encode_base64(msg)
             # Set the filename parameter
             msg.add_header('Content-Disposition', 'attachment', filename=filename)
             outer.attach(msg)
         # Now send or store the message
         composed = outer.as_string()
         if args.output:
             with open(args.output, 'w') as fp:
                 fp.write(composed)
         else:
             with smtplib.SMTP('localhost') as s:
                 s.sendmail(args.sender, args.recipients, composed)


     if __name__ == '__main__':
         main()

Here’s an example of how to unpack a MIME message like the one above,
into a directory of files:

     #!/usr/bin/env python3

     """Unpack a MIME message into a directory of files."""

     import os
     import sys
     import email
     import errno
     import mimetypes

     from argparse import ArgumentParser


     def main():
         parser = ArgumentParser(description="""\
     Unpack a MIME message into a directory of files.
     """)
         parser.add_argument('-d', '--directory', required=True,
                             help="""Unpack the MIME message into the named
                             directory, which will be created if it doesn't already
                             exist.""")
         parser.add_argument('msgfile')
         args = parser.parse_args()

         with open(args.msgfile) as fp:
             msg = email.message_from_file(fp)

         try:
             os.mkdir(args.directory)
         except FileExistsError:
             pass

         counter = 1
         for part in msg.walk():
             # multipart/* are just containers
             if part.get_content_maintype() == 'multipart':
                 continue
             # Applications should really sanitize the given filename so that an
             # email message can't be used to overwrite important files
             filename = part.get_filename()
             if not filename:
                 ext = mimetypes.guess_extension(part.get_content_type())
                 if not ext:
                     # Use a generic bag-of-bits extension
                     ext = '.bin'
                 filename = 'part-%03d%s' % (counter, ext)
             counter += 1
             with open(os.path.join(args.directory, filename), 'wb') as fp:
                 fp.write(part.get_payload(decode=True))


     if __name__ == '__main__':
         main()

Here’s an example of how to create an HTML message with an alternative
plain text version: (2)

     #!/usr/bin/env python3

     import smtplib

     from email.mime.multipart import MIMEMultipart
     from email.mime.text import MIMEText

     # me == my email address
     # you == recipient's email address
     me = "my@email.com"
     you = "your@email.com"

     # Create message container - the correct MIME type is multipart/alternative.
     msg = MIMEMultipart('alternative')
     msg['Subject'] = "Link"
     msg['From'] = me
     msg['To'] = you

     # Create the body of the message (a plain-text and an HTML version).
     text = "Hi!\nHow are you?\nHere is the link you wanted:\nhttps://www.python.org"
     html = """\
     <html>
       <head></head>
       <body>
         <p>Hi!<br>
            How are you?<br>
            Here is the <a href="https://www.python.org">link</a> you wanted.
         </p>
       </body>
     </html>
     """

     # Record the MIME types of both parts - text/plain and text/html.
     part1 = MIMEText(text, 'plain')
     part2 = MIMEText(html, 'html')

     # Attach parts into message container.
     # According to RFC 2046, the last part of a multipart message, in this case
     # the HTML message, is best and preferred.
     msg.attach(part1)
     msg.attach(part2)

     # Send the message via local SMTP server.
     s = smtplib.SMTP('localhost')
     # sendmail function takes 3 arguments: sender's address, recipient's address
     # and message to send - here it is sent as one string.
     s.sendmail(me, you, msg.as_string())
     s.quit()

* Menu:

* Examples using the Provisional API:: 

   ---------- Footnotes ----------

   (1) Thanks to Matthew Dixon Cowles for the original inspiration and
examples.

   (2) Contributed by Martin Matejek.


File: python.info,  Node: Examples using the Provisional API,  Up: email Examples

5.19.1.19 Examples using the Provisional API
............................................

Here is a reworking of the last example using the provisional API. To
make things a bit more interesting, we include a related image in the
html part, and we save a copy of what we are going to send to disk, as
well as sending it.

This example also shows how easy it is to include non-ASCII, and
simplifies the sending of the message using the *note send_message():
310. method of the *note smtplib: eb. module.

     #!/usr/bin/env python3

     import smtplib

     from email.message import EmailMessage
     from email.headerregistry import Address
     from email.utils import make_msgid

     # Create the base text message.
     msg = EmailMessage()
     msg['Subject'] = "Ayons asperges pour le déjeuner"
     msg['From'] = Address("Pepé Le Pew", "pepe@example.com")
     msg['To'] = (Address("Penelope Pussycat", "penelope@example.com"),
                  Address("Fabrette Pussycat", "fabrette@example.com"))
     msg.set_content("""\
     Salut!

     Cela ressemble à un excellent recipie[1] déjeuner.

     [1] http://www.yummly.com/recipe/Roasted-Asparagus-Epicurious-203718

     --Pepé
     """)

     # Add the html version.  This converts the message into a multipart/alternative
     # container, with the original text message as the first part and the new html
     # message as the second part.
     asparagus_cid = make_msgid()
     msg.add_alternative("""\
     <html>
       <head></head>
       <body>
         <p>Salut!<\p>
         <p>Cela ressemble à un excellent
             <a href="http://www.yummly.com/recipe/Roasted-Asparagus-Epicurious-203718>
                 recipie
             </a> déjeuner.
         </p>
         <img src="cid:{asparagus_cid}" \>
       </body>
     </html>
     """.format(asparagus_cid=asparagus_cid[1:-1]), subtype='html')
     # note that we needed to peel the <> off the msgid for use in the html.

     # Now add the related image to the html part.
     with open("roasted-asparagus.jpg", 'rb') as img:
         msg.get_payload()[1].add_related(img.read(), 'image', 'jpeg',
                                          cid=asparagus_cid)

     # Make a local copy of what we are going to send.
     with open('outgoing.msg', 'wb') as f:
         f.write(bytes(msg))

     # Send the message via local SMTP server.
     with smtplib.SMTP('localhost') as s:
         s.send_message(msg)

If we were instead sent the message from the last example, here is one
way we could process it:

     import os
     import sys
     import tempfile
     import mimetypes
     import webbrowser

     # Import the email modules we'll need
     from email import policy
     from email.parser import BytesParser

     # An imaginary module that would make this work and be safe.
     from imaginary import magic_html_parser

     # In a real program you'd get the filename from the arguments.
     with open('outgoing.msg', 'rb') as fp:
         msg = BytesParser(policy=policy.default).parse(fp)

     # Now the header items can be accessed as a dictionary, and any non-ASCII will
     # be converted to unicode:
     print('To:', msg['to'])
     print('From:', msg['from'])
     print('Subject:', msg['subject'])

     # If we want to print a priview of the message content, we can extract whatever
     # the least formatted payload is and print the first three lines.  Of course,
     # if the message has no plain text part printing the first three lines of html
     # is probably useless, but this is just a conceptual example.
     simplest = msg.get_body(preferencelist=('plain', 'html'))
     print()
     print(''.join(simplest.get_content().splitlines(keepends=True)[:3]))

     ans = input("View full message?")
     if ans.lower()[0] == 'n':
         sys.exit()

     # We can extract the richest alternative in order to display it:
     richest = msg.get_body()
     partfiles = {}
     if richest['content-type'].maintype == 'text':
         if richest['content-type'].subtype == 'plain':
             for line in richest.get_content().splitlines():
                 print(line)
             sys.exit()
         elif richest['content-type'].subtype == 'html':
             body = richest
         else:
             print("Don't know how to display {}".format(richest.get_content_type()))
             sys.exit()
     elif richest['content-type'].content_type == 'multipart/related':
         body = richest.get_body(preferencelist=('html'))
         for part in richest.iter_attachments():
             fn = part.get_filename()
             if fn:
                 extension = os.path.splitext(part.get_filename())[1]
             else:
                 extension = mimetypes.guess_extension(part.get_content_type())
             with tempfile.NamedTemporaryFile(suffix=extension, delete=False) as f:
                 f.write(part.get_content())
                 # again strip the <> to go from email form of cid to html form.
                 partfiles[part['content-id'][1:-1]] = f.name
     else:
         print("Don't know how to display {}".format(richest.get_content_type()))
         sys.exit()
     with tempfile.NamedTemporaryFile(mode='w', delete=False) as f:
         # The magic_html_parser has to rewrite the href="cid:...." attributes to
         # point to the filenames in partfiles.  It also has to do a safety-sanitize
         # of the html.  It could be written using html.parser.
         f.write(magic_html_parser(body.get_content(), partfiles))
     webbrowser.open(f.name)
     os.remove(f.name)
     for fn in partfiles.values():
         os.remove(fn)

     # Of course, there are lots of email messages that could break this simple
     # minded program, but it will handle the most common ones.

Up to the prompt, the output from the above is:

     To: Penelope Pussycat <"penelope@example.com">, Fabrette Pussycat <"fabrette@example.com">
     From: Pepé Le Pew <pepe@example.com>
     Subject: Ayons asperges pour le déjeuner

     Salut!

     Cela ressemble à un excellent recipie[1] déjeuner.

See also
........

Module *note smtplib: eb.

     SMTP protocol client

Module *note nntplib: be.

     NNTP protocol client


File: python.info,  Node: Package History,  Next: Differences from mimelib,  Prev: email Examples,  Up: email --- An email and MIME handling package

5.19.1.20 Package History
.........................

This table describes the release history of the email package,
corresponding to the version of Python that the package was released
with.  For purposes of this document, when you see a note about change
or added versions, these refer to the Python version the change was made
in, `not' the email package version.  This table also describes the
Python compatibility of each version of the package.

email version       distributed with                   compatible with
                                                       
-----------------------------------------------------------------------------------
                                                       
‘1.x’               Python 2.2.0 to Python 2.2.1       `no longer supported'
                                                       
                                                       
‘2.5’               Python 2.2.2+ and Python 2.3       Python 2.1 to 2.5
                                                       
                                                       
‘3.0’               Python 2.4 and Python 2.5          Python 2.3 to 2.6
                                                       
                                                       
‘4.0’               Python 2.5 to Python 2.7           Python 2.3 to 2.7
                                                       
                                                       
‘5.0’               Python 3.0 and Python 3.1          Python 3.0 to 3.2
                                                       
                                                       
‘5.1’               Python 3.2                         Python 3.2
                                                       

After Version 5.1 (Python 3.2), the email package no longer has a
version that is separate from the Python version.  (See the *note What’s
New in Python: 143. documents for the respective Python versions for
details on changes.)

Here are the major differences between *note email: 67. version 5.1 and
version 5.0:

   * It is once again possible to parse messages containing non-ASCII
     bytes, and to reproduce such messages if the data containing the
     non-ASCII bytes is not modified.

   * New functions *note message_from_bytes(): 790. and *note
     message_from_binary_file(): 791, and new classes *note
     BytesFeedParser: 792. and *note BytesParser: 793. allow binary
     message data to be parsed into model objects.

   * Given bytes input to the model, *note get_payload(): 794. will by
     default decode a message body that has a
     ‘Content-Transfer-Encoding’ of ‘8bit’ using the charset specified
     in the MIME headers and return the resulting string.

   * Given bytes input to the model, *note Generator: 795. will convert
     message bodies that have a ‘Content-Transfer-Encoding’ of 8bit to
     instead have a 7bit Content-Transfer-Encoding.

   * New class *note BytesGenerator: 796. produces bytes as output,
     preserving any unchanged non-ASCII data that was present in the
     input used to build the model, including message bodies with a
     ‘Content-Transfer-Encoding’ of 8bit.

Here are the major differences between *note email: 67. version 5.0 and
version 4:

   * All operations are on unicode strings.  Text inputs must be
     strings, text outputs are strings.  Outputs are limited to the
     ASCII character set and so can be encoded to ASCII for
     transmission.  Inputs are also limited to ASCII; this is an
     acknowledged limitation of email 5.0 and means it can only be used
     to parse email that is 7bit clean.

Here are the major differences between *note email: 67. version 4 and
version 3:

   * All modules have been renamed according to PEP 8(1) standards.  For
     example, the version 3 module ‘email.Message’ was renamed to *note
     email.message: 70. in version 4.

   * A new subpackage *note email.mime: 71. was added and all the
     version 3 ‘email.MIME*’ modules were renamed and situated into the
     *note email.mime: 71. subpackage.  For example, the version 3
     module ‘email.MIMEText’ was renamed to ‘email.mime.text’.

     `Note that the version 3 names will continue to work until Python
     2.6'.

   * The ‘email.mime.application’ module was added, which contains the
     *note MIMEApplication: 214d. class.

   * Methods that were deprecated in version 3 have been removed.  These
     include ‘Generator.__call__()’, ‘Message.get_type()’,
     ‘Message.get_main_type()’, ‘Message.get_subtype()’.

   * Fixes have been added for RFC 2231(2) support which can change some
     of the return types for *note Message.get_param: 20be. and friends.
     Under some circumstances, values which used to return a 3-tuple now
     return simple strings (specifically, if all extended parameter
     segments were unencoded, there is no language and charset
     designation expected, so the return type is now a simple string).
     Also, %-decoding used to be done for both encoded and unencoded
     segments; this decoding is now done only for encoded segments.

Here are the major differences between *note email: 67. version 3 and
version 2:

   * The *note FeedParser: 20cf. class was introduced, and the *note
     Parser: 75a. class was implemented in terms of the *note
     FeedParser: 20cf.  All parsing therefore is non-strict, and parsing
     will make a best effort never to raise an exception.  Problems
     found while parsing messages are stored in the message’s `defect'
     attribute.

   * All aspects of the API which raised *note DeprecationWarning: 192.s
     in version 2 have been removed.  These include the `_encoder'
     argument to the *note MIMEText: 283. constructor, the
     ‘Message.add_payload()’ method, the ‘Utils.dump_address_pair()’
     function, and the functions ‘Utils.decode()’ and ‘Utils.encode()’.

   * New *note DeprecationWarning: 192.s have been added to:
     ‘Generator.__call__()’, ‘Message.get_type()’,
     ‘Message.get_main_type()’, ‘Message.get_subtype()’, and the
     `strict' argument to the *note Parser: 75a. class.  These are
     expected to be removed in future versions.

   * Support for Pythons earlier than 2.3 has been removed.

Here are the differences between *note email: 67. version 2 and version
1:

   * The ‘email.Header’ and ‘email.Charset’ modules have been added.

   * The pickle format for *note Message: 3d2. instances has changed.
     Since this was never (and still isn’t) formally defined, this isn’t
     considered a backward incompatibility.  However if your application
     pickles and unpickles *note Message: 3d2. instances, be aware that
     in *note email: 67. version 2, *note Message: 3d2. instances now
     have private variables `_charset' and `_default_type'.

   * Several methods in the *note Message: 3d2. class have been
     deprecated, or their signatures changed.  Also, many new methods
     have been added.  See the documentation for the *note Message: 3d2.
     class for details.  The changes should be completely backward
     compatible.

   * The object structure has changed in the face of ‘message/rfc822’
     content types.  In *note email: 67. version 1, such a type would be
     represented by a scalar payload, i.e.  the container message’s
     *note is_multipart(): 20a4. returned false, *note get_payload():
     794. was not a list object, but a single *note Message: 3d2.
     instance.

     This structure was inconsistent with the rest of the package, so
     the object representation for ‘message/rfc822’ content types was
     changed.  In *note email: 67. version 2, the container `does'
     return ‘True’ from *note is_multipart(): 20a4, and *note
     get_payload(): 794. returns a list containing a single *note
     Message: 3d2. item.

     Note that this is one place that backward compatibility could not
     be completely maintained.  However, if you’re already testing the
     return type of *note get_payload(): 794, you should be fine.  You
     just need to make sure your code doesn’t do a *note set_payload():
     20a8. with a *note Message: 3d2. instance on a container with a
     content type of ‘message/rfc822’.

   * The *note Parser: 75a. constructor’s `strict' argument was added,
     and its *note parse(): 20d4. and *note parsestr(): 20d5. methods
     grew a `headersonly' argument.  The `strict' flag was also added to
     functions *note email.message_from_file(): 20d9. and *note
     email.message_from_string(): 20d8.

   * ‘Generator.__call__()’ is deprecated; use *note Generator.flatten:
     20a1. instead.  The *note Generator: 795. class has also grown the
     *note clone(): 20df. method.

   * The *note DecodedGenerator: 20e2. class in the *note
     email.generator: 6c. module was added.

   * The intermediate base classes *note MIMENonMultipart: 214a. and
     *note MIMEMultipart: 214c. have been added, and interposed in the
     class hierarchy for most of the other MIME-related derived classes.

   * The `_encoder' argument to the *note MIMEText: 283. constructor has
     been deprecated.  Encoding now happens implicitly based on the
     `_charset' argument.

   * The following functions in the ‘email.Utils’ module have been
     deprecated: ‘dump_address_pairs()’, ‘decode()’, and ‘encode()’.
     The following functions have been added to the module:
     ‘make_msgid()’, ‘decode_rfc2231()’, ‘encode_rfc2231()’, and
     ‘decode_params()’.

   * The non-public function ‘email.Iterators._structure()’ was added.

   ---------- Footnotes ----------

   (1) https://www.python.org/dev/peps/pep-0008

   (2) https://tools.ietf.org/html/rfc2231.html


File: python.info,  Node: Differences from mimelib,  Prev: Package History,  Up: email --- An email and MIME handling package

5.19.1.21 Differences from ‘mimelib’
....................................

The *note email: 67. package was originally prototyped as a separate
library called mimelib(1).  Changes have been made so that method names
are more consistent, and some methods or modules have either been added
or removed.  The semantics of some of the methods have also changed.
For the most part, any functionality available in ‘mimelib’ is still
available in the *note email: 67. package, albeit often in a different
way.  Backward compatibility between the ‘mimelib’ package and the *note
email: 67. package was not a priority.

Here is a brief description of the differences between the ‘mimelib’ and
the *note email: 67. packages, along with hints on how to port your
applications.

Of course, the most visible difference between the two packages is that
the package name has been changed to *note email: 67.  In addition, the
top-level package has the following differences:

   * ‘messageFromString()’ has been renamed to *note
     message_from_string(): 20d8.

   * ‘messageFromFile()’ has been renamed to *note message_from_file():
     20d9.

The *note Message: 3d2. class has the following differences:

   * The method ‘asString()’ was renamed to *note as_string(): 431.

   * The method ‘ismultipart()’ was renamed to *note is_multipart():
     20a4.

   * The *note get_payload(): 794. method has grown a `decode' optional
     argument.

   * The method ‘getall()’ was renamed to *note get_all(): 20b0.

   * The method ‘addheader()’ was renamed to *note add_header(): 20b6.

   * The method ‘gettype()’ was renamed to ‘get_type()’.

   * The method ‘getmaintype()’ was renamed to ‘get_main_type()’.

   * The method ‘getsubtype()’ was renamed to ‘get_subtype()’.

   * The method ‘getparams()’ was renamed to *note get_params(): 20bd.
     Also, whereas ‘getparams()’ returned a list of strings, *note
     get_params(): 20bd. returns a list of 2-tuples, effectively the
     key/value pairs of the parameters, split on the ‘'='’ sign.

   * The method ‘getparam()’ was renamed to *note get_param(): 20be.

   * The method ‘getcharsets()’ was renamed to *note get_charsets():
     20c8.

   * The method ‘getfilename()’ was renamed to *note get_filename():
     20c2.

   * The method ‘getboundary()’ was renamed to *note get_boundary():
     20c4.

   * The method ‘setboundary()’ was renamed to *note set_boundary():
     20c5.

   * The method ‘getdecodedpayload()’ was removed.  To get similar
     functionality, pass the value 1 to the `decode' flag of the *note
     get_payload(): 794. method.

   * The method ‘getpayloadastext()’ was removed.  Similar functionality
     is supported by the *note DecodedGenerator: 20e2. class in the
     *note email.generator: 6c. module.

   * The method ‘getbodyastext()’ was removed.  You can get similar
     functionality by creating an iterator with *note
     typed_subpart_iterator(): 2186. in the *note email.iterators: 6f.
     module.

The *note Parser: 75a. class has no differences in its public interface.
It does have some additional smarts to recognize
‘message/delivery-status’ type messages, which it represents as a *note
Message: 3d2. instance containing separate *note Message: 3d2. subparts
for each header block in the delivery status notification (2).

The *note Generator: 795. class has no differences in its public
interface.  There is a new class in the *note email.generator: 6c.
module though, called *note DecodedGenerator: 20e2. which provides most
of the functionality previously available in the
‘Message.getpayloadastext()’ method.

The following modules and classes have been changed:

   * The *note MIMEBase: 2149. class constructor arguments `_major' and
     `_minor' have changed to `_maintype' and `_subtype' respectively.

   * The ‘Image’ class/module has been renamed to ‘MIMEImage’.  The
     `_minor' argument has been renamed to `_subtype'.

   * The ‘Text’ class/module has been renamed to ‘MIMEText’.  The
     `_minor' argument has been renamed to `_subtype'.

   * The ‘MessageRFC822’ class/module has been renamed to ‘MIMEMessage’.
     Note that an earlier version of ‘mimelib’ called this class/module
     ‘RFC822’, but that clashed with the Python standard library module
     ‘rfc822’ on some case-insensitive file systems.

     Also, the *note MIMEMessage: 2150. class now represents any kind of
     MIME message with main type ‘message’.  It takes an optional
     argument `_subtype' which is used to set the MIME subtype.
     `_subtype' defaults to ‘rfc822’.

‘mimelib’ provided some utility functions in its ‘address’ and ‘date’
modules.  All of these functions have been moved to the *note
email.utils: 74. module.

The ‘MsgReader’ class/module has been removed.  Its functionality is
most closely supported in the *note body_line_iterator(): 2185. function
in the *note email.iterators: 6f. module.

   ---------- Footnotes ----------

   (1) http://mimelib.sourceforge.net/

   (2) Delivery Status Notifications (DSN) are defined in RFC 1894
(https://tools.ietf.org/html/rfc1894.html).


File: python.info,  Node: json --- JSON encoder and decoder,  Next: mailcap --- Mailcap file handling,  Prev: email --- An email and MIME handling package,  Up: Internet Data Handling

5.19.2 ‘json’ — JSON encoder and decoder
----------------------------------------

JSON (JavaScript Object Notation)(1), specified by RFC 7159(2) (which
obsoletes RFC 4627(3)) and by ECMA-404(4), is a lightweight data
interchange format inspired by JavaScript(5) object literal syntax
(although it is not a strict subset of JavaScript (6) ).

*note json: a2. exposes an API familiar to users of the standard library
*note marshal: af. and *note pickle: c8. modules.

Encoding basic Python object hierarchies:

     >>> import json
     >>> json.dumps(['foo', {'bar': ('baz', None, 1.0, 2)}])
     '["foo", {"bar": ["baz", null, 1.0, 2]}]'
     >>> print(json.dumps("\"foo\bar"))
     "\"foo\bar"
     >>> print(json.dumps('\u1234'))
     "\u1234"
     >>> print(json.dumps('\\'))
     "\\"
     >>> print(json.dumps({"c": 0, "b": 0, "a": 0}, sort_keys=True))
     {"a": 0, "b": 0, "c": 0}
     >>> from io import StringIO
     >>> io = StringIO()
     >>> json.dump(['streaming API'], io)
     >>> io.getvalue()
     '["streaming API"]'

Compact encoding:

     >>> import json
     >>> json.dumps([1,2,3,{'4': 5, '6': 7}], separators=(',', ':'))
     '[1,2,3,{"4":5,"6":7}]'

Pretty printing:

     >>> import json
     >>> print(json.dumps({'4': 5, '6': 7}, sort_keys=True, indent=4))
     {
         "4": 5,
         "6": 7
     }

Decoding JSON:

     >>> import json
     >>> json.loads('["foo", {"bar":["baz", null, 1.0, 2]}]')
     ['foo', {'bar': ['baz', None, 1.0, 2]}]
     >>> json.loads('"\\"foo\\bar"')
     '"foo\x08ar'
     >>> from io import StringIO
     >>> io = StringIO('["streaming API"]')
     >>> json.load(io)
     ['streaming API']

Specializing JSON object decoding:

     >>> import json
     >>> def as_complex(dct):
     ...     if '__complex__' in dct:
     ...         return complex(dct['real'], dct['imag'])
     ...     return dct
     ...
     >>> json.loads('{"__complex__": true, "real": 1, "imag": 2}',
     ...     object_hook=as_complex)
     (1+2j)
     >>> import decimal
     >>> json.loads('1.1', parse_float=decimal.Decimal)
     Decimal('1.1')

Extending *note JSONEncoder: 2191.:

     >>> import json
     >>> class ComplexEncoder(json.JSONEncoder):
     ...     def default(self, obj):
     ...         if isinstance(obj, complex):
     ...             return [obj.real, obj.imag]
     ...         # Let the base class default method raise the TypeError
     ...         return json.JSONEncoder.default(self, obj)
     ...
     >>> json.dumps(2 + 1j, cls=ComplexEncoder)
     '[2.0, 1.0]'
     >>> ComplexEncoder().encode(2 + 1j)
     '[2.0, 1.0]'
     >>> list(ComplexEncoder().iterencode(2 + 1j))
     ['[2.0', ', 1.0', ']']

Using json.tool from the shell to validate and pretty-print:

     $ echo '{"json":"obj"}' | python -m json.tool
     {
         "json": "obj"
     }
     $ echo '{1.2:3.4}' | python -m json.tool
     Expecting property name enclosed in double quotes: line 1 column 2 (char 1)

See *note Command Line Interface: 2192. for detailed documentation.

     Note: JSON is a subset of YAML(7) 1.2.  The JSON produced by this
     module’s default settings (in particular, the default `separators'
     value) is also a subset of YAML 1.0 and 1.1.  This module can thus
     also be used as a YAML serializer.

* Menu:

* Basic Usage:: 
* Encoders and Decoders:: 
* Exceptions: Exceptions<9>. 
* Standard Compliance and Interoperability:: 
* Command Line Interface: Command Line Interface<2>. 

   ---------- Footnotes ----------

   (1) http://json.org

   (2) https://tools.ietf.org/html/rfc7159.html

   (3) https://tools.ietf.org/html/rfc4627.html

   (4) 
http://www.ecma-international.org/publications/standards/Ecma-404.htm

   (5) https://en.wikipedia.org/wiki/JavaScript

   (6) As noted in the errata for RFC 7159
(http://www.rfc-editor.org/errata_search.php?rfc=7159), JSON permits
literal U+2028 (LINE SEPARATOR) and U+2029 (PARAGRAPH SEPARATOR)
characters in strings, whereas JavaScript (as of ECMAScript Edition 5.1)
does not.

   (7) http://yaml.org/


File: python.info,  Node: Basic Usage,  Next: Encoders and Decoders,  Up: json --- JSON encoder and decoder

5.19.2.1 Basic Usage
....................

 -- Function: json.dump (obj, fp, skipkeys=False, ensure_ascii=True,
          check_circular=True, allow_nan=True, cls=None, indent=None,
          separators=None, default=None, sort_keys=False, **kw)

     Serialize `obj' as a JSON formatted stream to `fp' (a
     ‘.write()’-supporting *note file-like object: 160e.) using this
     *note conversion table: 2194.

     If `skipkeys' is ‘True’ (default: ‘False’), then dict keys that are
     not of a basic type (*note str: 25a, *note int: 227, *note float:
     57a, *note bool: a72, ‘None’) will be skipped instead of raising a
     *note TypeError: 562.

     The *note json: a2. module always produces *note str: 25a. objects,
     not *note bytes: 1db. objects.  Therefore, ‘fp.write()’ must
     support *note str: 25a. input.

     If `ensure_ascii' is ‘True’ (the default), the output is guaranteed
     to have all incoming non-ASCII characters escaped.  If
     `ensure_ascii' is ‘False’, these characters will be output as-is.

     If `check_circular' is ‘False’ (default: ‘True’), then the circular
     reference check for container types will be skipped and a circular
     reference will result in an *note OverflowError: 578. (or worse).

     If `allow_nan' is ‘False’ (default: ‘True’), then it will be a
     *note ValueError: 19c. to serialize out of range *note float: 57a.
     values (‘nan’, ‘inf’, ‘-inf’) in strict compliance of the JSON
     specification, instead of using the JavaScript equivalents (‘NaN’,
     ‘Infinity’, ‘-Infinity’).

     If `indent' is a non-negative integer or string, then JSON array
     elements and object members will be pretty-printed with that indent
     level.  An indent level of 0, negative, or ‘""’ will only insert
     newlines.  ‘None’ (the default) selects the most compact
     representation.  Using a positive integer indent indents that many
     spaces per level.  If `indent' is a string (such as ‘"\t"’), that
     string is used to indent each level.

     Changed in version 3.2: Allow strings for `indent' in addition to
     integers.

     If specified, `separators' should be an ‘(item_separator,
     key_separator)’ tuple.  The default is ‘(', ', ': ')’ if `indent'
     is ‘None’ and ‘(',', ': ')’ otherwise.  To get the most compact
     JSON representation, you should specify ‘(',', ':')’ to eliminate
     whitespace.

     Changed in version 3.4: Use ‘(',', ': ')’ as default if `indent' is
     not ‘None’.

     `default(obj)' is a function that should return a serializable
     version of `obj' or raise *note TypeError: 562.  The default simply
     raises *note TypeError: 562.

     If `sort_keys' is ‘True’ (default: ‘False’), then the output of
     dictionaries will be sorted by key.

     To use a custom *note JSONEncoder: 2191. subclass (e.g.  one that
     overrides the ‘default()’ method to serialize additional types),
     specify it with the `cls' kwarg; otherwise *note JSONEncoder: 2191.
     is used.

 -- Function: json.dumps (obj, skipkeys=False, ensure_ascii=True,
          check_circular=True, allow_nan=True, cls=None, indent=None,
          separators=None, default=None, sort_keys=False, **kw)

     Serialize `obj' to a JSON formatted *note str: 25a. using this
     *note conversion table: 2194.  The arguments have the same meaning
     as in *note dump(): 582.

          Note: Unlike *note pickle: c8. and *note marshal: af, JSON is
          not a framed protocol, so trying to serialize multiple objects
          with repeated calls to *note dump(): 582. using the same `fp'
          will result in an invalid JSON file.

          Note: Keys in key/value pairs of JSON are always of the type
          *note str: 25a.  When a dictionary is converted into JSON, all
          the keys of the dictionary are coerced to strings.  As a
          result of this, if a dictionary is converted into JSON and
          then back into a dictionary, the dictionary may not equal the
          original one.  That is, ‘loads(dumps(x)) != x’ if x has
          non-string keys.

 -- Function: json.load (fp, cls=None, object_hook=None,
          parse_float=None, parse_int=None, parse_constant=None,
          object_pairs_hook=None, **kw)

     Deserialize `fp' (a ‘.read()’-supporting *note file-like object:
     160e. containing a JSON document) to a Python object using this
     *note conversion table: 2195.

     `object_hook' is an optional function that will be called with the
     result of any object literal decoded (a *note dict: 3b0.).  The
     return value of `object_hook' will be used instead of the *note
     dict: 3b0.  This feature can be used to implement custom decoders
     (e.g.  JSON-RPC(1) class hinting).

     `object_pairs_hook' is an optional function that will be called
     with the result of any object literal decoded with an ordered list
     of pairs.  The return value of `object_pairs_hook' will be used
     instead of the *note dict: 3b0.  This feature can be used to
     implement custom decoders that rely on the order that the key and
     value pairs are decoded (for example, *note
     collections.OrderedDict(): 1bd. will remember the order of
     insertion).  If `object_hook' is also defined, the
     `object_pairs_hook' takes priority.

     Changed in version 3.1: Added support for `object_pairs_hook'.

     `parse_float', if specified, will be called with the string of
     every JSON float to be decoded.  By default, this is equivalent to
     ‘float(num_str)’.  This can be used to use another datatype or
     parser for JSON floats (e.g.  *note decimal.Decimal: 618.).

     `parse_int', if specified, will be called with the string of every
     JSON int to be decoded.  By default, this is equivalent to
     ‘int(num_str)’.  This can be used to use another datatype or parser
     for JSON integers (e.g.  *note float: 57a.).

     `parse_constant', if specified, will be called with one of the
     following strings: ‘'-Infinity'’, ‘'Infinity'’, ‘'NaN'’.  This can
     be used to raise an exception if invalid JSON numbers are
     encountered.

     Changed in version 3.1: `parse_constant' doesn’t get called on
     ’null’, ’true’, ’false’ anymore.

     To use a custom *note JSONDecoder: 8f3. subclass, specify it with
     the ‘cls’ kwarg; otherwise *note JSONDecoder: 8f3. is used.
     Additional keyword arguments will be passed to the constructor of
     the class.

     If the data being deserialized is not a valid JSON document, a
     *note JSONDecodeError: 2bf. will be raised.

 -- Function: json.loads (s, encoding=None, cls=None, object_hook=None,
          parse_float=None, parse_int=None, parse_constant=None,
          object_pairs_hook=None, **kw)

     Deserialize `s' (a *note str: 25a. instance containing a JSON
     document) to a Python object using this *note conversion table:
     2195.

     The other arguments have the same meaning as in *note load(): 91b,
     except `encoding' which is ignored and deprecated.

     If the data being deserialized is not a valid JSON document, a
     *note JSONDecodeError: 2bf. will be raised.

   ---------- Footnotes ----------

   (1) http://www.jsonrpc.org


File: python.info,  Node: Encoders and Decoders,  Next: Exceptions<9>,  Prev: Basic Usage,  Up: json --- JSON encoder and decoder

5.19.2.2 Encoders and Decoders
..............................

 -- Class: json.JSONDecoder (object_hook=None, parse_float=None,
          parse_int=None, parse_constant=None, strict=True,
          object_pairs_hook=None)

     Simple JSON decoder.

     Performs the following translations in decoding by default:

     JSON                Python
                         
     --------------------------------------------
                         
     object              dict
                         
                         
     array               list
                         
                         
     string              str
                         
                         
     number (int)        int
                         
                         
     number (real)       float
                         
                         
     true                True
                         
                         
     false               False
                         
                         
     null                None
                         

     It also understands ‘NaN’, ‘Infinity’, and ‘-Infinity’ as their
     corresponding ‘float’ values, which is outside the JSON spec.

     `object_hook', if specified, will be called with the result of
     every JSON object decoded and its return value will be used in
     place of the given *note dict: 3b0.  This can be used to provide
     custom deserializations (e.g.  to support JSON-RPC class hinting).

     `object_pairs_hook', if specified will be called with the result of
     every JSON object decoded with an ordered list of pairs.  The
     return value of `object_pairs_hook' will be used instead of the
     *note dict: 3b0.  This feature can be used to implement custom
     decoders that rely on the order that the key and value pairs are
     decoded (for example, *note collections.OrderedDict(): 1bd. will
     remember the order of insertion).  If `object_hook' is also
     defined, the `object_pairs_hook' takes priority.

     Changed in version 3.1: Added support for `object_pairs_hook'.

     `parse_float', if specified, will be called with the string of
     every JSON float to be decoded.  By default, this is equivalent to
     ‘float(num_str)’.  This can be used to use another datatype or
     parser for JSON floats (e.g.  *note decimal.Decimal: 618.).

     `parse_int', if specified, will be called with the string of every
     JSON int to be decoded.  By default, this is equivalent to
     ‘int(num_str)’.  This can be used to use another datatype or parser
     for JSON integers (e.g.  *note float: 57a.).

     `parse_constant', if specified, will be called with one of the
     following strings: ‘'-Infinity'’, ‘'Infinity'’, ‘'NaN'’, ‘'null'’,
     ‘'true'’, ‘'false'’.  This can be used to raise an exception if
     invalid JSON numbers are encountered.

     If `strict' is ‘False’ (‘True’ is the default), then control
     characters will be allowed inside strings.  Control characters in
     this context are those with character codes in the 0-31 range,
     including ‘'\t'’ (tab), ‘'\n'’, ‘'\r'’ and ‘'\0'’.

     If the data being deserialized is not a valid JSON document, a
     *note JSONDecodeError: 2bf. will be raised.

      -- Method: decode (s)

          Return the Python representation of `s' (a *note str: 25a.
          instance containing a JSON document).

          *note JSONDecodeError: 2bf. will be raised if the given JSON
          document is not valid.

      -- Method: raw_decode (s)

          Decode a JSON document from `s' (a *note str: 25a. beginning
          with a JSON document) and return a 2-tuple of the Python
          representation and the index in `s' where the document ended.

          This can be used to decode a JSON document from a string that
          may have extraneous data at the end.

 -- Class: json.JSONEncoder (skipkeys=False, ensure_ascii=True,
          check_circular=True, allow_nan=True, sort_keys=False,
          indent=None, separators=None, default=None)

     Extensible JSON encoder for Python data structures.

     Supports the following objects and types by default:

     Python                                       JSON
                                                  
     -----------------------------------------------------------------
                                                  
     dict                                         object
                                                  
                                                  
     list, tuple                                  array
                                                  
                                                  
     str                                          string
                                                  
                                                  
     int, float, int- & float-derived Enums       number
                                                  
                                                  
     True                                         true
                                                  
                                                  
     False                                        false
                                                  
                                                  
     None                                         null
                                                  

     Changed in version 3.4: Added support for int- and float-derived
     Enum classes.

     To extend this to recognize other objects, subclass and implement a
     *note default(): 219a. method with another method that returns a
     serializable object for ‘o’ if possible, otherwise it should call
     the superclass implementation (to raise *note TypeError: 562.).

     If `skipkeys' is ‘False’ (the default), then it is a *note
     TypeError: 562. to attempt encoding of keys that are not str, int,
     float or None.  If `skipkeys' is ‘True’, such items are simply
     skipped.

     If `ensure_ascii' is ‘True’ (the default), the output is guaranteed
     to have all incoming non-ASCII characters escaped.  If
     `ensure_ascii' is ‘False’, these characters will be output as-is.

     If `check_circular' is ‘True’ (the default), then lists, dicts, and
     custom encoded objects will be checked for circular references
     during encoding to prevent an infinite recursion (which would cause
     an *note OverflowError: 578.).  Otherwise, no such check takes
     place.

     If `allow_nan' is ‘True’ (the default), then ‘NaN’, ‘Infinity’, and
     ‘-Infinity’ will be encoded as such.  This behavior is not JSON
     specification compliant, but is consistent with most JavaScript
     based encoders and decoders.  Otherwise, it will be a *note
     ValueError: 19c. to encode such floats.

     If `sort_keys' is ‘True’ (default ‘False’), then the output of
     dictionaries will be sorted by key; this is useful for regression
     tests to ensure that JSON serializations can be compared on a
     day-to-day basis.

     If `indent' is a non-negative integer or string, then JSON array
     elements and object members will be pretty-printed with that indent
     level.  An indent level of 0, negative, or ‘""’ will only insert
     newlines.  ‘None’ (the default) selects the most compact
     representation.  Using a positive integer indent indents that many
     spaces per level.  If `indent' is a string (such as ‘"\t"’), that
     string is used to indent each level.

     Changed in version 3.2: Allow strings for `indent' in addition to
     integers.

     If specified, `separators' should be an ‘(item_separator,
     key_separator)’ tuple.  The default is ‘(', ', ': ')’ if `indent'
     is ‘None’ and ‘(',', ': ')’ otherwise.  To get the most compact
     JSON representation, you should specify ‘(',', ':')’ to eliminate
     whitespace.

     Changed in version 3.4: Use ‘(',', ': ')’ as default if `indent' is
     not ‘None’.

     If specified, `default' is a function that gets called for objects
     that can’t otherwise be serialized.  It should return a JSON
     encodable version of the object or raise a *note TypeError: 562.

      -- Method: default (o)

          Implement this method in a subclass such that it returns a
          serializable object for `o', or calls the base implementation
          (to raise a *note TypeError: 562.).

          For example, to support arbitrary iterators, you could
          implement default like this:

               def default(self, o):
                  try:
                      iterable = iter(o)
                  except TypeError:
                      pass
                  else:
                      return list(iterable)
                  # Let the base class default method raise the TypeError
                  return json.JSONEncoder.default(self, o)

      -- Method: encode (o)

          Return a JSON string representation of a Python data
          structure, `o'.  For example:

               >>> json.JSONEncoder().encode({"foo": ["bar", "baz"]})
               '{"foo": ["bar", "baz"]}'

      -- Method: iterencode (o)

          Encode the given object, `o', and yield each string
          representation as available.  For example:

               for chunk in json.JSONEncoder().iterencode(bigobject):
                   mysocket.write(chunk)


File: python.info,  Node: Exceptions<9>,  Next: Standard Compliance and Interoperability,  Prev: Encoders and Decoders,  Up: json --- JSON encoder and decoder

5.19.2.3 Exceptions
...................

 -- Exception: json.JSONDecodeError (msg, doc, pos, end=None)

          Subclass of *note ValueError: 19c. with the following
          additional attributes:

           -- Attribute: msg

               The unformatted error message.

           -- Attribute: doc

               The JSON document being parsed.

           -- Attribute: pos

               The start index of `doc' where parsing failed.

           -- Attribute: lineno

               The line corresponding to `pos'.

           -- Attribute: colno

               The column corresponding to `pos'.

     New in version 3.5.


File: python.info,  Node: Standard Compliance and Interoperability,  Next: Command Line Interface<2>,  Prev: Exceptions<9>,  Up: json --- JSON encoder and decoder

5.19.2.4 Standard Compliance and Interoperability
.................................................

The JSON format is specified by RFC 7159(1) and by ECMA-404(2).  This
section details this module’s level of compliance with the RFC. For
simplicity, *note JSONEncoder: 2191. and *note JSONDecoder: 8f3.
subclasses, and parameters other than those explicitly mentioned, are
not considered.

This module does not comply with the RFC in a strict fashion,
implementing some extensions that are valid JavaScript but not valid
JSON. In particular:

   - Infinite and NaN number values are accepted and output;

   - Repeated names within an object are accepted, and only the value of
     the last name-value pair is used.

Since the RFC permits RFC-compliant parsers to accept input texts that
are not RFC-compliant, this module’s deserializer is technically
RFC-compliant under default settings.

* Menu:

* Character Encodings:: 
* Infinite and NaN Number Values:: 
* Repeated Names Within an Object:: 
* Top-level Non-Object, Non-Array Values: Top-level Non-Object Non-Array Values. 
* Implementation Limitations:: 

   ---------- Footnotes ----------

   (1) https://tools.ietf.org/html/rfc7159.html

   (2) 
http://www.ecma-international.org/publications/standards/Ecma-404.htm


File: python.info,  Node: Character Encodings,  Next: Infinite and NaN Number Values,  Up: Standard Compliance and Interoperability

5.19.2.5 Character Encodings
............................

The RFC requires that JSON be represented using either UTF-8, UTF-16, or
UTF-32, with UTF-8 being the recommended default for maximum
interoperability.

As permitted, though not required, by the RFC, this module’s serializer
sets `ensure_ascii=True' by default, thus escaping the output so that
the resulting strings only contain ASCII characters.

Other than the `ensure_ascii' parameter, this module is defined strictly
in terms of conversion between Python objects and *note Unicode strings:
25a, and thus does not otherwise directly address the issue of character
encodings.

The RFC prohibits adding a byte order mark (BOM) to the start of a JSON
text, and this module’s serializer does not add a BOM to its output.
The RFC permits, but does not require, JSON deserializers to ignore an
initial BOM in their input.  This module’s deserializer raises a *note
ValueError: 19c. when an initial BOM is present.

The RFC does not explicitly forbid JSON strings which contain byte
sequences that don’t correspond to valid Unicode characters (e.g.
unpaired UTF-16 surrogates), but it does note that they may cause
interoperability problems.  By default, this module accepts and outputs
(when present in the original *note str: 25a.) code points for such
sequences.


File: python.info,  Node: Infinite and NaN Number Values,  Next: Repeated Names Within an Object,  Prev: Character Encodings,  Up: Standard Compliance and Interoperability

5.19.2.6 Infinite and NaN Number Values
.......................................

The RFC does not permit the representation of infinite or NaN number
values.  Despite that, by default, this module accepts and outputs
‘Infinity’, ‘-Infinity’, and ‘NaN’ as if they were valid JSON number
literal values:

     >>> # Neither of these calls raises an exception, but the results are not valid JSON
     >>> json.dumps(float('-inf'))
     '-Infinity'
     >>> json.dumps(float('nan'))
     'NaN'
     >>> # Same when deserializing
     >>> json.loads('-Infinity')
     -inf
     >>> json.loads('NaN')
     nan

In the serializer, the `allow_nan' parameter can be used to alter this
behavior.  In the deserializer, the `parse_constant' parameter can be
used to alter this behavior.


File: python.info,  Node: Repeated Names Within an Object,  Next: Top-level Non-Object Non-Array Values,  Prev: Infinite and NaN Number Values,  Up: Standard Compliance and Interoperability

5.19.2.7 Repeated Names Within an Object
........................................

The RFC specifies that the names within a JSON object should be unique,
but does not mandate how repeated names in JSON objects should be
handled.  By default, this module does not raise an exception; instead,
it ignores all but the last name-value pair for a given name:

     >>> weird_json = '{"x": 1, "x": 2, "x": 3}'
     >>> json.loads(weird_json)
     {'x': 3}

The `object_pairs_hook' parameter can be used to alter this behavior.


File: python.info,  Node: Top-level Non-Object Non-Array Values,  Next: Implementation Limitations,  Prev: Repeated Names Within an Object,  Up: Standard Compliance and Interoperability

5.19.2.8 Top-level Non-Object, Non-Array Values
...............................................

The old version of JSON specified by the obsolete RFC 4627(1) required
that the top-level value of a JSON text must be either a JSON object or
array (Python *note dict: 3b0. or *note list: 25d.), and could not be a
JSON null, boolean, number, or string value.  RFC 7159(2) removed that
restriction, and this module does not and has never implemented that
restriction in either its serializer or its deserializer.

Regardless, for maximum interoperability, you may wish to voluntarily
adhere to the restriction yourself.

   ---------- Footnotes ----------

   (1) https://tools.ietf.org/html/rfc4627.html

   (2) https://tools.ietf.org/html/rfc7159.html


File: python.info,  Node: Implementation Limitations,  Prev: Top-level Non-Object Non-Array Values,  Up: Standard Compliance and Interoperability

5.19.2.9 Implementation Limitations
...................................

Some JSON deserializer implementations may set limits on:

   * the size of accepted JSON texts

   * the maximum level of nesting of JSON objects and arrays

   * the range and precision of JSON numbers

   * the content and maximum length of JSON strings

This module does not impose any such limits beyond those of the relevant
Python datatypes themselves or the Python interpreter itself.

When serializing to JSON, beware any such limitations in applications
that may consume your JSON. In particular, it is common for JSON numbers
to be deserialized into IEEE 754 double precision numbers and thus
subject to that representation’s range and precision limitations.  This
is especially relevant when serializing Python *note int: 227. values of
extremely large magnitude, or when serializing instances of "exotic"
numerical types such as *note decimal.Decimal: 618.


File: python.info,  Node: Command Line Interface<2>,  Prev: Standard Compliance and Interoperability,  Up: json --- JSON encoder and decoder

5.19.2.10 Command Line Interface
................................

The *note json.tool: a3. module provides a simple command line interface
to validate and pretty-print JSON objects.

If the optional ‘infile’ and ‘outfile’ arguments are not specified,
*note sys.stdin: 1b9. and *note sys.stdout: 1ba. will be used
respectively:

     $ echo '{"json": "obj"}' | python -m json.tool
     {
         "json": "obj"
     }
     $ echo '{1.2:3.4}' | python -m json.tool
     Expecting property name enclosed in double quotes: line 1 column 2 (char 1)

Changed in version 3.5: The output is now in the same order as the
input.  Use the *note –sort-keys: 21aa. option to sort the output of
dictionaries alphabetically by key.

* Menu:

* Command line options: Command line options<2>. 


File: python.info,  Node: Command line options<2>,  Up: Command Line Interface<2>

5.19.2.11 Command line options
..............................

 -- Program Option: infile

     The JSON file to be validated or pretty-printed:

          $ python -m json.tool mp_films.json
          [
              {
                  "title": "And Now for Something Completely Different",
                  "year": 1971
              },
              {
                  "title": "Monty Python and the Holy Grail",
                  "year": 1975
              }
          ]

     If `infile' is not specified, read from *note sys.stdin: 1b9.

 -- Program Option: outfile

     Write the output of the `infile' to the given `outfile'.
     Otherwise, write it to *note sys.stdout: 1ba.

 -- Program Option: --sort-keys

     Sort the output of dictionaries alphabetically by key.

     New in version 3.5.

 -- Program Option: -h, --help

     Show the help message.


File: python.info,  Node: mailcap --- Mailcap file handling,  Next: mailbox --- Manipulate mailboxes in various formats,  Prev: json --- JSON encoder and decoder,  Up: Internet Data Handling

5.19.3 ‘mailcap’ — Mailcap file handling
----------------------------------------

`Source code:' Lib/mailcap.py(1)

__________________________________________________________________

Mailcap files are used to configure how MIME-aware applications such as
mail readers and Web browsers react to files with different MIME types.
(The name "mailcap" is derived from the phrase "mail capability".)  For
example, a mailcap file might contain a line like ‘video/mpeg; xmpeg
%s’.  Then, if the user encounters an email message or Web document with
the MIME type ‘video/mpeg’, ‘%s’ will be replaced by a filename (usually
one belonging to a temporary file) and the ‘xmpeg’ program can be
automatically started to view the file.

The mailcap format is documented in RFC 1524(2), "A User Agent
Configuration Mechanism For Multimedia Mail Format Information," but is
not an Internet standard.  However, mailcap files are supported on most
Unix systems.

 -- Function: mailcap.findmatch (caps, MIMEtype, key='view',
          filename='/dev/null', plist=[])

     Return a 2-tuple; the first element is a string containing the
     command line to be executed (which can be passed to *note
     os.system(): a3d.), and the second element is the mailcap entry for
     a given MIME type.  If no matching MIME type can be found, ‘(None,
     None)’ is returned.

     `key' is the name of the field desired, which represents the type
     of activity to be performed; the default value is ’view’, since in
     the most common case you simply want to view the body of the
     MIME-typed data.  Other possible values might be ’compose’ and
     ’edit’, if you wanted to create a new body of the given MIME type
     or alter the existing body data.  See RFC 1524(3) for a complete
     list of these fields.

     `filename' is the filename to be substituted for ‘%s’ in the
     command line; the default value is ‘'/dev/null'’ which is almost
     certainly not what you want, so usually you’ll override it by
     specifying a filename.

     `plist' can be a list containing named parameters; the default
     value is simply an empty list.  Each entry in the list must be a
     string containing the parameter name, an equals sign (‘'='’), and
     the parameter’s value.  Mailcap entries can contain named
     parameters like ‘%{foo}’, which will be replaced by the value of
     the parameter named ’foo’.  For example, if the command line
     ‘showpartial %{id} %{number} %{total}’ was in a mailcap file, and
     `plist' was set to ‘['id=1', 'number=2', 'total=3']’, the resulting
     command line would be ‘'showpartial 1 2 3'’.

     In a mailcap file, the "test" field can optionally be specified to
     test some external condition (such as the machine architecture, or
     the window system in use) to determine whether or not the mailcap
     line applies.  *note findmatch(): 21b2. will automatically check
     such conditions and skip the entry if the check fails.

 -- Function: mailcap.getcaps ()

     Returns a dictionary mapping MIME types to a list of mailcap file
     entries.  This dictionary must be passed to the *note findmatch():
     21b2. function.  An entry is stored as a list of dictionaries, but
     it shouldn’t be necessary to know the details of this
     representation.

     The information is derived from all of the mailcap files found on
     the system.  Settings in the user’s mailcap file ‘$HOME/.mailcap’
     will override settings in the system mailcap files ‘/etc/mailcap’,
     ‘/usr/etc/mailcap’, and ‘/usr/local/etc/mailcap’.

An example usage:

     >>> import mailcap
     >>> d=mailcap.getcaps()
     >>> mailcap.findmatch(d, 'video/mpeg', filename='tmp1223')
     ('xmpeg tmp1223', {'view': 'xmpeg %s'})

   ---------- Footnotes ----------

   (1) https://hg.python.org/cpython/file/default/Lib/mailcap.py

   (2) https://tools.ietf.org/html/rfc1524.html

   (3) https://tools.ietf.org/html/rfc1524.html


File: python.info,  Node: mailbox --- Manipulate mailboxes in various formats,  Next: mimetypes --- Map filenames to MIME types,  Prev: mailcap --- Mailcap file handling,  Up: Internet Data Handling

5.19.4 ‘mailbox’ — Manipulate mailboxes in various formats
----------------------------------------------------------

This module defines two classes, *note Mailbox: 841. and *note Message:
845, for accessing and manipulating on-disk mailboxes and the messages
they contain.  *note Mailbox: 841. offers a dictionary-like mapping from
keys to messages.  *note Message: 845. extends the *note email.message:
70. module’s *note Message: 3d2. class with format-specific state and
behavior.  Supported mailbox formats are Maildir, mbox, MH, Babyl, and
MMDF.

See also
........

Module *note email: 67.

     Represent and manipulate messages.

* Menu:

* Mailbox objects:: 
* Message objects:: 
* Exceptions: Exceptions<10>. 
* Examples: Examples<12>. 


File: python.info,  Node: Mailbox objects,  Next: Message objects,  Up: mailbox --- Manipulate mailboxes in various formats

5.19.4.1 ‘Mailbox’ objects
..........................

 -- Class: mailbox.Mailbox

     A mailbox, which may be inspected and modified.

     The *note Mailbox: 841. class defines an interface and is not
     intended to be instantiated.  Instead, format-specific subclasses
     should inherit from *note Mailbox: 841. and your code should
     instantiate a particular subclass.

     The *note Mailbox: 841. interface is dictionary-like, with small
     keys corresponding to messages.  Keys are issued by the *note
     Mailbox: 841. instance with which they will be used and are only
     meaningful to that *note Mailbox: 841. instance.  A key continues
     to identify a message even if the corresponding message is
     modified, such as by replacing it with another message.

     Messages may be added to a *note Mailbox: 841. instance using the
     set-like method *note add(): 840. and removed using a ‘del’
     statement or the set-like methods *note remove(): 21b8. and *note
     discard(): 21b9.

     *note Mailbox: 841. interface semantics differ from dictionary
     semantics in some noteworthy ways.  Each time a message is
     requested, a new representation (typically a *note Message: 845.
     instance) is generated based upon the current state of the mailbox.
     Similarly, when a message is added to a *note Mailbox: 841.
     instance, the provided message representation’s contents are
     copied.  In neither case is a reference to the message
     representation kept by the *note Mailbox: 841. instance.

     The default *note Mailbox: 841. iterator iterates over message
     representations, not keys as the default dictionary iterator does.
     Moreover, modification of a mailbox during iteration is safe and
     well-defined.  Messages added to the mailbox after an iterator is
     created will not be seen by the iterator.  Messages removed from
     the mailbox before the iterator yields them will be silently
     skipped, though using a key from an iterator may result in a *note
     KeyError: 1a7. exception if the corresponding message is
     subsequently removed.

          Warning: Be very cautious when modifying mailboxes that might
          be simultaneously changed by some other process.  The safest
          mailbox format to use for such tasks is Maildir; try to avoid
          using single-file formats such as mbox for concurrent writing.
          If you’re modifying a mailbox, you `must' lock it by calling
          the *note lock(): 21ba. and *note unlock(): 21bb. methods
          `before' reading any messages in the file or making any
          changes by adding or deleting a message.  Failing to lock the
          mailbox runs the risk of losing messages or corrupting the
          entire mailbox.

     *note Mailbox: 841. instances have the following methods:

      -- Method: add (message)

          Add `message' to the mailbox and return the key that has been
          assigned to it.

          Parameter `message' may be a *note Message: 845. instance, an
          *note email.message.Message: 3d2. instance, a string, a byte
          string, or a file-like object (which should be open in binary
          mode).  If `message' is an instance of the appropriate
          format-specific *note Message: 845. subclass (e.g., if it’s an
          *note mboxMessage: 21bc. instance and this is an *note mbox:
          21bd. instance), its format-specific information is used.
          Otherwise, reasonable defaults for format-specific information
          are used.

          Changed in version 3.2: Support for binary input was added.

      -- Method: remove (key)
      -- Method: __delitem__ (key)
      -- Method: discard (key)

          Delete the message corresponding to `key' from the mailbox.

          If no such message exists, a *note KeyError: 1a7. exception is
          raised if the method was called as *note remove(): 21b8. or
          *note __delitem__(): 21be. but no exception is raised if the
          method was called as *note discard(): 21b9.  The behavior of
          *note discard(): 21b9. may be preferred if the underlying
          mailbox format supports concurrent modification by other
          processes.

      -- Method: __setitem__ (key, message)

          Replace the message corresponding to `key' with `message'.
          Raise a *note KeyError: 1a7. exception if no message already
          corresponds to `key'.

          As with *note add(): 840, parameter `message' may be a *note
          Message: 845. instance, an *note email.message.Message: 3d2.
          instance, a string, a byte string, or a file-like object
          (which should be open in binary mode).  If `message' is an
          instance of the appropriate format-specific *note Message:
          845. subclass (e.g., if it’s an *note mboxMessage: 21bc.
          instance and this is an *note mbox: 21bd. instance), its
          format-specific information is used.  Otherwise, the
          format-specific information of the message that currently
          corresponds to `key' is left unchanged.

      -- Method: iterkeys ()
      -- Method: keys ()

          Return an iterator over all keys if called as *note
          iterkeys(): 21c0. or return a list of keys if called as *note
          keys(): 21c1.

      -- Method: itervalues ()
      -- Method: __iter__ ()
      -- Method: values ()

          Return an iterator over representations of all messages if
          called as *note itervalues(): 21c2. or *note __iter__(): 21c3.
          or return a list of such representations if called as *note
          values(): 21c4.  The messages are represented as instances of
          the appropriate format-specific *note Message: 845. subclass
          unless a custom message factory was specified when the *note
          Mailbox: 841. instance was initialized.

               Note: The behavior of *note __iter__(): 21c3. is unlike
               that of dictionaries, which iterate over keys.

      -- Method: iteritems ()
      -- Method: items ()

          Return an iterator over (`key', `message') pairs, where `key'
          is a key and `message' is a message representation, if called
          as *note iteritems(): 21c5. or return a list of such pairs if
          called as *note items(): 21c6.  The messages are represented
          as instances of the appropriate format-specific *note Message:
          845. subclass unless a custom message factory was specified
          when the *note Mailbox: 841. instance was initialized.

      -- Method: get (key, default=None)
      -- Method: __getitem__ (key)

          Return a representation of the message corresponding to `key'.
          If no such message exists, `default' is returned if the method
          was called as *note get(): 21c7. and a *note KeyError: 1a7.
          exception is raised if the method was called as *note
          __getitem__(): 21c8.  The message is represented as an
          instance of the appropriate format-specific *note Message:
          845. subclass unless a custom message factory was specified
          when the *note Mailbox: 841. instance was initialized.

      -- Method: get_message (key)

          Return a representation of the message corresponding to `key'
          as an instance of the appropriate format-specific *note
          Message: 845. subclass, or raise a *note KeyError: 1a7.
          exception if no such message exists.

      -- Method: get_bytes (key)

          Return a byte representation of the message corresponding to
          `key', or raise a *note KeyError: 1a7. exception if no such
          message exists.

          New in version 3.2.

      -- Method: get_string (key)

          Return a string representation of the message corresponding to
          `key', or raise a *note KeyError: 1a7. exception if no such
          message exists.  The message is processed through *note
          email.message.Message: 3d2. to convert it to a 7bit clean
          representation.

      -- Method: get_file (key)

          Return a file-like representation of the message corresponding
          to `key', or raise a *note KeyError: 1a7. exception if no such
          message exists.  The file-like object behaves as if open in
          binary mode.  This file should be closed once it is no longer
          needed.

          Changed in version 3.2: The file object really is a binary
          file; previously it was incorrectly returned in text mode.
          Also, the file-like object now supports the context management
          protocol: you can use a *note with: 29d. statement to
          automatically close it.

               Note: Unlike other representations of messages, file-like
               representations are not necessarily independent of the
               *note Mailbox: 841. instance that created them or of the
               underlying mailbox.  More specific documentation is
               provided by each subclass.

      -- Method: __contains__ (key)

          Return ‘True’ if `key' corresponds to a message, ‘False’
          otherwise.

      -- Method: __len__ ()

          Return a count of messages in the mailbox.

      -- Method: clear ()

          Delete all messages from the mailbox.

      -- Method: pop (key, default=None)

          Return a representation of the message corresponding to `key'
          and delete the message.  If no such message exists, return
          `default'.  The message is represented as an instance of the
          appropriate format-specific *note Message: 845. subclass
          unless a custom message factory was specified when the *note
          Mailbox: 841. instance was initialized.

      -- Method: popitem ()

          Return an arbitrary (`key', `message') pair, where `key' is a
          key and `message' is a message representation, and delete the
          corresponding message.  If the mailbox is empty, raise a *note
          KeyError: 1a7. exception.  The message is represented as an
          instance of the appropriate format-specific *note Message:
          845. subclass unless a custom message factory was specified
          when the *note Mailbox: 841. instance was initialized.

      -- Method: update (arg)

          Parameter `arg' should be a `key'-to-`message' mapping or an
          iterable of (`key', `message') pairs.  Updates the mailbox so
          that, for each given `key' and `message', the message
          corresponding to `key' is set to `message' as if by using
          *note __setitem__(): 21bf.  As with *note __setitem__(): 21bf,
          each `key' must already correspond to a message in the mailbox
          or else a *note KeyError: 1a7. exception will be raised, so in
          general it is incorrect for `arg' to be a *note Mailbox: 841.
          instance.

               Note: Unlike with dictionaries, keyword arguments are not
               supported.

      -- Method: flush ()

          Write any pending changes to the filesystem.  For some *note
          Mailbox: 841. subclasses, changes are always written
          immediately and *note flush(): 21d0. does nothing, but you
          should still make a habit of calling this method.

      -- Method: lock ()

          Acquire an exclusive advisory lock on the mailbox so that
          other processes know not to modify it.  An *note
          ExternalClashError: 21d1. is raised if the lock is not
          available.  The particular locking mechanisms used depend upon
          the mailbox format.  You should `always' lock the mailbox
          before making any modifications to its contents.

      -- Method: unlock ()

          Release the lock on the mailbox, if any.

      -- Method: close ()

          Flush the mailbox, unlock it if necessary, and close any open
          files.  For some *note Mailbox: 841. subclasses, this method
          does nothing.

* Menu:

* Maildir:: 
* mbox:: 
* MH:: 
* Babyl:: 
* MMDF:: 


File: python.info,  Node: Maildir,  Next: mbox,  Up: Mailbox objects

5.19.4.2 ‘Maildir’
..................

 -- Class: mailbox.Maildir (dirname, factory=None, create=True)

     A subclass of *note Mailbox: 841. for mailboxes in Maildir format.
     Parameter `factory' is a callable object that accepts a file-like
     message representation (which behaves as if opened in binary mode)
     and returns a custom representation.  If `factory' is ‘None’, *note
     MaildirMessage: 21d5. is used as the default message
     representation.  If `create' is ‘True’, the mailbox is created if
     it does not exist.

     It is for historical reasons that `dirname' is named as such rather
     than `path'.

     Maildir is a directory-based mailbox format invented for the qmail
     mail transfer agent and now widely supported by other programs.
     Messages in a Maildir mailbox are stored in separate files within a
     common directory structure.  This design allows Maildir mailboxes
     to be accessed and modified by multiple unrelated programs without
     data corruption, so file locking is unnecessary.

     Maildir mailboxes contain three subdirectories, namely: ‘tmp’,
     ‘new’, and ‘cur’.  Messages are created momentarily in the ‘tmp’
     subdirectory and then moved to the ‘new’ subdirectory to finalize
     delivery.  A mail user agent may subsequently move the message to
     the ‘cur’ subdirectory and store information about the state of the
     message in a special "info" section appended to its file name.

     Folders of the style introduced by the Courier mail transfer agent
     are also supported.  Any subdirectory of the main mailbox is
     considered a folder if ‘'.'’ is the first character in its name.
     Folder names are represented by *note Maildir: 91c. without the
     leading ‘'.'’.  Each folder is itself a Maildir mailbox but should
     not contain other folders.  Instead, a logical nesting is indicated
     using ‘'.'’ to delimit levels, e.g., "Archived.2005.07".

          Note: The Maildir specification requires the use of a colon
          (‘':'’) in certain message file names.  However, some
          operating systems do not permit this character in file names,
          If you wish to use a Maildir-like format on such an operating
          system, you should specify another character to use instead.
          The exclamation point (‘'!'’) is a popular choice.  For
          example:

               import mailbox
               mailbox.Maildir.colon = '!'

          The ‘colon’ attribute may also be set on a per-instance basis.

     *note Maildir: 91c. instances have all of the methods of *note
     Mailbox: 841. in addition to the following:

      -- Method: list_folders ()

          Return a list of the names of all folders.

      -- Method: get_folder (folder)

          Return a *note Maildir: 91c. instance representing the folder
          whose name is `folder'.  A *note NoSuchMailboxError: 21d8.
          exception is raised if the folder does not exist.

      -- Method: add_folder (folder)

          Create a folder whose name is `folder' and return a *note
          Maildir: 91c. instance representing it.

      -- Method: remove_folder (folder)

          Delete the folder whose name is `folder'.  If the folder
          contains any messages, a *note NotEmptyError: 21db. exception
          will be raised and the folder will not be deleted.

      -- Method: clean ()

          Delete temporary files from the mailbox that have not been
          accessed in the last 36 hours.  The Maildir specification says
          that mail-reading programs should do this occasionally.

     Some *note Mailbox: 841. methods implemented by *note Maildir: 91c.
     deserve special remarks:

      -- Method: add (message)
      -- Method: __setitem__ (key, message)
      -- Method: update (arg)

               Warning: These methods generate unique file names based
               upon the current process ID. When using multiple threads,
               undetected name clashes may occur and cause corruption of
               the mailbox unless threads are coordinated to avoid using
               these methods to manipulate the same mailbox
               simultaneously.

      -- Method: flush ()

          All changes to Maildir mailboxes are immediately applied, so
          this method does nothing.

      -- Method: lock ()
      -- Method: unlock ()

          Maildir mailboxes do not support (or require) locking, so
          these methods do nothing.

      -- Method: close ()

          *note Maildir: 91c. instances do not keep any open files and
          the underlying mailboxes do not support locking, so this
          method does nothing.

      -- Method: get_file (key)

          Depending upon the host platform, it may not be possible to
          modify or remove the underlying message while the returned
          file remains open.

See also
........

maildir man page from qmail(1)

     The original specification of the format.

Using maildir format(2)

     Notes on Maildir by its inventor.  Includes an updated
     name-creation scheme and details on "info" semantics.

maildir man page from Courier(3)

     Another specification of the format.  Describes a common extension
     for supporting folders.

   ---------- Footnotes ----------

   (1) http://www.qmail.org/man/man5/maildir.html

   (2) http://cr.yp.to/proto/maildir.html

   (3) http://www.courier-mta.org/maildir.html


File: python.info,  Node: mbox,  Next: MH,  Prev: Maildir,  Up: Mailbox objects

5.19.4.3 ‘mbox’
...............

 -- Class: mailbox.mbox (path, factory=None, create=True)

     A subclass of *note Mailbox: 841. for mailboxes in mbox format.
     Parameter `factory' is a callable object that accepts a file-like
     message representation (which behaves as if opened in binary mode)
     and returns a custom representation.  If `factory' is ‘None’, *note
     mboxMessage: 21bc. is used as the default message representation.
     If `create' is ‘True’, the mailbox is created if it does not exist.

     The mbox format is the classic format for storing mail on Unix
     systems.  All messages in an mbox mailbox are stored in a single
     file with the beginning of each message indicated by a line whose
     first five characters are "From ".

     Several variations of the mbox format exist to address perceived
     shortcomings in the original.  In the interest of compatibility,
     *note mbox: 21bd. implements the original format, which is
     sometimes referred to as `mboxo'.  This means that the
     ‘Content-Length’ header, if present, is ignored and that any
     occurrences of "From " at the beginning of a line in a message body
     are transformed to ">From " when storing the message, although
     occurrences of ">From " are not transformed to "From " when reading
     the message.

     Some *note Mailbox: 841. methods implemented by *note mbox: 21bd.
     deserve special remarks:

      -- Method: get_file (key)

          Using the file after calling ‘flush()’ or ‘close()’ on the
          *note mbox: 21bd. instance may yield unpredictable results or
          raise an exception.

      -- Method: lock ()
      -- Method: unlock ()

          Three locking mechanisms are used—dot locking and, if
          available, the ‘flock()’ and ‘lockf()’ system calls.

See also
........

mbox man page from qmail(1)

     A specification of the format and its variations.

mbox man page from tin(2)

     Another specification of the format, with details on locking.

Configuring Netscape Mail on Unix: Why The Content-Length Format is Bad(3)

     An argument for using the original mbox format rather than a
     variation.

"mbox" is a family of several mutually incompatible mailbox formats(4)

     A history of mbox variations.

   ---------- Footnotes ----------

   (1) http://www.qmail.org/man/man5/mbox.html

   (2) http://www.tin.org/bin/man.cgi?section=5&topic=mbox

   (3) https://www.jwz.org/doc/content-length.html

   (4) 
http://homepage.ntlworld.com/jonathan.deboynepollard/FGA/mail-mbox-formats.html


File: python.info,  Node: MH,  Next: Babyl,  Prev: mbox,  Up: Mailbox objects

5.19.4.4 ‘MH’
.............

 -- Class: mailbox.MH (path, factory=None, create=True)

     A subclass of *note Mailbox: 841. for mailboxes in MH format.
     Parameter `factory' is a callable object that accepts a file-like
     message representation (which behaves as if opened in binary mode)
     and returns a custom representation.  If `factory' is ‘None’, *note
     MHMessage: 21ed. is used as the default message representation.  If
     `create' is ‘True’, the mailbox is created if it does not exist.

     MH is a directory-based mailbox format invented for the MH Message
     Handling System, a mail user agent.  Each message in an MH mailbox
     resides in its own file.  An MH mailbox may contain other MH
     mailboxes (called `folders') in addition to messages.  Folders may
     be nested indefinitely.  MH mailboxes also support `sequences',
     which are named lists used to logically group messages without
     moving them to sub-folders.  Sequences are defined in a file called
     ‘.mh_sequences’ in each folder.

     The *note MH: 21ec. class manipulates MH mailboxes, but it does not
     attempt to emulate all of ‘mh’’s behaviors.  In particular, it does
     not modify and is not affected by the ‘context’ or ‘.mh_profile’
     files that are used by ‘mh’ to store its state and configuration.

     *note MH: 21ec. instances have all of the methods of *note Mailbox:
     841. in addition to the following:

      -- Method: list_folders ()

          Return a list of the names of all folders.

      -- Method: get_folder (folder)

          Return an *note MH: 21ec. instance representing the folder
          whose name is `folder'.  A *note NoSuchMailboxError: 21d8.
          exception is raised if the folder does not exist.

      -- Method: add_folder (folder)

          Create a folder whose name is `folder' and return an *note MH:
          21ec. instance representing it.

      -- Method: remove_folder (folder)

          Delete the folder whose name is `folder'.  If the folder
          contains any messages, a *note NotEmptyError: 21db. exception
          will be raised and the folder will not be deleted.

      -- Method: get_sequences ()

          Return a dictionary of sequence names mapped to key lists.  If
          there are no sequences, the empty dictionary is returned.

      -- Method: set_sequences (sequences)

          Re-define the sequences that exist in the mailbox based upon
          `sequences', a dictionary of names mapped to key lists, like
          returned by *note get_sequences(): 21f2.

      -- Method: pack ()

          Rename messages in the mailbox as necessary to eliminate gaps
          in numbering.  Entries in the sequences list are updated
          correspondingly.

               Note: Already-issued keys are invalidated by this
               operation and should not be subsequently used.

     Some *note Mailbox: 841. methods implemented by *note MH: 21ec.
     deserve special remarks:

      -- Method: remove (key)
      -- Method: __delitem__ (key)
      -- Method: discard (key)

          These methods immediately delete the message.  The MH
          convention of marking a message for deletion by prepending a
          comma to its name is not used.

      -- Method: lock ()
      -- Method: unlock ()

          Three locking mechanisms are used—dot locking and, if
          available, the ‘flock()’ and ‘lockf()’ system calls.  For MH
          mailboxes, locking the mailbox means locking the
          ‘.mh_sequences’ file and, only for the duration of any
          operations that affect them, locking individual message files.

      -- Method: get_file (key)

          Depending upon the host platform, it may not be possible to
          remove the underlying message while the returned file remains
          open.

      -- Method: flush ()

          All changes to MH mailboxes are immediately applied, so this
          method does nothing.

      -- Method: close ()

          *note MH: 21ec. instances do not keep any open files, so this
          method is equivalent to *note unlock(): 21f9.

See also
........

nmh - Message Handling System(1)

     Home page of ‘nmh’, an updated version of the original ‘mh’.

MH & nmh: Email for Users & Programmers(2)

     A GPL-licensed book on ‘mh’ and ‘nmh’, with some information on the
     mailbox format.

   ---------- Footnotes ----------

   (1) http://www.nongnu.org/nmh/

   (2) http://rand-mh.sourceforge.net/book/


File: python.info,  Node: Babyl,  Next: MMDF,  Prev: MH,  Up: Mailbox objects

5.19.4.5 ‘Babyl’
................

 -- Class: mailbox.Babyl (path, factory=None, create=True)

     A subclass of *note Mailbox: 841. for mailboxes in Babyl format.
     Parameter `factory' is a callable object that accepts a file-like
     message representation (which behaves as if opened in binary mode)
     and returns a custom representation.  If `factory' is ‘None’, *note
     BabylMessage: 2200. is used as the default message representation.
     If `create' is ‘True’, the mailbox is created if it does not exist.

     Babyl is a single-file mailbox format used by the Rmail mail user
     agent included with Emacs.  The beginning of a message is indicated
     by a line containing the two characters Control-Underscore
     (‘'\037'’) and Control-L (‘'\014'’).  The end of a message is
     indicated by the start of the next message or, in the case of the
     last message, a line containing a Control-Underscore (‘'\037'’)
     character.

     Messages in a Babyl mailbox have two sets of headers, original
     headers and so-called visible headers.  Visible headers are
     typically a subset of the original headers that have been
     reformatted or abridged to be more attractive.  Each message in a
     Babyl mailbox also has an accompanying list of `labels', or short
     strings that record extra information about the message, and a list
     of all user-defined labels found in the mailbox is kept in the
     Babyl options section.

     *note Babyl: 21ff. instances have all of the methods of *note
     Mailbox: 841. in addition to the following:

      -- Method: get_labels ()

          Return a list of the names of all user-defined labels used in
          the mailbox.

               Note: The actual messages are inspected to determine
               which labels exist in the mailbox rather than consulting
               the list of labels in the Babyl options section, but the
               Babyl section is updated whenever the mailbox is
               modified.

     Some *note Mailbox: 841. methods implemented by *note Babyl: 21ff.
     deserve special remarks:

      -- Method: get_file (key)

          In Babyl mailboxes, the headers of a message are not stored
          contiguously with the body of the message.  To generate a
          file-like representation, the headers and body are copied
          together into an *note io.BytesIO: 371. instance, which has an
          API identical to that of a file.  As a result, the file-like
          object is truly independent of the underlying mailbox but does
          not save memory compared to a string representation.

      -- Method: lock ()
      -- Method: unlock ()

          Three locking mechanisms are used—dot locking and, if
          available, the ‘flock()’ and ‘lockf()’ system calls.

See also
........

Format of Version 5 Babyl Files(1)

     A specification of the Babyl format.

Reading Mail with Rmail(2)

     The Rmail manual, with some information on Babyl semantics.

   ---------- Footnotes ----------

   (1) http://quimby.gnus.org/notes/BABYL

   (2) 
http://www.gnu.org/software/emacs/manual/html_node/emacs/Rmail.html


File: python.info,  Node: MMDF,  Prev: Babyl,  Up: Mailbox objects

5.19.4.6 ‘MMDF’
...............

 -- Class: mailbox.MMDF (path, factory=None, create=True)

     A subclass of *note Mailbox: 841. for mailboxes in MMDF format.
     Parameter `factory' is a callable object that accepts a file-like
     message representation (which behaves as if opened in binary mode)
     and returns a custom representation.  If `factory' is ‘None’, *note
     MMDFMessage: 2208. is used as the default message representation.
     If `create' is ‘True’, the mailbox is created if it does not exist.

     MMDF is a single-file mailbox format invented for the Multichannel
     Memorandum Distribution Facility, a mail transfer agent.  Each
     message is in the same form as an mbox message but is bracketed
     before and after by lines containing four Control-A (‘'\001'’)
     characters.  As with the mbox format, the beginning of each message
     is indicated by a line whose first five characters are "From ", but
     additional occurrences of "From " are not transformed to ">From "
     when storing messages because the extra message separator lines
     prevent mistaking such occurrences for the starts of subsequent
     messages.

     Some *note Mailbox: 841. methods implemented by *note MMDF: 2207.
     deserve special remarks:

      -- Method: get_file (key)

          Using the file after calling ‘flush()’ or ‘close()’ on the
          *note MMDF: 2207. instance may yield unpredictable results or
          raise an exception.

      -- Method: lock ()
      -- Method: unlock ()

          Three locking mechanisms are used—dot locking and, if
          available, the ‘flock()’ and ‘lockf()’ system calls.

See also
........

mmdf man page from tin(1)

     A specification of MMDF format from the documentation of tin, a
     newsreader.

MMDF(2)

     A Wikipedia article describing the Multichannel Memorandum
     Distribution Facility.

   ---------- Footnotes ----------

   (1) http://www.tin.org/bin/man.cgi?section=5&topic=mmdf

   (2) https://en.wikipedia.org/wiki/MMDF


File: python.info,  Node: Message objects,  Next: Exceptions<10>,  Prev: Mailbox objects,  Up: mailbox --- Manipulate mailboxes in various formats

5.19.4.7 ‘Message’ objects
..........................

 -- Class: mailbox.Message (message=None)

     A subclass of the *note email.message: 70. module’s *note Message:
     3d2.  Subclasses of *note mailbox.Message: 845. add
     mailbox-format-specific state and behavior.

     If `message' is omitted, the new instance is created in a default,
     empty state.  If `message' is an *note email.message.Message: 3d2.
     instance, its contents are copied; furthermore, any format-specific
     information is converted insofar as possible if `message' is a
     *note Message: 845. instance.  If `message' is a string, a byte
     string, or a file, it should contain an RFC 2822(1)-compliant
     message, which is read and parsed.  Files should be open in binary
     mode, but text mode files are accepted for backward compatibility.

     The format-specific state and behaviors offered by subclasses vary,
     but in general it is only the properties that are not specific to a
     particular mailbox that are supported (although presumably the
     properties are specific to a particular mailbox format).  For
     example, file offsets for single-file mailbox formats and file
     names for directory-based mailbox formats are not retained, because
     they are only applicable to the original mailbox.  But state such
     as whether a message has been read by the user or marked as
     important is retained, because it applies to the message itself.

     There is no requirement that *note Message: 845. instances be used
     to represent messages retrieved using *note Mailbox: 841.
     instances.  In some situations, the time and memory required to
     generate *note Message: 845. representations might not be
     acceptable.  For such situations, *note Mailbox: 841. instances
     also offer string and file-like representations, and a custom
     message factory may be specified when a *note Mailbox: 841.
     instance is initialized.

* Menu:

* MaildirMessage:: 
* mboxMessage:: 
* MHMessage:: 
* BabylMessage:: 
* MMDFMessage:: 

   ---------- Footnotes ----------

   (1) https://tools.ietf.org/html/rfc2822.html


File: python.info,  Node: MaildirMessage,  Next: mboxMessage,  Up: Message objects

5.19.4.8 ‘MaildirMessage’
.........................

 -- Class: mailbox.MaildirMessage (message=None)

     A message with Maildir-specific behaviors.  Parameter `message' has
     the same meaning as with the *note Message: 845. constructor.

     Typically, a mail user agent application moves all of the messages
     in the ‘new’ subdirectory to the ‘cur’ subdirectory after the first
     time the user opens and closes the mailbox, recording that the
     messages are old whether or not they’ve actually been read.  Each
     message in ‘cur’ has an "info" section added to its file name to
     store information about its state.  (Some mail readers may also add
     an "info" section to messages in ‘new’.)  The "info" section may
     take one of two forms: it may contain "2," followed by a list of
     standardized flags (e.g., "2,FR") or it may contain "1," followed
     by so-called experimental information.  Standard flags for Maildir
     messages are as follows:

     Flag       Meaning       Explanation
                              
     --------------------------------------------------------------
                              
     D          Draft         Under composition
                              
                              
     F          Flagged       Marked as important
                              
                              
     P          Passed        Forwarded, resent, or bounced
                              
                              
     R          Replied       Replied to
                              
                              
     S          Seen          Read
                              
                              
     T          Trashed       Marked for subsequent deletion
                              

     *note MaildirMessage: 21d5. instances offer the following methods:

      -- Method: get_subdir ()

          Return either "new" (if the message should be stored in the
          ‘new’ subdirectory) or "cur" (if the message should be stored
          in the ‘cur’ subdirectory).

               Note: A message is typically moved from ‘new’ to ‘cur’
               after its mailbox has been accessed, whether or not the
               message is has been read.  A message ‘msg’ has been read
               if ‘"S" in msg.get_flags()’ is ‘True’.

      -- Method: set_subdir (subdir)

          Set the subdirectory the message should be stored in.
          Parameter `subdir' must be either "new" or "cur".

      -- Method: get_flags ()

          Return a string specifying the flags that are currently set.
          If the message complies with the standard Maildir format, the
          result is the concatenation in alphabetical order of zero or
          one occurrence of each of ‘'D'’, ‘'F'’, ‘'P'’, ‘'R'’, ‘'S'’,
          and ‘'T'’.  The empty string is returned if no flags are set
          or if "info" contains experimental semantics.

      -- Method: set_flags (flags)

          Set the flags specified by `flags' and unset all others.

      -- Method: add_flag (flag)

          Set the flag(s) specified by `flag' without changing other
          flags.  To add more than one flag at a time, `flag' may be a
          string of more than one character.  The current "info" is
          overwritten whether or not it contains experimental
          information rather than flags.

      -- Method: remove_flag (flag)

          Unset the flag(s) specified by `flag' without changing other
          flags.  To remove more than one flag at a time, `flag' maybe a
          string of more than one character.  If "info" contains
          experimental information rather than flags, the current "info"
          is not modified.

      -- Method: get_date ()

          Return the delivery date of the message as a floating-point
          number representing seconds since the epoch.

      -- Method: set_date (date)

          Set the delivery date of the message to `date', a
          floating-point number representing seconds since the epoch.

      -- Method: get_info ()

          Return a string containing the "info" for a message.  This is
          useful for accessing and modifying "info" that is experimental
          (i.e., not a list of flags).

      -- Method: set_info (info)

          Set "info" to `info', which should be a string.

When a *note MaildirMessage: 21d5. instance is created based upon an
*note mboxMessage: 21bc. or *note MMDFMessage: 2208. instance, the
‘Status’ and ‘X-Status’ headers are omitted and the following
conversions take place:

Resulting state          *note mboxMessage: 21bc. or
                         *note MMDFMessage: 2208. state
                         
----------------------------------------------------------------------------
                         
"cur" subdirectory       O flag
                         
                         
F flag                   F flag
                         
                         
R flag                   A flag
                         
                         
S flag                   R flag
                         
                         
T flag                   D flag
                         

When a *note MaildirMessage: 21d5. instance is created based upon an
*note MHMessage: 21ed. instance, the following conversions take place:

Resulting state                     *note MHMessage: 21ed. state
                                    
-------------------------------------------------------------------
                                    
"cur" subdirectory                  "unseen" sequence
                                    
                                    
"cur" subdirectory and S flag       no "unseen" sequence
                                    
                                    
F flag                              "flagged" sequence
                                    
                                    
R flag                              "replied" sequence
                                    

When a *note MaildirMessage: 21d5. instance is created based upon a
*note BabylMessage: 2200. instance, the following conversions take
place:

Resulting state                     *note BabylMessage: 2200. state
                                    
------------------------------------------------------------------------
                                    
"cur" subdirectory                  "unseen" label
                                    
                                    
"cur" subdirectory and S flag       no "unseen" label
                                    
                                    
P flag                              "forwarded" or "resent" label
                                    
                                    
R flag                              "answered" label
                                    
                                    
T flag                              "deleted" label
                                    

