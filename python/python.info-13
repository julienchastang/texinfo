This is python.info, produced by makeinfo version 6.0 from python.texi.

     Python 3.6.0a0, May 06, 2016

     Georg Brandl

     Copyright © 2001-2016, Python Software Foundation

INFO-DIR-SECTION Documentation tools
START-INFO-DIR-ENTRY
* Python: (python.info). The Python Programming Language
END-INFO-DIR-ENTRY


   Generated by Sphinx 1.4.1.


File: python.info,  Node: enum --- Support for enumerations,  Prev: reprlib --- Alternate repr implementation,  Up: Data Types

5.8.13 ‘enum’ — Support for enumerations
----------------------------------------

New in version 3.4.

`Source code:' Lib/enum.py(1)

__________________________________________________________________

An enumeration is a set of symbolic names (members) bound to unique,
constant values.  Within an enumeration, the members can be compared by
identity, and the enumeration itself can be iterated over.

* Menu:

* Module Contents: Module Contents<2>. 
* Creating an Enum:: 
* Programmatic access to enumeration members and their attributes:: 
* Duplicating enum members and values:: 
* Ensuring unique enumeration values:: 
* Iteration:: 
* Comparisons: Comparisons<3>. 
* Allowed members and attributes of enumerations:: 
* Restricted subclassing of enumerations:: 
* Pickling:: 
* Functional API:: 
* Derived Enumerations:: 
* Interesting examples:: 
* How are Enums different?:: 

   ---------- Footnotes ----------

   (1) https://hg.python.org/cpython/file/default/Lib/enum.py


File: python.info,  Node: Module Contents<2>,  Next: Creating an Enum,  Up: enum --- Support for enumerations

5.8.13.1 Module Contents
........................

This module defines two enumeration classes that can be used to define
unique sets of names and values: *note Enum: 286. and *note IntEnum:
1393.  It also defines one decorator, *note unique(): 1394.

 -- Class: enum.Enum

     Base class for creating enumerated constants.  See section *note
     Functional API: 1395. for an alternate construction syntax.

 -- Class: enum.IntEnum

     Base class for creating enumerated constants that are also
     subclasses of *note int: 227.

 -- Function: enum.unique ()

     Enum class decorator that ensures only one name is bound to any one
     value.


File: python.info,  Node: Creating an Enum,  Next: Programmatic access to enumeration members and their attributes,  Prev: Module Contents<2>,  Up: enum --- Support for enumerations

5.8.13.2 Creating an Enum
.........................

Enumerations are created using the *note class: 8d6. syntax, which makes
them easy to read and write.  An alternative creation method is
described in *note Functional API: 1395.  To define an enumeration,
subclass *note Enum: 286. as follows:

     >>> from enum import Enum
     >>> class Color(Enum):
     ...     red = 1
     ...     green = 2
     ...     blue = 3
     ...

     Note: Nomenclature

        - The class ‘Color’ is an `enumeration' (or `enum')

        - The attributes ‘Color.red’, ‘Color.green’, etc., are
          `enumeration members' (or `enum members').

        - The enum members have `names' and `values' (the name of
          ‘Color.red’ is ‘red’, the value of ‘Color.blue’ is ‘3’, etc.)

     Note: Even though we use the *note class: 8d6. syntax to create
     Enums, Enums are not normal Python classes.  See *note How are
     Enums different?: 1397. for more details.

Enumeration members have human readable string representations:

     >>> print(Color.red)
     Color.red

...while their ‘repr’ has more information:

     >>> print(repr(Color.red))
     <Color.red: 1>

The `type' of an enumeration member is the enumeration it belongs to:

     >>> type(Color.red)
     <enum 'Color'>
     >>> isinstance(Color.green, Color)
     True
     >>>

Enum members also have a property that contains just their item name:

     >>> print(Color.red.name)
     red

Enumerations support iteration, in definition order:

     >>> class Shake(Enum):
     ...     vanilla = 7
     ...     chocolate = 4
     ...     cookies = 9
     ...     mint = 3
     ...
     >>> for shake in Shake:
     ...     print(shake)
     ...
     Shake.vanilla
     Shake.chocolate
     Shake.cookies
     Shake.mint

Enumeration members are hashable, so they can be used in dictionaries
and sets:

     >>> apples = {}
     >>> apples[Color.red] = 'red delicious'
     >>> apples[Color.green] = 'granny smith'
     >>> apples == {Color.red: 'red delicious', Color.green: 'granny smith'}
     True


File: python.info,  Node: Programmatic access to enumeration members and their attributes,  Next: Duplicating enum members and values,  Prev: Creating an Enum,  Up: enum --- Support for enumerations

5.8.13.3 Programmatic access to enumeration members and their attributes
........................................................................

Sometimes it’s useful to access members in enumerations programmatically
(i.e.  situations where ‘Color.red’ won’t do because the exact color is
not known at program-writing time).  ‘Enum’ allows such access:

     >>> Color(1)
     <Color.red: 1>
     >>> Color(3)
     <Color.blue: 3>

If you want to access enum members by `name', use item access:

     >>> Color['red']
     <Color.red: 1>
     >>> Color['green']
     <Color.green: 2>

If you have an enum member and need its ‘name’ or ‘value’:

     >>> member = Color.red
     >>> member.name
     'red'
     >>> member.value
     1


File: python.info,  Node: Duplicating enum members and values,  Next: Ensuring unique enumeration values,  Prev: Programmatic access to enumeration members and their attributes,  Up: enum --- Support for enumerations

5.8.13.4 Duplicating enum members and values
............................................

Having two enum members with the same name is invalid:

     >>> class Shape(Enum):
     ...     square = 2
     ...     square = 3
     ...
     Traceback (most recent call last):
     ...
     TypeError: Attempted to reuse key: 'square'

However, two enum members are allowed to have the same value.  Given two
members A and B with the same value (and A defined first), B is an alias
to A. By-value lookup of the value of A and B will return A. By-name
lookup of B will also return A:

     >>> class Shape(Enum):
     ...     square = 2
     ...     diamond = 1
     ...     circle = 3
     ...     alias_for_square = 2
     ...
     >>> Shape.square
     <Shape.square: 2>
     >>> Shape.alias_for_square
     <Shape.square: 2>
     >>> Shape(2)
     <Shape.square: 2>

     Note: Attempting to create a member with the same name as an
     already defined attribute (another member, a method, etc.)  or
     attempting to create an attribute with the same name as a member is
     not allowed.


File: python.info,  Node: Ensuring unique enumeration values,  Next: Iteration,  Prev: Duplicating enum members and values,  Up: enum --- Support for enumerations

5.8.13.5 Ensuring unique enumeration values
...........................................

By default, enumerations allow multiple names as aliases for the same
value.  When this behavior isn’t desired, the following decorator can be
used to ensure each value is used only once in the enumeration:

 -- Function: @enum.unique

A *note class: 8d6. decorator specifically for enumerations.  It
searches an enumeration’s ‘__members__’ gathering any aliases it finds;
if any are found *note ValueError: 19c. is raised with the details:

     >>> from enum import Enum, unique
     >>> @unique
     ... class Mistake(Enum):
     ...     one = 1
     ...     two = 2
     ...     three = 3
     ...     four = 3
     ...
     Traceback (most recent call last):
     ...
     ValueError: duplicate values found in <enum 'Mistake'>: four -> three


File: python.info,  Node: Iteration,  Next: Comparisons<3>,  Prev: Ensuring unique enumeration values,  Up: enum --- Support for enumerations

5.8.13.6 Iteration
..................

Iterating over the members of an enum does not provide the aliases:

     >>> list(Shape)
     [<Shape.square: 2>, <Shape.diamond: 1>, <Shape.circle: 3>]

The special attribute ‘__members__’ is an ordered dictionary mapping
names to members.  It includes all names defined in the enumeration,
including the aliases:

     >>> for name, member in Shape.__members__.items():
     ...     name, member
     ...
     ('square', <Shape.square: 2>)
     ('diamond', <Shape.diamond: 1>)
     ('circle', <Shape.circle: 3>)
     ('alias_for_square', <Shape.square: 2>)

The ‘__members__’ attribute can be used for detailed programmatic access
to the enumeration members.  For example, finding all the aliases:

     >>> [name for name, member in Shape.__members__.items() if member.name != name]
     ['alias_for_square']


File: python.info,  Node: Comparisons<3>,  Next: Allowed members and attributes of enumerations,  Prev: Iteration,  Up: enum --- Support for enumerations

5.8.13.7 Comparisons
....................

Enumeration members are compared by identity:

     >>> Color.red is Color.red
     True
     >>> Color.red is Color.blue
     False
     >>> Color.red is not Color.blue
     True

Ordered comparisons between enumeration values are `not' supported.
Enum members are not integers (but see *note IntEnum: 139d. below):

     >>> Color.red < Color.blue
     Traceback (most recent call last):
       File "<stdin>", line 1, in <module>
     TypeError: unorderable types: Color() < Color()

Equality comparisons are defined though:

     >>> Color.blue == Color.red
     False
     >>> Color.blue != Color.red
     True
     >>> Color.blue == Color.blue
     True

Comparisons against non-enumeration values will always compare not equal
(again, *note IntEnum: 1393. was explicitly designed to behave
differently, see below):

     >>> Color.blue == 2
     False


File: python.info,  Node: Allowed members and attributes of enumerations,  Next: Restricted subclassing of enumerations,  Prev: Comparisons<3>,  Up: enum --- Support for enumerations

5.8.13.8 Allowed members and attributes of enumerations
.......................................................

The examples above use integers for enumeration values.  Using integers
is short and handy (and provided by default by the *note Functional API:
1395.), but not strictly enforced.  In the vast majority of use-cases,
one doesn’t care what the actual value of an enumeration is.  But if the
value `is' important, enumerations can have arbitrary values.

Enumerations are Python classes, and can have methods and special
methods as usual.  If we have this enumeration:

     >>> class Mood(Enum):
     ...     funky = 1
     ...     happy = 3
     ...
     ...     def describe(self):
     ...         # self is the member here
     ...         return self.name, self.value
     ...
     ...     def __str__(self):
     ...         return 'my custom str! {0}'.format(self.value)
     ...
     ...     @classmethod
     ...     def favorite_mood(cls):
     ...         # cls here is the enumeration
     ...         return cls.happy
     ...

Then:

     >>> Mood.favorite_mood()
     <Mood.happy: 3>
     >>> Mood.happy.describe()
     ('happy', 3)
     >>> str(Mood.funky)
     'my custom str! 1'

The rules for what is allowed are as follows: names that start and end
with a with a single underscore are reserved by enum and cannot be used;
all other attributes defined within an enumeration will become members
of this enumeration, with the exception of special methods (*note
__str__(): ab9, *note __add__(): e19, etc.)  and descriptors (methods
are also descriptors).

Note: if your enumeration defines *note __new__(): 484. and/or *note
__init__(): 9d5. then whatever value(s) were given to the enum member
will be passed into those methods.  See *note Planet: 139f. for an
example.


File: python.info,  Node: Restricted subclassing of enumerations,  Next: Pickling,  Prev: Allowed members and attributes of enumerations,  Up: enum --- Support for enumerations

5.8.13.9 Restricted subclassing of enumerations
...............................................

Subclassing an enumeration is allowed only if the enumeration does not
define any members.  So this is forbidden:

     >>> class MoreColor(Color):
     ...     pink = 17
     ...
     Traceback (most recent call last):
     ...
     TypeError: Cannot extend enumerations

But this is allowed:

     >>> class Foo(Enum):
     ...     def some_behavior(self):
     ...         pass
     ...
     >>> class Bar(Foo):
     ...     happy = 1
     ...     sad = 2
     ...

Allowing subclassing of enums that define members would lead to a
violation of some important invariants of types and instances.  On the
other hand, it makes sense to allow sharing some common behavior between
a group of enumerations.  (See *note OrderedEnum: 13a1. for an example.)


File: python.info,  Node: Pickling,  Next: Functional API,  Prev: Restricted subclassing of enumerations,  Up: enum --- Support for enumerations

5.8.13.10 Pickling
..................

Enumerations can be pickled and unpickled:

     >>> from test.test_enum import Fruit
     >>> from pickle import dumps, loads
     >>> Fruit.tomato is loads(dumps(Fruit.tomato))
     True

The usual restrictions for pickling apply: picklable enums must be
defined in the top level of a module, since unpickling requires them to
be importable from that module.

     Note: With pickle protocol version 4 it is possible to easily
     pickle enums nested in other classes.

It is possible to modify how Enum members are pickled/unpickled by
defining *note __reduce_ex__(): 13a3. in the enumeration class.


File: python.info,  Node: Functional API,  Next: Derived Enumerations,  Prev: Pickling,  Up: enum --- Support for enumerations

5.8.13.11 Functional API
........................

The *note Enum: 286. class is callable, providing the following
functional API:

     >>> Animal = Enum('Animal', 'ant bee cat dog')
     >>> Animal
     <enum 'Animal'>
     >>> Animal.ant
     <Animal.ant: 1>
     >>> Animal.ant.value
     1
     >>> list(Animal)
     [<Animal.ant: 1>, <Animal.bee: 2>, <Animal.cat: 3>, <Animal.dog: 4>]

The semantics of this API resemble *note namedtuple: 229.  The first
argument of the call to *note Enum: 286. is the name of the enumeration.

The second argument is the `source' of enumeration member names.  It can
be a whitespace-separated string of names, a sequence of names, a
sequence of 2-tuples with key/value pairs, or a mapping (e.g.
dictionary) of names to values.  The last two options enable assigning
arbitrary values to enumerations; the others auto-assign increasing
integers starting with 1 (use the ‘start’ parameter to specify a
different starting value).  A new class derived from *note Enum: 286. is
returned.  In other words, the above assignment to ‘Animal’ is
equivalent to:

     >>> class Animal(Enum):
     ...     ant = 1
     ...     bee = 2
     ...     cat = 3
     ...     dog = 4
     ...

The reason for defaulting to ‘1’ as the starting number and not ‘0’ is
that ‘0’ is ‘False’ in a boolean sense, but enum members all evaluate to
‘True’.

Pickling enums created with the functional API can be tricky as frame
stack implementation details are used to try and figure out which module
the enumeration is being created in (e.g.  it will fail if you use a
utility function in separate module, and also may not work on IronPython
or Jython).  The solution is to specify the module name explicitly as
follows:

     >>> Animal = Enum('Animal', 'ant bee cat dog', module=__name__)

     Warning: If ‘module’ is not supplied, and Enum cannot determine
     what it is, the new Enum members will not be unpicklable; to keep
     errors closer to the source, pickling will be disabled.

The new pickle protocol 4 also, in some circumstances, relies on
‘__qualname__’ being set to the location where pickle will be able to
find the class.  For example, if the class was made available in class
SomeData in the global scope:

     >>> Animal = Enum('Animal', 'ant bee cat dog', qualname='SomeData.Animal')

The complete signature is:

     Enum(value='NewEnumName', names=<...>, *, module='...', qualname='...', type=<mixed-in class>, start=1)


value: What the new Enum class will record as its name.


names: The Enum members.  This can be a whitespace or comma separated
string (values will start at 1 unless otherwise specified):

     'red green blue' | 'red,green,blue' | 'red, green, blue'

or an iterator of names:

     ['red', 'green', 'blue']

or an iterator of (name, value) pairs:

     [('cyan', 4), ('magenta', 5), ('yellow', 6)]

or a mapping:

     {'chartreuse': 7, 'sea_green': 11, 'rosemary': 42}


module: name of module where new Enum class can be found.


qualname: where in module new Enum class can be found.


type: type to mix in to new Enum class.


start: number to start counting at if only names are passed in.

Changed in version 3.5: The `start' parameter was added.


File: python.info,  Node: Derived Enumerations,  Next: Interesting examples,  Prev: Functional API,  Up: enum --- Support for enumerations

5.8.13.12 Derived Enumerations
..............................

* Menu:

* IntEnum:: 
* Others:: 


File: python.info,  Node: IntEnum,  Next: Others,  Up: Derived Enumerations

5.8.13.13 IntEnum
.................

A variation of *note Enum: 286. is provided which is also a subclass of
*note int: 227.  Members of an *note IntEnum: 1393. can be compared to
integers; by extension, integer enumerations of different types can also
be compared to each other:

     >>> from enum import IntEnum
     >>> class Shape(IntEnum):
     ...     circle = 1
     ...     square = 2
     ...
     >>> class Request(IntEnum):
     ...     post = 1
     ...     get = 2
     ...
     >>> Shape == 1
     False
     >>> Shape.circle == 1
     True
     >>> Shape.circle == Request.post
     True

However, they still can’t be compared to standard *note Enum: 286.
enumerations:

     >>> class Shape(IntEnum):
     ...     circle = 1
     ...     square = 2
     ...
     >>> class Color(Enum):
     ...     red = 1
     ...     green = 2
     ...
     >>> Shape.circle == Color.red
     False

*note IntEnum: 1393. values behave like integers in other ways you’d
expect:

     >>> int(Shape.circle)
     1
     >>> ['a', 'b', 'c'][Shape.circle]
     'b'
     >>> [i for i in range(Shape.square)]
     [0, 1]

For the vast majority of code, *note Enum: 286. is strongly recommended,
since *note IntEnum: 1393. breaks some semantic promises of an
enumeration (by being comparable to integers, and thus by transitivity
to other unrelated enumerations).  It should be used only in special
cases where there’s no other choice; for example, when integer constants
are replaced with enumerations and backwards compatibility is required
with code that still expects integers.


File: python.info,  Node: Others,  Prev: IntEnum,  Up: Derived Enumerations

5.8.13.14 Others
................

While *note IntEnum: 1393. is part of the *note enum: 79. module, it
would be very simple to implement independently:

     class IntEnum(int, Enum):
         pass

This demonstrates how similar derived enumerations can be defined; for
example a ‘StrEnum’ that mixes in *note str: 25a. instead of *note int:
227.

Some rules:

  1. When subclassing *note Enum: 286, mix-in types must appear before
     *note Enum: 286. itself in the sequence of bases, as in the *note
     IntEnum: 1393. example above.

  2. While *note Enum: 286. can have members of any type, once you mix
     in an additional type, all the members must have values of that
     type, e.g.  *note int: 227. above.  This restriction does not apply
     to mix-ins which only add methods and don’t specify another data
     type such as *note int: 227. or *note str: 25a.

  3. When another data type is mixed in, the ‘value’ attribute is `not
     the same' as the enum member itself, although it is equivalent and
     will compare equal.

  4. %-style formatting: ‘%s’ and ‘%r’ call the *note Enum: 286. class’s
     *note __str__(): ab9. and *note __repr__(): 7bd. respectively;
     other codes (such as ‘%i’ or ‘%h’ for IntEnum) treat the enum
     member as its mixed-in type.

  5. *note Formatted string literals: 14f, *note str.format(): 14d, and
     *note format(): 14e. will use the mixed-in type’s *note
     __format__(): 561.  If the *note Enum: 286. class’s *note str():
     25a. or *note repr(): 3bb. is desired, use the ‘!s’ or ‘!r’ format
     codes.


File: python.info,  Node: Interesting examples,  Next: How are Enums different?,  Prev: Derived Enumerations,  Up: enum --- Support for enumerations

5.8.13.15 Interesting examples
..............................

While *note Enum: 286. and *note IntEnum: 1393. are expected to cover
the majority of use-cases, they cannot cover them all.  Here are recipes
for some different types of enumerations that can be used directly, or
as examples for creating one’s own.

* Menu:

* AutoNumber:: 
* OrderedEnum:: 
* DuplicateFreeEnum:: 
* Planet:: 


File: python.info,  Node: AutoNumber,  Next: OrderedEnum,  Up: Interesting examples

5.8.13.16 AutoNumber
....................

Avoids having to specify the value for each enumeration member:

     >>> class AutoNumber(Enum):
     ...     def __new__(cls):
     ...         value = len(cls.__members__) + 1
     ...         obj = object.__new__(cls)
     ...         obj._value_ = value
     ...         return obj
     ...
     >>> class Color(AutoNumber):
     ...     red = ()
     ...     green = ()
     ...     blue = ()
     ...
     >>> Color.green.value == 2
     True

     Note: The *note __new__(): 484. method, if defined, is used during
     creation of the Enum members; it is then replaced by Enum’s *note
     __new__(): 484. which is used after class creation for lookup of
     existing members.


File: python.info,  Node: OrderedEnum,  Next: DuplicateFreeEnum,  Prev: AutoNumber,  Up: Interesting examples

5.8.13.17 OrderedEnum
.....................

An ordered enumeration that is not based on *note IntEnum: 1393. and so
maintains the normal *note Enum: 286. invariants (such as not being
comparable to other enumerations):

     >>> class OrderedEnum(Enum):
     ...     def __ge__(self, other):
     ...         if self.__class__ is other.__class__:
     ...             return self.value >= other.value
     ...         return NotImplemented
     ...     def __gt__(self, other):
     ...         if self.__class__ is other.__class__:
     ...             return self.value > other.value
     ...         return NotImplemented
     ...     def __le__(self, other):
     ...         if self.__class__ is other.__class__:
     ...             return self.value <= other.value
     ...         return NotImplemented
     ...     def __lt__(self, other):
     ...         if self.__class__ is other.__class__:
     ...             return self.value < other.value
     ...         return NotImplemented
     ...
     >>> class Grade(OrderedEnum):
     ...     A = 5
     ...     B = 4
     ...     C = 3
     ...     D = 2
     ...     F = 1
     ...
     >>> Grade.C < Grade.A
     True


File: python.info,  Node: DuplicateFreeEnum,  Next: Planet,  Prev: OrderedEnum,  Up: Interesting examples

5.8.13.18 DuplicateFreeEnum
...........................

Raises an error if a duplicate member name is found instead of creating
an alias:

     >>> class DuplicateFreeEnum(Enum):
     ...     def __init__(self, *args):
     ...         cls = self.__class__
     ...         if any(self.value == e.value for e in cls):
     ...             a = self.name
     ...             e = cls(self.value).name
     ...             raise ValueError(
     ...                 "aliases not allowed in DuplicateFreeEnum:  %r --> %r"
     ...                 % (a, e))
     ...
     >>> class Color(DuplicateFreeEnum):
     ...     red = 1
     ...     green = 2
     ...     blue = 3
     ...     grene = 2
     ...
     Traceback (most recent call last):
     ...
     ValueError: aliases not allowed in DuplicateFreeEnum:  'grene' --> 'green'

     Note: This is a useful example for subclassing Enum to add or
     change other behaviors as well as disallowing aliases.  If the only
     desired change is disallowing aliases, the *note unique(): 1394.
     decorator can be used instead.


File: python.info,  Node: Planet,  Prev: DuplicateFreeEnum,  Up: Interesting examples

5.8.13.19 Planet
................

If *note __new__(): 484. or *note __init__(): 9d5. is defined the value
of the enum member will be passed to those methods:

     >>> class Planet(Enum):
     ...     MERCURY = (3.303e+23, 2.4397e6)
     ...     VENUS   = (4.869e+24, 6.0518e6)
     ...     EARTH   = (5.976e+24, 6.37814e6)
     ...     MARS    = (6.421e+23, 3.3972e6)
     ...     JUPITER = (1.9e+27,   7.1492e7)
     ...     SATURN  = (5.688e+26, 6.0268e7)
     ...     URANUS  = (8.686e+25, 2.5559e7)
     ...     NEPTUNE = (1.024e+26, 2.4746e7)
     ...     def __init__(self, mass, radius):
     ...         self.mass = mass       # in kilograms
     ...         self.radius = radius   # in meters
     ...     @property
     ...     def surface_gravity(self):
     ...         # universal gravitational constant  (m3 kg-1 s-2)
     ...         G = 6.67300E-11
     ...         return G * self.mass / (self.radius * self.radius)
     ...
     >>> Planet.EARTH.value
     (5.976e+24, 6378140.0)
     >>> Planet.EARTH.surface_gravity
     9.802652743337129


File: python.info,  Node: How are Enums different?,  Prev: Interesting examples,  Up: enum --- Support for enumerations

5.8.13.20 How are Enums different?
..................................

Enums have a custom metaclass that affects many aspects of both derived
Enum classes and their instances (members).

* Menu:

* Enum Classes:: 
* Enum Members (aka instances): Enum Members aka instances. 
* Finer Points:: 


File: python.info,  Node: Enum Classes,  Next: Enum Members aka instances,  Up: How are Enums different?

5.8.13.21 Enum Classes
......................

The ‘EnumMeta’ metaclass is responsible for providing the *note
__contains__(): 99c, *note __dir__(): 9a7, *note __iter__(): 99b. and
other methods that allow one to do things with an *note Enum: 286. class
that fail on a typical class, such as ‘list(Color)’ or ‘some_var in
Color’.  ‘EnumMeta’ is responsible for ensuring that various other
methods on the final *note Enum: 286. class are correct (such as *note
__new__(): 484, *note __getnewargs__(): 254, *note __str__(): ab9. and
*note __repr__(): 7bd.).


File: python.info,  Node: Enum Members aka instances,  Next: Finer Points,  Prev: Enum Classes,  Up: How are Enums different?

5.8.13.22 Enum Members (aka instances)
......................................

The most interesting thing about Enum members is that they are
singletons.  ‘EnumMeta’ creates them all while it is creating the *note
Enum: 286. class itself, and then puts a custom *note __new__(): 484. in
place to ensure that no new ones are ever instantiated by returning only
the existing member instances.


File: python.info,  Node: Finer Points,  Prev: Enum Members aka instances,  Up: How are Enums different?

5.8.13.23 Finer Points
......................

*note Enum: 286. members are instances of an *note Enum: 286. class, and
even though they are accessible as ‘EnumClass.member’, they should not
be accessed directly from the member as that lookup may fail or, worse,
return something besides the *note Enum: 286. member you looking for:

     >>> class FieldTypes(Enum):
     ...     name = 0
     ...     value = 1
     ...     size = 2
     ...
     >>> FieldTypes.value.size
     <FieldTypes.size: 2>
     >>> FieldTypes.size.value
     2

Changed in version 3.5.

Boolean evaluation: Enum classes that are mixed with non-Enum types
(such as *note int: 227, *note str: 25a, etc.)  are evaluated according
to the mixed-in type’s rules; otherwise, all members evaluate as ‘True’.
To make your own Enum’s boolean evaluation depend on the member’s value
add the following to your class:

     def __bool__(self):
         return bool(self.value)

The ‘__members__’ attribute is only available on the class.

If you give your *note Enum: 286. subclass extra methods, like the *note
Planet: 139f. class above, those methods will show up in a *note dir():
16a. of the member, but not of the class:

     >>> dir(Planet)
     ['EARTH', 'JUPITER', 'MARS', 'MERCURY', 'NEPTUNE', 'SATURN', 'URANUS', 'VENUS', '__class__', '__doc__', '__members__', '__module__']
     >>> dir(Planet.EARTH)
     ['__class__', '__doc__', '__module__', 'name', 'surface_gravity', 'value']

The *note __new__(): 484. method will only be used for the creation of
the *note Enum: 286. members – after that it is replaced.  Any custom
*note __new__(): 484. method must create the object and set the
‘_value_’ attribute appropriately.

If you wish to change how *note Enum: 286. members are looked up you
should either write a helper function or a *note classmethod(): 5f4. for
the *note Enum: 286. subclass.


File: python.info,  Node: Numeric and Mathematical Modules,  Next: Functional Programming Modules,  Prev: Data Types,  Up: The Python Standard Library

5.9 Numeric and Mathematical Modules
====================================

The modules described in this chapter provide numeric and math-related
functions and data types.  The *note numbers: bf. module defines an
abstract hierarchy of numeric types.  The *note math: b0. and *note
cmath: 19. modules contain various mathematical functions for
floating-point and complex numbers.  The *note decimal: 34. module
supports exact representations of decimal numbers, using arbitrary
precision arithmetic.

The following modules are documented in this chapter:

* Menu:

* numbers: numbers --- Numeric abstract base classes. Numeric abstract base classes
* math: math --- Mathematical functions. Mathematical functions
* cmath: cmath --- Mathematical functions for complex numbers. Mathematical functions for complex numbers
* decimal: decimal --- Decimal fixed point and floating point arithmetic. Decimal fixed point and floating point arithmetic
* fractions: fractions --- Rational numbers. Rational numbers
* random: random --- Generate pseudo-random numbers. Generate pseudo-random numbers
* statistics: statistics --- Mathematical statistics functions. Mathematical statistics functions


File: python.info,  Node: numbers --- Numeric abstract base classes,  Next: math --- Mathematical functions,  Up: Numeric and Mathematical Modules

5.9.1 ‘numbers’ — Numeric abstract base classes
-----------------------------------------------

The *note numbers: bf. module ( PEP 3141(1)) defines a hierarchy of
numeric *note abstract base classes: 776. which progressively define
more operations.  None of the types defined in this module can be
instantiated.

 -- Class: numbers.Number

     The root of the numeric hierarchy.  If you just want to check if an
     argument `x' is a number, without caring what kind, use
     ‘isinstance(x, Number)’.

* Menu:

* The numeric tower:: 
* Notes for type implementors:: 

   ---------- Footnotes ----------

   (1) https://www.python.org/dev/peps/pep-3141


File: python.info,  Node: The numeric tower,  Next: Notes for type implementors,  Up: numbers --- Numeric abstract base classes

5.9.1.1 The numeric tower
.........................

 -- Class: numbers.Complex

     Subclasses of this type describe complex numbers and include the
     operations that work on the built-in *note complex: 579. type.
     These are: conversions to *note complex: 579. and *note bool: a72,
     *note real: 13b2, *note imag: 13b3, ‘+’, ‘-’, ‘*’, ‘/’, *note
     abs(): c7c, *note conjugate(): 13b4, ‘==’, and ‘!=’.  All except
     ‘-’ and ‘!=’ are abstract.

      -- Attribute: real

          Abstract.  Retrieves the real component of this number.

      -- Attribute: imag

          Abstract.  Retrieves the imaginary component of this number.

      -- Method: abstractmethod conjugate ()

          Abstract.  Returns the complex conjugate.  For example,
          ‘(1+3j).conjugate() == (1-3j)’.

 -- Class: numbers.Real

     To *note Complex: de5, *note Real: de4. adds the operations that
     work on real numbers.

     In short, those are: a conversion to *note float: 57a, *note
     math.trunc(): 9a2, *note round(): 8d9, *note math.floor(): 9a0,
     *note math.ceil(): 9a1, *note divmod(): e2c, ‘//’, ‘%’, ‘<’, ‘<=’,
     ‘>’, and ‘>=’.

     Real also provides defaults for *note complex(): 579, *note real:
     13b2, *note imag: 13b3, and *note conjugate(): 13b4.

 -- Class: numbers.Rational

     Subtypes *note Real: de4. and adds *note numerator: 13b5. and *note
     denominator: 13b6. properties, which should be in lowest terms.
     With these, it provides a default for *note float(): 57a.

      -- Attribute: numerator

          Abstract.

      -- Attribute: denominator

          Abstract.

 -- Class: numbers.Integral

     Subtypes *note Rational: 8c1. and adds a conversion to *note int:
     227.  Provides defaults for *note float(): 57a, *note numerator:
     13b5, and *note denominator: 13b6.  Adds abstract methods for ‘**’
     and bit-string operations: ‘<<’, ‘>>’, ‘&’, ‘^’, ‘|’, ‘~’.


File: python.info,  Node: Notes for type implementors,  Prev: The numeric tower,  Up: numbers --- Numeric abstract base classes

5.9.1.2 Notes for type implementors
...................................

Implementors should be careful to make equal numbers equal and hash them
to the same values.  This may be subtle if there are two different
extensions of the real numbers.  For example, *note fractions.Fraction:
378. implements *note hash(): 5e6. as follows:

     def __hash__(self):
         if self.denominator == 1:
             # Get integers right.
             return hash(self.numerator)
         # Expensive check, but definitely correct.
         if self == float(self):
             return hash(float(self))
         else:
             # Use tuple's hash to avoid a high collision rate on
             # simple fractions.
             return hash((self.numerator, self.denominator))

* Menu:

* Adding More Numeric ABCs:: 
* Implementing the arithmetic operations:: 


File: python.info,  Node: Adding More Numeric ABCs,  Next: Implementing the arithmetic operations,  Up: Notes for type implementors

5.9.1.3 Adding More Numeric ABCs
................................

There are, of course, more possible ABCs for numbers, and this would be
a poor hierarchy if it precluded the possibility of adding those.  You
can add ‘MyFoo’ between *note Complex: de5. and *note Real: de4. with:

     class MyFoo(Complex): ...
     MyFoo.register(Real)


File: python.info,  Node: Implementing the arithmetic operations,  Prev: Adding More Numeric ABCs,  Up: Notes for type implementors

5.9.1.4 Implementing the arithmetic operations
..............................................

We want to implement the arithmetic operations so that mixed-mode
operations either call an implementation whose author knew about the
types of both arguments, or convert both to the nearest built in type
and do the operation there.  For subtypes of *note Integral: de3, this
means that *note __add__(): e19. and *note __radd__(): e1a. should be
defined as:

     class MyIntegral(Integral):

         def __add__(self, other):
             if isinstance(other, MyIntegral):
                 return do_my_adding_stuff(self, other)
             elif isinstance(other, OtherTypeIKnowAbout):
                 return do_my_other_adding_stuff(self, other)
             else:
                 return NotImplemented

         def __radd__(self, other):
             if isinstance(other, MyIntegral):
                 return do_my_adding_stuff(other, self)
             elif isinstance(other, OtherTypeIKnowAbout):
                 return do_my_other_adding_stuff(other, self)
             elif isinstance(other, Integral):
                 return int(other) + int(self)
             elif isinstance(other, Real):
                 return float(other) + float(self)
             elif isinstance(other, Complex):
                 return complex(other) + complex(self)
             else:
                 return NotImplemented

There are 5 different cases for a mixed-type operation on subclasses of
*note Complex: de5.  I’ll refer to all of the above code that doesn’t
refer to ‘MyIntegral’ and ‘OtherTypeIKnowAbout’ as "boilerplate".  ‘a’
will be an instance of ‘A’, which is a subtype of *note Complex: de5.
(‘a : A <: Complex’), and ‘b : B <: Complex’.  I’ll consider ‘a + b’:

       1. If ‘A’ defines an *note __add__(): e19. which accepts ‘b’, all
          is well.

       2. If ‘A’ falls back to the boilerplate code, and it were to
          return a value from *note __add__(): e19, we’d miss the
          possibility that ‘B’ defines a more intelligent *note
          __radd__(): e1a, so the boilerplate should return *note
          NotImplemented: 441. from *note __add__(): e19.  (Or ‘A’ may
          not implement *note __add__(): e19. at all.)

       3. Then ‘B’’s *note __radd__(): e1a. gets a chance.  If it
          accepts ‘a’, all is well.

       4. If it falls back to the boilerplate, there are no more
          possible methods to try, so this is where the default
          implementation should live.

       5. If ‘B <: A’, Python tries ‘B.__radd__’ before ‘A.__add__’.
          This is ok, because it was implemented with knowledge of ‘A’,
          so it can handle those instances before delegating to *note
          Complex: de5.

If ‘A <: Complex’ and ‘B <: Real’ without sharing any other knowledge,
then the appropriate shared operation is the one involving the built in
*note complex: 579, and both *note __radd__(): e1a. s land there, so
‘a+b == b+a’.

Because most of the operations on any given type will be very similar,
it can be useful to define a helper function which generates the forward
and reverse instances of any given operator.  For example, *note
fractions.Fraction: 378. uses:

     def _operator_fallbacks(monomorphic_operator, fallback_operator):
         def forward(a, b):
             if isinstance(b, (int, Fraction)):
                 return monomorphic_operator(a, b)
             elif isinstance(b, float):
                 return fallback_operator(float(a), b)
             elif isinstance(b, complex):
                 return fallback_operator(complex(a), b)
             else:
                 return NotImplemented
         forward.__name__ = '__' + fallback_operator.__name__ + '__'
         forward.__doc__ = monomorphic_operator.__doc__

         def reverse(b, a):
             if isinstance(a, Rational):
                 # Includes ints.
                 return monomorphic_operator(a, b)
             elif isinstance(a, numbers.Real):
                 return fallback_operator(float(a), float(b))
             elif isinstance(a, numbers.Complex):
                 return fallback_operator(complex(a), complex(b))
             else:
                 return NotImplemented
         reverse.__name__ = '__r' + fallback_operator.__name__ + '__'
         reverse.__doc__ = monomorphic_operator.__doc__

         return forward, reverse

     def _add(a, b):
         """a + b"""
         return Fraction(a.numerator * b.denominator +
                         b.numerator * a.denominator,
                         a.denominator * b.denominator)

     __add__, __radd__ = _operator_fallbacks(_add, operator.add)

     # ...


File: python.info,  Node: math --- Mathematical functions,  Next: cmath --- Mathematical functions for complex numbers,  Prev: numbers --- Numeric abstract base classes,  Up: Numeric and Mathematical Modules

5.9.2 ‘math’ — Mathematical functions
-------------------------------------

This module is always available.  It provides access to the mathematical
functions defined by the C standard.

These functions cannot be used with complex numbers; use the functions
of the same name from the *note cmath: 19. module if you require support
for complex numbers.  The distinction between functions which support
complex numbers and those which don’t is made since most users do not
want to learn quite as much mathematics as required to understand
complex numbers.  Receiving an exception instead of a complex result
allows earlier detection of the unexpected complex number used as a
parameter, so that the programmer can determine how and why it was
generated in the first place.

The following functions are provided by this module.  Except when
explicitly noted otherwise, all return values are floats.

* Menu:

* Number-theoretic and representation functions:: 
* Power and logarithmic functions:: 
* Trigonometric functions:: 
* Angular conversion:: 
* Hyperbolic functions:: 
* Special functions:: 
* Constants:: 


File: python.info,  Node: Number-theoretic and representation functions,  Next: Power and logarithmic functions,  Up: math --- Mathematical functions

5.9.2.1 Number-theoretic and representation functions
.....................................................

 -- Function: math.ceil (x)

     Return the ceiling of `x', the smallest integer greater than or
     equal to `x'.  If `x' is not a float, delegates to ‘x.__ceil__()’,
     which should return an *note Integral: de3. value.

 -- Function: math.copysign (x, y)

     Return a float with the magnitude (absolute value) of `x' but the
     sign of `y'.  On platforms that support signed zeros,
     ‘copysign(1.0, -0.0)’ returns `-1.0'.

 -- Function: math.fabs (x)

     Return the absolute value of `x'.

 -- Function: math.factorial (x)

     Return `x' factorial.  Raises *note ValueError: 19c. if `x' is not
     integral or is negative.

 -- Function: math.floor (x)

     Return the floor of `x', the largest integer less than or equal to
     `x'.  If `x' is not a float, delegates to ‘x.__floor__()’, which
     should return an *note Integral: de3. value.

 -- Function: math.fmod (x, y)

     Return ‘fmod(x, y)’, as defined by the platform C library.  Note
     that the Python expression ‘x % y’ may not return the same result.
     The intent of the C standard is that ‘fmod(x, y)’ be exactly
     (mathematically; to infinite precision) equal to ‘x - n*y’ for some
     integer `n' such that the result has the same sign as `x' and
     magnitude less than ‘abs(y)’.  Python’s ‘x % y’ returns a result
     with the sign of `y' instead, and may not be exactly computable for
     float arguments.  For example, ‘fmod(-1e-100, 1e100)’ is ‘-1e-100’,
     but the result of Python’s ‘-1e-100 % 1e100’ is ‘1e100-1e-100’,
     which cannot be represented exactly as a float, and rounds to the
     surprising ‘1e100’.  For this reason, function *note fmod(): ef3.
     is generally preferred when working with floats, while Python’s ‘x
     % y’ is preferred when working with integers.

 -- Function: math.frexp (x)

     Return the mantissa and exponent of `x' as the pair ‘(m, e)’.  `m'
     is a float and `e' is an integer such that ‘x == m * 2**e’ exactly.
     If `x' is zero, returns ‘(0.0, 0)’, otherwise ‘0.5 <= abs(m) < 1’.
     This is used to "pick apart" the internal representation of a float
     in a portable way.

 -- Function: math.fsum (iterable)

     Return an accurate floating point sum of values in the iterable.
     Avoids loss of precision by tracking multiple intermediate partial
     sums:

          >>> sum([.1, .1, .1, .1, .1, .1, .1, .1, .1, .1])
          0.9999999999999999
          >>> fsum([.1, .1, .1, .1, .1, .1, .1, .1, .1, .1])
          1.0

     The algorithm’s accuracy depends on IEEE-754 arithmetic guarantees
     and the typical case where the rounding mode is half-even.  On some
     non-Windows builds, the underlying C library uses extended
     precision addition and may occasionally double-round an
     intermediate sum causing it to be off in its least significant bit.

     For further discussion and two alternative approaches, see the ASPN
     cookbook recipes for accurate floating point summation(1).

 -- Function: math.gcd (a, b)

     Return the greatest common divisor of the integers `a' and `b'.  If
     either `a' or `b' is nonzero, then the value of ‘gcd(a, b)’ is the
     largest positive integer that divides both `a' and `b'.  ‘gcd(0,
     0)’ returns ‘0’.

     New in version 3.5.

 -- Function: math.isclose (a, b, *, rel_tol=1e-09, abs_tol=0.0)

     Return ‘True’ if the values `a' and `b' are close to each other and
     ‘False’ otherwise.

     Whether or not two values are considered close is determined
     according to given absolute and relative tolerances.

     `rel_tol' is the relative tolerance – it is the maximum allowed
     difference between `a' and `b', relative to the larger absolute
     value of `a' or `b'.  For example, to set a tolerance of 5%, pass
     ‘rel_tol=0.05’.  The default tolerance is ‘1e-09’, which assures
     that the two values are the same within about 9 decimal digits.
     `rel_tol' must be greater than zero.

     `abs_tol' is the minimum absolute tolerance – useful for
     comparisons near zero.  `abs_tol' must be at least zero.

     If no errors occur, the result will be: ‘abs(a-b) <= max(rel_tol *
     max(abs(a), abs(b)), abs_tol)’.

     The IEEE 754 special values of ‘NaN’, ‘inf’, and ‘-inf’ will be
     handled according to IEEE rules.  Specifically, ‘NaN’ is not
     considered close to any other value, including ‘NaN’.  ‘inf’ and
     ‘-inf’ are only considered close to themselves.

     New in version 3.5.

     See also
     ........

     PEP 485(2) – A function for testing approximate equality

 -- Function: math.isfinite (x)

     Return ‘True’ if `x' is neither an infinity nor a NaN, and ‘False’
     otherwise.  (Note that ‘0.0’ `is' considered finite.)

     New in version 3.2.

 -- Function: math.isinf (x)

     Return ‘True’ if `x' is a positive or negative infinity, and
     ‘False’ otherwise.

 -- Function: math.isnan (x)

     Return ‘True’ if `x' is a NaN (not a number), and ‘False’
     otherwise.

 -- Function: math.ldexp (x, i)

     Return ‘x * (2**i)’.  This is essentially the inverse of function
     *note frexp(): 13be.

 -- Function: math.modf (x)

     Return the fractional and integer parts of `x'.  Both results carry
     the sign of `x' and are floats.

 -- Function: math.trunc (x)

     Return the *note Real: de4. value `x' truncated to an *note
     Integral: de3. (usually an integer).  Delegates to ‘x.__trunc__()’.

Note that *note frexp(): 13be. and *note modf(): 13c0. have a different
call/return pattern than their C equivalents: they take a single
argument and return a pair of values, rather than returning their second
return value through an ’output parameter’ (there is no such thing in
Python).

For the *note ceil(): 9a1, *note floor(): 9a0, and *note modf(): 13c0.
functions, note that `all' floating-point numbers of sufficiently large
magnitude are exact integers.  Python floats typically carry no more
than 53 bits of precision (the same as the platform C double type), in
which case any float `x' with ‘abs(x) >= 2**52’ necessarily has no
fractional bits.

   ---------- Footnotes ----------

   (1) https://code.activestate.com/recipes/393090/

   (2) https://www.python.org/dev/peps/pep-0485


File: python.info,  Node: Power and logarithmic functions,  Next: Trigonometric functions,  Prev: Number-theoretic and representation functions,  Up: math --- Mathematical functions

5.9.2.2 Power and logarithmic functions
.......................................

 -- Function: math.exp (x)

     Return ‘e**x’.

 -- Function: math.expm1 (x)

     Return ‘e**x - 1’.  For small floats `x', the subtraction in
     ‘exp(x) - 1’ can result in a significant loss of precision(1); the
     *note expm1(): 7b4. function provides a way to compute this
     quantity to full precision:

          >>> from math import exp, expm1
          >>> exp(1e-5) - 1  # gives result accurate to 11 places
          1.0000050000069649e-05
          >>> expm1(1e-5)    # result accurate to full precision
          1.0000050000166668e-05

     New in version 3.2.

 -- Function: math.log (x[, base])

     With one argument, return the natural logarithm of `x' (to base
     `e').

     With two arguments, return the logarithm of `x' to the given
     `base', calculated as ‘log(x)/log(base)’.

 -- Function: math.log1p (x)

     Return the natural logarithm of `1+x' (base `e').  The result is
     calculated in a way which is accurate for `x' near zero.

 -- Function: math.log2 (x)

     Return the base-2 logarithm of `x'.  This is usually more accurate
     than ‘log(x, 2)’.

     New in version 3.3.

     See also
     ........

     *note int.bit_length(): fd6. returns the number of bits necessary
     to represent an integer in binary, excluding the sign and leading
     zeros.

 -- Function: math.log10 (x)

     Return the base-10 logarithm of `x'.  This is usually more accurate
     than ‘log(x, 10)’.

 -- Function: math.pow (x, y)

     Return ‘x’ raised to the power ‘y’.  Exceptional cases follow Annex
     ’F’ of the C99 standard as far as possible.  In particular,
     ‘pow(1.0, x)’ and ‘pow(x, 0.0)’ always return ‘1.0’, even when ‘x’
     is a zero or a NaN. If both ‘x’ and ‘y’ are finite, ‘x’ is
     negative, and ‘y’ is not an integer then ‘pow(x, y)’ is undefined,
     and raises *note ValueError: 19c.

     Unlike the built-in ‘**’ operator, *note math.pow(): 13c3. converts
     both its arguments to type *note float: 57a.  Use ‘**’ or the
     built-in *note pow(): ad3. function for computing exact integer
     powers.

 -- Function: math.sqrt (x)

     Return the square root of `x'.

   ---------- Footnotes ----------

   (1) https://en.wikipedia.org/wiki/Loss_of_significance


File: python.info,  Node: Trigonometric functions,  Next: Angular conversion,  Prev: Power and logarithmic functions,  Up: math --- Mathematical functions

5.9.2.3 Trigonometric functions
...............................

 -- Function: math.acos (x)

     Return the arc cosine of `x', in radians.

 -- Function: math.asin (x)

     Return the arc sine of `x', in radians.

 -- Function: math.atan (x)

     Return the arc tangent of `x', in radians.

 -- Function: math.atan2 (y, x)

     Return ‘atan(y / x)’, in radians.  The result is between ‘-pi’ and
     ‘pi’.  The vector in the plane from the origin to point ‘(x, y)’
     makes this angle with the positive X axis.  The point of *note
     atan2(): 13c9. is that the signs of both inputs are known to it, so
     it can compute the correct quadrant for the angle.  For example,
     ‘atan(1)’ and ‘atan2(1, 1)’ are both ‘pi/4’, but ‘atan2(-1, -1)’ is
     ‘-3*pi/4’.

 -- Function: math.cos (x)

     Return the cosine of `x' radians.

 -- Function: math.hypot (x, y)

     Return the Euclidean norm, ‘sqrt(x*x + y*y)’.  This is the length
     of the vector from the origin to point ‘(x, y)’.

 -- Function: math.sin (x)

     Return the sine of `x' radians.

 -- Function: math.tan (x)

     Return the tangent of `x' radians.


File: python.info,  Node: Angular conversion,  Next: Hyperbolic functions,  Prev: Trigonometric functions,  Up: math --- Mathematical functions

5.9.2.4 Angular conversion
..........................

 -- Function: math.degrees (x)

     Convert angle `x' from radians to degrees.

 -- Function: math.radians (x)

     Convert angle `x' from degrees to radians.


File: python.info,  Node: Hyperbolic functions,  Next: Special functions,  Prev: Angular conversion,  Up: math --- Mathematical functions

5.9.2.5 Hyperbolic functions
............................

Hyperbolic functions(1) are analogs of trigonometric functions that are
based on hyperbolas instead of circles.

 -- Function: math.acosh (x)

     Return the inverse hyperbolic cosine of `x'.

 -- Function: math.asinh (x)

     Return the inverse hyperbolic sine of `x'.

 -- Function: math.atanh (x)

     Return the inverse hyperbolic tangent of `x'.

 -- Function: math.cosh (x)

     Return the hyperbolic cosine of `x'.

 -- Function: math.sinh (x)

     Return the hyperbolic sine of `x'.

 -- Function: math.tanh (x)

     Return the hyperbolic tangent of `x'.

   ---------- Footnotes ----------

   (1) https://en.wikipedia.org/wiki/Hyperbolic_function


File: python.info,  Node: Special functions,  Next: Constants,  Prev: Hyperbolic functions,  Up: math --- Mathematical functions

5.9.2.6 Special functions
.........................

 -- Function: math.erf (x)

     Return the error function(1) at `x'.

     The *note erf(): 7b5. function can be used to compute traditional
     statistical functions such as the cumulative standard normal
     distribution(2):

          def phi(x):
              'Cumulative distribution function for the standard normal distribution'
              return (1.0 + erf(x / sqrt(2.0))) / 2.0

     New in version 3.2.

 -- Function: math.erfc (x)

     Return the complementary error function at `x'.  The complementary
     error function(3) is defined as ‘1.0 - erf(x)’.  It is used for
     large values of `x' where a subtraction from one would cause a loss
     of significance(4).

     New in version 3.2.

 -- Function: math.gamma (x)

     Return the Gamma function(5) at `x'.

     New in version 3.2.

 -- Function: math.lgamma (x)

     Return the natural logarithm of the absolute value of the Gamma
     function at `x'.

     New in version 3.2.

   ---------- Footnotes ----------

   (1) https://en.wikipedia.org/wiki/Error_function

   (2) 
https://en.wikipedia.org/wiki/Normal_distribution#Cumulative_distribution_function

   (3) https://en.wikipedia.org/wiki/Error_function

   (4) https://en.wikipedia.org/wiki/Loss_of_significance

   (5) https://en.wikipedia.org/wiki/Gamma_function


File: python.info,  Node: Constants,  Prev: Special functions,  Up: math --- Mathematical functions

5.9.2.7 Constants
.................

 -- Data: math.pi

     The mathematical constant π = 3.141592..., to available precision.

 -- Data: math.e

     The mathematical constant e = 2.718281..., to available precision.

 -- Data: math.inf

     A floating-point positive infinity.  (For negative infinity, use
     ‘-math.inf’.)  Equivalent to the output of ‘float('inf')’.

     New in version 3.5.

 -- Data: math.nan

     A floating-point "not a number" (NaN) value.  Equivalent to the
     output of ‘float('nan')’.

     New in version 3.5.

`CPython implementation detail:' The *note math: b0. module consists
mostly of thin wrappers around the platform C math library functions.
Behavior in exceptional cases follows Annex F of the C99 standard where
appropriate.  The current implementation will raise *note ValueError:
19c. for invalid operations like ‘sqrt(-1.0)’ or ‘log(0.0)’ (where C99
Annex F recommends signaling invalid operation or divide-by-zero), and
*note OverflowError: 578. for results that overflow (for example,
‘exp(1000.0)’).  A NaN will not be returned from any of the functions
above unless one or more of the input arguments was a NaN; in that case,
most functions will return a NaN, but (again following C99 Annex F)
there are some exceptions to this rule, for example ‘pow(float('nan'),
0.0)’ or ‘hypot(float('nan'), float('inf'))’.

Note that Python makes no effort to distinguish signaling NaNs from
quiet NaNs, and behavior for signaling NaNs remains unspecified.
Typical behavior is to treat all NaNs as though they were quiet.

See also
........

Module *note cmath: 19.

     Complex number versions of many of these functions.


File: python.info,  Node: cmath --- Mathematical functions for complex numbers,  Next: decimal --- Decimal fixed point and floating point arithmetic,  Prev: math --- Mathematical functions,  Up: Numeric and Mathematical Modules

5.9.3 ‘cmath’ — Mathematical functions for complex numbers
----------------------------------------------------------

This module is always available.  It provides access to mathematical
functions for complex numbers.  The functions in this module accept
integers, floating-point numbers or complex numbers as arguments.  They
will also accept any Python object that has either a *note
__complex__(): 97b. or a *note __float__(): e45. method: these methods
are used to convert the object to a complex or floating-point number,
respectively, and the function is then applied to the result of the
conversion.

     Note: On platforms with hardware and system-level support for
     signed zeros, functions involving branch cuts are continuous on
     `both' sides of the branch cut: the sign of the zero distinguishes
     one side of the branch cut from the other.  On platforms that do
     not support signed zeros the continuity is as specified below.

* Menu:

* Conversions to and from polar coordinates:: 
* Power and logarithmic functions: Power and logarithmic functions<2>. 
* Trigonometric functions: Trigonometric functions<2>. 
* Hyperbolic functions: Hyperbolic functions<2>. 
* Classification functions:: 
* Constants: Constants<2>. 


File: python.info,  Node: Conversions to and from polar coordinates,  Next: Power and logarithmic functions<2>,  Up: cmath --- Mathematical functions for complex numbers

5.9.3.1 Conversions to and from polar coordinates
.................................................

A Python complex number ‘z’ is stored internally using `rectangular' or
`Cartesian' coordinates.  It is completely determined by its `real part'
‘z.real’ and its `imaginary part' ‘z.imag’.  In other words:

     z == z.real + z.imag*1j

`Polar coordinates' give an alternative way to represent a complex
number.  In polar coordinates, a complex number `z' is defined by the
modulus `r' and the phase angle `phi'.  The modulus `r' is the distance
from `z' to the origin, while the phase `phi' is the counterclockwise
angle, measured in radians, from the positive x-axis to the line segment
that joins the origin to `z'.

The following functions can be used to convert from the native
rectangular coordinates to polar coordinates and back.

 -- Function: cmath.phase (x)

     Return the phase of `x' (also known as the `argument' of `x'), as a
     float.  ‘phase(x)’ is equivalent to ‘math.atan2(x.imag, x.real)’.
     The result lies in the range [-π, π], and the branch cut for this
     operation lies along the negative real axis, continuous from above.
     On systems with support for signed zeros (which includes most
     systems in current use), this means that the sign of the result is
     the same as the sign of ‘x.imag’, even when ‘x.imag’ is zero:

          >>> phase(complex(-1.0, 0.0))
          3.141592653589793
          >>> phase(complex(-1.0, -0.0))
          -3.141592653589793

     Note: The modulus (absolute value) of a complex number `x' can be
     computed using the built-in *note abs(): c7c. function.  There is
     no separate *note cmath: 19. module function for this operation.

 -- Function: cmath.polar (x)

     Return the representation of `x' in polar coordinates.  Returns a
     pair ‘(r, phi)’ where `r' is the modulus of `x' and phi is the
     phase of `x'.  ‘polar(x)’ is equivalent to ‘(abs(x), phase(x))’.

 -- Function: cmath.rect (r, phi)

     Return the complex number `x' with polar coordinates `r' and `phi'.
     Equivalent to ‘r * (math.cos(phi) + math.sin(phi)*1j)’.


File: python.info,  Node: Power and logarithmic functions<2>,  Next: Trigonometric functions<2>,  Prev: Conversions to and from polar coordinates,  Up: cmath --- Mathematical functions for complex numbers

5.9.3.2 Power and logarithmic functions
.......................................

 -- Function: cmath.exp (x)

     Return the exponential value ‘e**x’.

 -- Function: cmath.log (x[, base])

     Returns the logarithm of `x' to the given `base'.  If the `base' is
     not specified, returns the natural logarithm of `x'.  There is one
     branch cut, from 0 along the negative real axis to -∞, continuous
     from above.

 -- Function: cmath.log10 (x)

     Return the base-10 logarithm of `x'.  This has the same branch cut
     as *note log(): 13df.

 -- Function: cmath.sqrt (x)

     Return the square root of `x'.  This has the same branch cut as
     *note log(): 13df.


File: python.info,  Node: Trigonometric functions<2>,  Next: Hyperbolic functions<2>,  Prev: Power and logarithmic functions<2>,  Up: cmath --- Mathematical functions for complex numbers

5.9.3.3 Trigonometric functions
...............................

 -- Function: cmath.acos (x)

     Return the arc cosine of `x'.  There are two branch cuts: One
     extends right from 1 along the real axis to ∞, continuous from
     below.  The other extends left from -1 along the real axis to -∞,
     continuous from above.

 -- Function: cmath.asin (x)

     Return the arc sine of `x'.  This has the same branch cuts as *note
     acos(): 13e3.

 -- Function: cmath.atan (x)

     Return the arc tangent of `x'.  There are two branch cuts: One
     extends from ‘1j’ along the imaginary axis to ‘∞j’, continuous from
     the right.  The other extends from ‘-1j’ along the imaginary axis
     to ‘-∞j’, continuous from the left.

 -- Function: cmath.cos (x)

     Return the cosine of `x'.

 -- Function: cmath.sin (x)

     Return the sine of `x'.

 -- Function: cmath.tan (x)

     Return the tangent of `x'.


File: python.info,  Node: Hyperbolic functions<2>,  Next: Classification functions,  Prev: Trigonometric functions<2>,  Up: cmath --- Mathematical functions for complex numbers

5.9.3.4 Hyperbolic functions
............................

 -- Function: cmath.acosh (x)

     Return the inverse hyperbolic cosine of `x'.  There is one branch
     cut, extending left from 1 along the real axis to -∞, continuous
     from above.

 -- Function: cmath.asinh (x)

     Return the inverse hyperbolic sine of `x'.  There are two branch
     cuts: One extends from ‘1j’ along the imaginary axis to ‘∞j’,
     continuous from the right.  The other extends from ‘-1j’ along the
     imaginary axis to ‘-∞j’, continuous from the left.

 -- Function: cmath.atanh (x)

     Return the inverse hyperbolic tangent of `x'.  There are two branch
     cuts: One extends from ‘1’ along the real axis to ‘∞’, continuous
     from below.  The other extends from ‘-1’ along the real axis to
     ‘-∞’, continuous from above.

 -- Function: cmath.cosh (x)

     Return the hyperbolic cosine of `x'.

 -- Function: cmath.sinh (x)

     Return the hyperbolic sine of `x'.

 -- Function: cmath.tanh (x)

     Return the hyperbolic tangent of `x'.


File: python.info,  Node: Classification functions,  Next: Constants<2>,  Prev: Hyperbolic functions<2>,  Up: cmath --- Mathematical functions for complex numbers

5.9.3.5 Classification functions
................................

 -- Function: cmath.isfinite (x)

     Return ‘True’ if both the real and imaginary parts of `x' are
     finite, and ‘False’ otherwise.

     New in version 3.2.

 -- Function: cmath.isinf (x)

     Return ‘True’ if either the real or the imaginary part of `x' is an
     infinity, and ‘False’ otherwise.

 -- Function: cmath.isnan (x)

     Return ‘True’ if either the real or the imaginary part of `x' is a
     NaN, and ‘False’ otherwise.

 -- Function: cmath.isclose (a, b, *, rel_tol=1e-09, abs_tol=0.0)

     Return ‘True’ if the values `a' and `b' are close to each other and
     ‘False’ otherwise.

     Whether or not two values are considered close is determined
     according to given absolute and relative tolerances.

     `rel_tol' is the relative tolerance – it is the maximum allowed
     difference between `a' and `b', relative to the larger absolute
     value of `a' or `b'.  For example, to set a tolerance of 5%, pass
     ‘rel_tol=0.05’.  The default tolerance is ‘1e-09’, which assures
     that the two values are the same within about 9 decimal digits.
     `rel_tol' must be greater than zero.

     `abs_tol' is the minimum absolute tolerance – useful for
     comparisons near zero.  `abs_tol' must be at least zero.

     If no errors occur, the result will be: ‘abs(a-b) <= max(rel_tol *
     max(abs(a), abs(b)), abs_tol)’.

     The IEEE 754 special values of ‘NaN’, ‘inf’, and ‘-inf’ will be
     handled according to IEEE rules.  Specifically, ‘NaN’ is not
     considered close to any other value, including ‘NaN’.  ‘inf’ and
     ‘-inf’ are only considered close to themselves.

     New in version 3.5.

     See also
     ........

     PEP 485(1) – A function for testing approximate equality

   ---------- Footnotes ----------

   (1) https://www.python.org/dev/peps/pep-0485


File: python.info,  Node: Constants<2>,  Prev: Classification functions,  Up: cmath --- Mathematical functions for complex numbers

5.9.3.6 Constants
.................

 -- Data: cmath.pi

     The mathematical constant `π', as a float.

 -- Data: cmath.e

     The mathematical constant `e', as a float.

Note that the selection of functions is similar, but not identical, to
that in module *note math: b0.  The reason for having two modules is
that some users aren’t interested in complex numbers, and perhaps don’t
even know what they are.  They would rather have ‘math.sqrt(-1)’ raise
an exception than return a complex number.  Also note that the functions
defined in *note cmath: 19. always return a complex number, even if the
answer can be expressed as a real number (in which case the complex
number has an imaginary part of zero).

A note on branch cuts: They are curves along which the given function
fails to be continuous.  They are a necessary feature of many complex
functions.  It is assumed that if you need to compute with complex
functions, you will understand about branch cuts.  Consult almost any
(not too elementary) book on complex variables for enlightenment.  For
information of the proper choice of branch cuts for numerical purposes,
a good reference should be the following:

See also
........

Kahan, W: Branch cuts for complex elementary functions; or, Much ado
about nothing’s sign bit.  In Iserles, A., and Powell, M. (eds.), The
state of the art in numerical analysis.  Clarendon Press (1987)
pp165-211.


File: python.info,  Node: decimal --- Decimal fixed point and floating point arithmetic,  Next: fractions --- Rational numbers,  Prev: cmath --- Mathematical functions for complex numbers,  Up: Numeric and Mathematical Modules

5.9.4 ‘decimal’ — Decimal fixed point and floating point arithmetic
-------------------------------------------------------------------

`Source code:' Lib/decimal.py(1)

The *note decimal: 34. module provides support for fast
correctly-rounded decimal floating point arithmetic.  It offers several
advantages over the *note float: 57a. datatype:

   * Decimal "is based on a floating-point model which was designed with
     people in mind, and necessarily has a paramount guiding principle –
     computers must provide an arithmetic that works in the same way as
     the arithmetic that people learn at school."  – excerpt from the
     decimal arithmetic specification.

   * Decimal numbers can be represented exactly.  In contrast, numbers
     like ‘1.1’ and ‘2.2’ do not have exact representations in binary
     floating point.  End users typically would not expect ‘1.1 + 2.2’
     to display as ‘3.3000000000000003’ as it does with binary floating
     point.

   * The exactness carries over into arithmetic.  In decimal floating
     point, ‘0.1 + 0.1 + 0.1 - 0.3’ is exactly equal to zero.  In binary
     floating point, the result is ‘5.5511151231257827e-017’.  While
     near to zero, the differences prevent reliable equality testing and
     differences can accumulate.  For this reason, decimal is preferred
     in accounting applications which have strict equality invariants.

   * The decimal module incorporates a notion of significant places so
     that ‘1.30 + 1.20’ is ‘2.50’.  The trailing zero is kept to
     indicate significance.  This is the customary presentation for
     monetary applications.  For multiplication, the "schoolbook"
     approach uses all the figures in the multiplicands.  For instance,
     ‘1.3 * 1.2’ gives ‘1.56’ while ‘1.30 * 1.20’ gives ‘1.5600’.

   * Unlike hardware based binary floating point, the decimal module has
     a user alterable precision (defaulting to 28 places) which can be
     as large as needed for a given problem:

          >>> from decimal import *
          >>> getcontext().prec = 6
          >>> Decimal(1) / Decimal(7)
          Decimal('0.142857')
          >>> getcontext().prec = 28
          >>> Decimal(1) / Decimal(7)
          Decimal('0.1428571428571428571428571429')

   * Both binary and decimal floating point are implemented in terms of
     published standards.  While the built-in float type exposes only a
     modest portion of its capabilities, the decimal module exposes all
     required parts of the standard.  When needed, the programmer has
     full control over rounding and signal handling.  This includes an
     option to enforce exact arithmetic by using exceptions to block any
     inexact operations.

   * The decimal module was designed to support "without prejudice, both
     exact unrounded decimal arithmetic (sometimes called fixed-point
     arithmetic) and rounded floating-point arithmetic."  – excerpt from
     the decimal arithmetic specification.

The module design is centered around three concepts: the decimal number,
the context for arithmetic, and signals.

A decimal number is immutable.  It has a sign, coefficient digits, and
an exponent.  To preserve significance, the coefficient digits do not
truncate trailing zeros.  Decimals also include special values such as
‘Infinity’, ‘-Infinity’, and ‘NaN’.  The standard also differentiates
‘-0’ from ‘+0’.

The context for arithmetic is an environment specifying precision,
rounding rules, limits on exponents, flags indicating the results of
operations, and trap enablers which determine whether signals are
treated as exceptions.  Rounding options include *note ROUND_CEILING:
13f9, *note ROUND_DOWN: 13fa, *note ROUND_FLOOR: 13fb, *note
ROUND_HALF_DOWN: 13fc, *note ROUND_HALF_EVEN: 13fd, *note ROUND_HALF_UP:
13fe, *note ROUND_UP: 13ff, and *note ROUND_05UP: 1400.

Signals are groups of exceptional conditions arising during the course
of computation.  Depending on the needs of the application, signals may
be ignored, considered as informational, or treated as exceptions.  The
signals in the decimal module are: *note Clamped: 1401, *note
InvalidOperation: 619, *note DivisionByZero: 1402, *note Inexact: 1403,
*note Rounded: 1404, *note Subnormal: 1405, *note Overflow: 1406, *note
Underflow: 1407. and *note FloatOperation: 612.

For each signal there is a flag and a trap enabler.  When a signal is
encountered, its flag is set to one, then, if the trap enabler is set to
one, an exception is raised.  Flags are sticky, so the user needs to
reset them before monitoring a calculation.

See also
........

   * IBM’s General Decimal Arithmetic Specification, The General Decimal
     Arithmetic Specification(2).

* Menu:

* Quick-start Tutorial:: 
* Decimal objects:: 
* Context objects:: 
* Constants: Constants<3>. 
* Rounding modes:: 
* Signals:: 
* Floating Point Notes:: 
* Working with threads:: 
* Recipes:: 
* Decimal FAQ:: 

   ---------- Footnotes ----------

   (1) https://hg.python.org/cpython/file/default/Lib/decimal.py

   (2) http://speleotrove.com/decimal/decarith.html


File: python.info,  Node: Quick-start Tutorial,  Next: Decimal objects,  Up: decimal --- Decimal fixed point and floating point arithmetic

5.9.4.1 Quick-start Tutorial
............................

The usual start to using decimals is importing the module, viewing the
current context with *note getcontext(): 140a. and, if necessary,
setting new values for precision, rounding, or enabled traps:

     >>> from decimal import *
     >>> getcontext()
     Context(prec=28, rounding=ROUND_HALF_EVEN, Emin=-999999, Emax=999999,
             capitals=1, clamp=0, flags=[], traps=[Overflow, DivisionByZero,
             InvalidOperation])

     >>> getcontext().prec = 7       # Set a new precision

Decimal instances can be constructed from integers, strings, floats, or
tuples.  Construction from an integer or a float performs an exact
conversion of the value of that integer or float.  Decimal numbers
include special values such as ‘NaN’ which stands for "Not a number",
positive and negative ‘Infinity’, and ‘-0’:

     >>> getcontext().prec = 28
     >>> Decimal(10)
     Decimal('10')
     >>> Decimal('3.14')
     Decimal('3.14')
     >>> Decimal(3.14)
     Decimal('3.140000000000000124344978758017532527446746826171875')
     >>> Decimal((0, (3, 1, 4), -2))
     Decimal('3.14')
     >>> Decimal(str(2.0 ** 0.5))
     Decimal('1.4142135623730951')
     >>> Decimal(2) ** Decimal('0.5')
     Decimal('1.414213562373095048801688724')
     >>> Decimal('NaN')
     Decimal('NaN')
     >>> Decimal('-Infinity')
     Decimal('-Infinity')

If the *note FloatOperation: 612. signal is trapped, accidental mixing
of decimals and floats in constructors or ordering comparisons raises an
exception:

     >>> c = getcontext()
     >>> c.traps[FloatOperation] = True
     >>> Decimal(3.14)
     Traceback (most recent call last):
     File "<stdin>", line 1, in <module>
     decimal.FloatOperation: [<class 'decimal.FloatOperation'>]
     >>> Decimal('3.5') < 3.7
     Traceback (most recent call last):
       File "<stdin>", line 1, in <module>
     decimal.FloatOperation: [<class 'decimal.FloatOperation'>]
     >>> Decimal('3.5') == 3.5
     True

New in version 3.3.

The significance of a new Decimal is determined solely by the number of
digits input.  Context precision and rounding only come into play during
arithmetic operations.

     >>> getcontext().prec = 6
     >>> Decimal('3.0')
     Decimal('3.0')
     >>> Decimal('3.1415926535')
     Decimal('3.1415926535')
     >>> Decimal('3.1415926535') + Decimal('2.7182818285')
     Decimal('5.85987')
     >>> getcontext().rounding = ROUND_UP
     >>> Decimal('3.1415926535') + Decimal('2.7182818285')
     Decimal('5.85988')

If the internal limits of the C version are exceeded, constructing a
decimal raises *note InvalidOperation: 619.:

     >>> Decimal("1e9999999999999999999")
     Traceback (most recent call last):
       File "<stdin>", line 1, in <module>
     decimal.InvalidOperation: [<class 'decimal.InvalidOperation'>]

Changed in version 3.3.

Decimals interact well with much of the rest of Python.  Here is a small
decimal floating point flying circus:

     >>> data = list(map(Decimal, '1.34 1.87 3.45 2.35 1.00 0.03 9.25'.split()))
     >>> max(data)
     Decimal('9.25')
     >>> min(data)
     Decimal('0.03')
     >>> sorted(data)
     [Decimal('0.03'), Decimal('1.00'), Decimal('1.34'), Decimal('1.87'),
      Decimal('2.35'), Decimal('3.45'), Decimal('9.25')]
     >>> sum(data)
     Decimal('19.29')
     >>> a,b,c = data[:3]
     >>> str(a)
     '1.34'
     >>> float(a)
     1.34
     >>> round(a, 1)
     Decimal('1.3')
     >>> int(a)
     1
     >>> a * 5
     Decimal('6.70')
     >>> a * b
     Decimal('2.5058')
     >>> c % a
     Decimal('0.77')

And some mathematical functions are also available to Decimal:

     >>> getcontext().prec = 28
     >>> Decimal(2).sqrt()
     Decimal('1.414213562373095048801688724')
     >>> Decimal(1).exp()
     Decimal('2.718281828459045235360287471')
     >>> Decimal('10').ln()
     Decimal('2.302585092994045684017991455')
     >>> Decimal('10').log10()
     Decimal('1')

The ‘quantize()’ method rounds a number to a fixed exponent.  This
method is useful for monetary applications that often round results to a
fixed number of places:

     >>> Decimal('7.325').quantize(Decimal('.01'), rounding=ROUND_DOWN)
     Decimal('7.32')
     >>> Decimal('7.325').quantize(Decimal('1.'), rounding=ROUND_UP)
     Decimal('8')

As shown above, the *note getcontext(): 140a. function accesses the
current context and allows the settings to be changed.  This approach
meets the needs of most applications.

For more advanced work, it may be useful to create alternate contexts
using the Context() constructor.  To make an alternate active, use the
*note setcontext(): 140b. function.

In accordance with the standard, the *note decimal: 34. module provides
two ready to use standard contexts, *note BasicContext: 616. and *note
ExtendedContext: 617.  The former is especially useful for debugging
because many of the traps are enabled:

     >>> myothercontext = Context(prec=60, rounding=ROUND_HALF_DOWN)
     >>> setcontext(myothercontext)
     >>> Decimal(1) / Decimal(7)
     Decimal('0.142857142857142857142857142857142857142857142857142857142857')

     >>> ExtendedContext
     Context(prec=9, rounding=ROUND_HALF_EVEN, Emin=-999999, Emax=999999,
             capitals=1, clamp=0, flags=[], traps=[])
     >>> setcontext(ExtendedContext)
     >>> Decimal(1) / Decimal(7)
     Decimal('0.142857143')
     >>> Decimal(42) / Decimal(0)
     Decimal('Infinity')

     >>> setcontext(BasicContext)
     >>> Decimal(42) / Decimal(0)
     Traceback (most recent call last):
       File "<pyshell#143>", line 1, in -toplevel-
         Decimal(42) / Decimal(0)
     DivisionByZero: x / 0

Contexts also have signal flags for monitoring exceptional conditions
encountered during computations.  The flags remain set until explicitly
cleared, so it is best to clear the flags before each set of monitored
computations by using the ‘clear_flags()’ method.

     >>> setcontext(ExtendedContext)
     >>> getcontext().clear_flags()
     >>> Decimal(355) / Decimal(113)
     Decimal('3.14159292')
     >>> getcontext()
     Context(prec=9, rounding=ROUND_HALF_EVEN, Emin=-999999, Emax=999999,
             capitals=1, clamp=0, flags=[Inexact, Rounded], traps=[])

The `flags' entry shows that the rational approximation to ‘Pi’ was
rounded (digits beyond the context precision were thrown away) and that
the result is inexact (some of the discarded digits were non-zero).

Individual traps are set using the dictionary in the ‘traps’ field of a
context:

     >>> setcontext(ExtendedContext)
     >>> Decimal(1) / Decimal(0)
     Decimal('Infinity')
     >>> getcontext().traps[DivisionByZero] = 1
     >>> Decimal(1) / Decimal(0)
     Traceback (most recent call last):
       File "<pyshell#112>", line 1, in -toplevel-
         Decimal(1) / Decimal(0)
     DivisionByZero: x / 0

Most programs adjust the current context only once, at the beginning of
the program.  And, in many applications, data is converted to *note
Decimal: 618. with a single cast inside a loop.  With context set and
decimals created, the bulk of the program manipulates the data no
differently than with other Python numeric types.


File: python.info,  Node: Decimal objects,  Next: Context objects,  Prev: Quick-start Tutorial,  Up: decimal --- Decimal fixed point and floating point arithmetic

5.9.4.2 Decimal objects
.......................

 -- Class: decimal.Decimal (value="0", context=None)

     Construct a new *note Decimal: 618. object based from `value'.

     `value' can be an integer, string, tuple, *note float: 57a, or
     another *note Decimal: 618. object.  If no `value' is given,
     returns ‘Decimal('0')’.  If `value' is a string, it should conform
     to the decimal numeric string syntax after leading and trailing
     whitespace characters are removed:

          sign           ::=  '+' | '-'
          digit          ::=  '0' | '1' | '2' | '3' | '4' | '5' | '6' | '7' | '8' | '9'
          indicator      ::=  'e' | 'E'
          digits         ::=  digit [digit]...
          decimal-part   ::=  digits '.' [digits] | ['.'] digits
          exponent-part  ::=  indicator [sign] digits
          infinity       ::=  'Infinity' | 'Inf'
          nan            ::=  'NaN' [digits] | 'sNaN' [digits]
          numeric-value  ::=  decimal-part [exponent-part] | infinity
          numeric-string ::=  [sign] numeric-value | [sign] nan

     Other Unicode decimal digits are also permitted where ‘digit’
     appears above.  These include decimal digits from various other
     alphabets (for example, Arabic-Indic and Devanāgarī digits) along
     with the fullwidth digits ‘'\uff10'’ through ‘'\uff19'’.

     If `value' is a *note tuple: 25c, it should have three components,
     a sign (‘0’ for positive or ‘1’ for negative), a *note tuple: 25c.
     of digits, and an integer exponent.  For example, ‘Decimal((0, (1,
     4, 1, 4), -3))’ returns ‘Decimal('1.414')’.

     If `value' is a *note float: 57a, the binary floating point value
     is losslessly converted to its exact decimal equivalent.  This
     conversion can often require 53 or more digits of precision.  For
     example, ‘Decimal(float('1.1'))’ converts to
     ‘Decimal('1.100000000000000088817841970012523233890533447265625')’.

     The `context' precision does not affect how many digits are stored.
     That is determined exclusively by the number of digits in `value'.
     For example, ‘Decimal('3.00000')’ records all five zeros even if
     the context precision is only three.

     The purpose of the `context' argument is determining what to do if
     `value' is a malformed string.  If the context traps *note
     InvalidOperation: 619, an exception is raised; otherwise, the
     constructor returns a new Decimal with the value of ‘NaN’.

     Once constructed, *note Decimal: 618. objects are immutable.

     Changed in version 3.2: The argument to the constructor is now
     permitted to be a *note float: 57a. instance.

     Changed in version 3.3: *note float: 57a. arguments raise an
     exception if the *note FloatOperation: 612. trap is set.  By
     default the trap is off.

     Decimal floating point objects share many properties with the other
     built-in numeric types such as *note float: 57a. and *note int:
     227.  All of the usual math operations and special methods apply.
     Likewise, decimal objects can be copied, pickled, printed, used as
     dictionary keys, used as set elements, compared, sorted, and
     coerced to another type (such as *note float: 57a. or *note int:
     227.).

     There are some small differences between arithmetic on Decimal
     objects and arithmetic on integers and floats.  When the remainder
     operator ‘%’ is applied to Decimal objects, the sign of the result
     is the sign of the `dividend' rather than the sign of the divisor:

          >>> (-7) % 4
          1
          >>> Decimal(-7) % Decimal(4)
          Decimal('-3')

     The integer division operator ‘//’ behaves analogously, returning
     the integer part of the true quotient (truncating towards zero)
     rather than its floor, so as to preserve the usual identity ‘x ==
     (x // y) * y + x % y’:

          >>> -7 // 4
          -2
          >>> Decimal(-7) // Decimal(4)
          Decimal('-1')

     The ‘%’ and ‘//’ operators implement the ‘remainder’ and
     ‘divide-integer’ operations (respectively) as described in the
     specification.

     Decimal objects cannot generally be combined with floats or
     instances of *note fractions.Fraction: 378. in arithmetic
     operations: an attempt to add a *note Decimal: 618. to a *note
     float: 57a, for example, will raise a *note TypeError: 562.
     However, it is possible to use Python’s comparison operators to
     compare a *note Decimal: 618. instance ‘x’ with another number ‘y’.
     This avoids confusing results when doing equality comparisons
     between numbers of different types.

     Changed in version 3.2: Mixed-type comparisons between *note
     Decimal: 618. instances and other numeric types are now fully
     supported.

     In addition to the standard numeric properties, decimal floating
     point objects also have a number of specialized methods:

      -- Method: adjusted ()

          Return the adjusted exponent after shifting out the
          coefficient’s rightmost digits until only the lead digit
          remains: ‘Decimal('321e+5').adjusted()’ returns seven.  Used
          for determining the position of the most significant digit
          with respect to the decimal point.

      -- Method: as_integer_ratio ()

          Return a pair ‘(n, d)’ of integers that represent the given
          *note Decimal: 618. instance as a fraction, in lowest terms
          and with a positive denominator:

               >>> Decimal('-3.14').as_integer_ratio()
               (-157, 50)

          The conversion is exact.  Raise OverflowError on infinities
          and ValueError on NaNs.

     New in version 3.6.

      -- Method: as_tuple ()

          Return a *note named tuple: 787. representation of the number:
          ‘DecimalTuple(sign, digits, exponent)’.

      -- Method: canonical ()

          Return the canonical encoding of the argument.  Currently, the
          encoding of a *note Decimal: 618. instance is always
          canonical, so this operation returns its argument unchanged.

      -- Method: compare (other, context=None)

          Compare the values of two Decimal instances.  *note compare():
          1412. returns a Decimal instance, and if either operand is a
          NaN then the result is a NaN:

               a or b is a NaN  ==> Decimal('NaN')
               a < b            ==> Decimal('-1')
               a == b           ==> Decimal('0')
               a > b            ==> Decimal('1')

      -- Method: compare_signal (other, context=None)

          This operation is identical to the *note compare(): 1412.
          method, except that all NaNs signal.  That is, if neither
          operand is a signaling NaN then any quiet NaN operand is
          treated as though it were a signaling NaN.

      -- Method: compare_total (other, context=None)

          Compare two operands using their abstract representation
          rather than their numerical value.  Similar to the *note
          compare(): 1412. method, but the result gives a total ordering
          on *note Decimal: 618. instances.  Two *note Decimal: 618.
          instances with the same numeric value but different
          representations compare unequal in this ordering:

               >>> Decimal('12.0').compare_total(Decimal('12'))
               Decimal('-1')

          Quiet and signaling NaNs are also included in the total
          ordering.  The result of this function is ‘Decimal('0')’ if
          both operands have the same representation, ‘Decimal('-1')’ if
          the first operand is lower in the total order than the second,
          and ‘Decimal('1')’ if the first operand is higher in the total
          order than the second operand.  See the specification for
          details of the total order.

          This operation is unaffected by context and is quiet: no flags
          are changed and no rounding is performed.  As an exception,
          the C version may raise InvalidOperation if the second operand
          cannot be converted exactly.

      -- Method: compare_total_mag (other, context=None)

          Compare two operands using their abstract representation
          rather than their value as in *note compare_total(): 1414, but
          ignoring the sign of each operand.  ‘x.compare_total_mag(y)’
          is equivalent to ‘x.copy_abs().compare_total(y.copy_abs())’.

          This operation is unaffected by context and is quiet: no flags
          are changed and no rounding is performed.  As an exception,
          the C version may raise InvalidOperation if the second operand
          cannot be converted exactly.

      -- Method: conjugate ()

          Just returns self, this method is only to comply with the
          Decimal Specification.

      -- Method: copy_abs ()

          Return the absolute value of the argument.  This operation is
          unaffected by the context and is quiet: no flags are changed
          and no rounding is performed.

      -- Method: copy_negate ()

          Return the negation of the argument.  This operation is
          unaffected by the context and is quiet: no flags are changed
          and no rounding is performed.

      -- Method: copy_sign (other, context=None)

          Return a copy of the first operand with the sign set to be the
          same as the sign of the second operand.  For example:

               >>> Decimal('2.3').copy_sign(Decimal('-1.5'))
               Decimal('-2.3')

          This operation is unaffected by context and is quiet: no flags
          are changed and no rounding is performed.  As an exception,
          the C version may raise InvalidOperation if the second operand
          cannot be converted exactly.

      -- Method: exp (context=None)

          Return the value of the (natural) exponential function ‘e**x’
          at the given number.  The result is correctly rounded using
          the *note ROUND_HALF_EVEN: 13fd. rounding mode.

               >>> Decimal(1).exp()
               Decimal('2.718281828459045235360287471')
               >>> Decimal(321).exp()
               Decimal('2.561702493119680037517373933E+139')

      -- Method: from_float (f)

          Classmethod that converts a float to a decimal number,
          exactly.

          Note ‘Decimal.from_float(0.1)’ is not the same as
          ‘Decimal(’0.1’)’.  Since 0.1 is not exactly representable in
          binary floating point, the value is stored as the nearest
          representable value which is ‘0x1.999999999999ap-4’.  That
          equivalent value in decimal is
          ‘0.1000000000000000055511151231257827021181583404541015625’.

               Note: From Python 3.2 onwards, a *note Decimal: 618.
               instance can also be constructed directly from a *note
               float: 57a.

               >>> Decimal.from_float(0.1)
               Decimal('0.1000000000000000055511151231257827021181583404541015625')
               >>> Decimal.from_float(float('nan'))
               Decimal('NaN')
               >>> Decimal.from_float(float('inf'))
               Decimal('Infinity')
               >>> Decimal.from_float(float('-inf'))
               Decimal('-Infinity')

          New in version 3.1.

      -- Method: fma (other, third, context=None)

          Fused multiply-add.  Return self*other+third with no rounding
          of the intermediate product self*other.

               >>> Decimal(2).fma(3, 5)
               Decimal('11')

      -- Method: is_canonical ()

          Return *note True: 9ff. if the argument is canonical and *note
          False: 60d. otherwise.  Currently, a *note Decimal: 618.
          instance is always canonical, so this operation always returns
          *note True: 9ff.

      -- Method: is_finite ()

          Return *note True: 9ff. if the argument is a finite number,
          and *note False: 60d. if the argument is an infinity or a NaN.

      -- Method: is_infinite ()

          Return *note True: 9ff. if the argument is either positive or
          negative infinity and *note False: 60d. otherwise.

      -- Method: is_nan ()

          Return *note True: 9ff. if the argument is a (quiet or
          signaling) NaN and *note False: 60d. otherwise.

      -- Method: is_normal (context=None)

          Return *note True: 9ff. if the argument is a `normal' finite
          number.  Return *note False: 60d. if the argument is zero,
          subnormal, infinite or a NaN.

      -- Method: is_qnan ()

          Return *note True: 9ff. if the argument is a quiet NaN, and
          *note False: 60d. otherwise.

      -- Method: is_signed ()

          Return *note True: 9ff. if the argument has a negative sign
          and *note False: 60d. otherwise.  Note that zeros and NaNs can
          both carry signs.

      -- Method: is_snan ()

          Return *note True: 9ff. if the argument is a signaling NaN and
          *note False: 60d. otherwise.

      -- Method: is_subnormal (context=None)

          Return *note True: 9ff. if the argument is subnormal, and
          *note False: 60d. otherwise.

      -- Method: is_zero ()

          Return *note True: 9ff. if the argument is a (positive or
          negative) zero and *note False: 60d. otherwise.

      -- Method: ln (context=None)

          Return the natural (base e) logarithm of the operand.  The
          result is correctly rounded using the *note ROUND_HALF_EVEN:
          13fd. rounding mode.

      -- Method: log10 (context=None)

          Return the base ten logarithm of the operand.  The result is
          correctly rounded using the *note ROUND_HALF_EVEN: 13fd.
          rounding mode.

      -- Method: logb (context=None)

          For a nonzero number, return the adjusted exponent of its
          operand as a *note Decimal: 618. instance.  If the operand is
          a zero then ‘Decimal('-Infinity')’ is returned and the *note
          DivisionByZero: 1402. flag is raised.  If the operand is an
          infinity then ‘Decimal('Infinity')’ is returned.

      -- Method: logical_and (other, context=None)

          *note logical_and(): 1427. is a logical operation which takes
          two `logical operands' (see *note Logical operands: 1428.).
          The result is the digit-wise ‘and’ of the two operands.

      -- Method: logical_invert (context=None)

          *note logical_invert(): 1429. is a logical operation.  The
          result is the digit-wise inversion of the operand.

      -- Method: logical_or (other, context=None)

          *note logical_or(): 142a. is a logical operation which takes
          two `logical operands' (see *note Logical operands: 1428.).
          The result is the digit-wise ‘or’ of the two operands.

      -- Method: logical_xor (other, context=None)

          *note logical_xor(): 142b. is a logical operation which takes
          two `logical operands' (see *note Logical operands: 1428.).
          The result is the digit-wise exclusive or of the two operands.

      -- Method: max (other, context=None)

          Like ‘max(self, other)’ except that the context rounding rule
          is applied before returning and that ‘NaN’ values are either
          signaled or ignored (depending on the context and whether they
          are signaling or quiet).

      -- Method: max_mag (other, context=None)

          Similar to the *note max(): 142c. method, but the comparison
          is done using the absolute values of the operands.

      -- Method: min (other, context=None)

          Like ‘min(self, other)’ except that the context rounding rule
          is applied before returning and that ‘NaN’ values are either
          signaled or ignored (depending on the context and whether they
          are signaling or quiet).

      -- Method: min_mag (other, context=None)

          Similar to the *note min(): 142e. method, but the comparison
          is done using the absolute values of the operands.

      -- Method: next_minus (context=None)

          Return the largest number representable in the given context
          (or in the current thread’s context if no context is given)
          that is smaller than the given operand.

      -- Method: next_plus (context=None)

          Return the smallest number representable in the given context
          (or in the current thread’s context if no context is given)
          that is larger than the given operand.

      -- Method: next_toward (other, context=None)

          If the two operands are unequal, return the number closest to
          the first operand in the direction of the second operand.  If
          both operands are numerically equal, return a copy of the
          first operand with the sign set to be the same as the sign of
          the second operand.

      -- Method: normalize (context=None)

          Normalize the number by stripping the rightmost trailing zeros
          and converting any result equal to ‘Decimal('0')’ to
          ‘Decimal('0e0')’.  Used for producing canonical values for
          attributes of an equivalence class.  For example,
          ‘Decimal('32.100')’ and ‘Decimal('0.321000e+2')’ both
          normalize to the equivalent value ‘Decimal('32.1')’.

      -- Method: number_class (context=None)

          Return a string describing the `class' of the operand.  The
          returned value is one of the following ten strings.

             * ‘"-Infinity"’, indicating that the operand is negative
               infinity.

             * ‘"-Normal"’, indicating that the operand is a negative
               normal number.

             * ‘"-Subnormal"’, indicating that the operand is negative
               and subnormal.

             * ‘"-Zero"’, indicating that the operand is a negative
               zero.

             * ‘"+Zero"’, indicating that the operand is a positive
               zero.

             * ‘"+Subnormal"’, indicating that the operand is positive
               and subnormal.

             * ‘"+Normal"’, indicating that the operand is a positive
               normal number.

             * ‘"+Infinity"’, indicating that the operand is positive
               infinity.

             * ‘"NaN"’, indicating that the operand is a quiet NaN (Not
               a Number).

             * ‘"sNaN"’, indicating that the operand is a signaling NaN.

      -- Method: quantize (exp, rounding=None, context=None)

          Return a value equal to the first operand after rounding and
          having the exponent of the second operand.

               >>> Decimal('1.41421356').quantize(Decimal('1.000'))
               Decimal('1.414')

          Unlike other operations, if the length of the coefficient
          after the quantize operation would be greater than precision,
          then an *note InvalidOperation: 619. is signaled.  This
          guarantees that, unless there is an error condition, the
          quantized exponent is always equal to that of the right-hand
          operand.

          Also unlike other operations, quantize never signals
          Underflow, even if the result is subnormal and inexact.

          If the exponent of the second operand is larger than that of
          the first then rounding may be necessary.  In this case, the
          rounding mode is determined by the ‘rounding’ argument if
          given, else by the given ‘context’ argument; if neither
          argument is given the rounding mode of the current thread’s
          context is used.

          An error is returned whenever the resulting exponent is
          greater than ‘Emax’ or less than ‘Etiny’.

      -- Method: radix ()

          Return ‘Decimal(10)’, the radix (base) in which the *note
          Decimal: 618. class does all its arithmetic.  Included for
          compatibility with the specification.

      -- Method: remainder_near (other, context=None)

          Return the remainder from dividing `self' by `other'.  This
          differs from ‘self % other’ in that the sign of the remainder
          is chosen so as to minimize its absolute value.  More
          precisely, the return value is ‘self - n * other’ where ‘n’ is
          the integer nearest to the exact value of ‘self / other’, and
          if two integers are equally near then the even one is chosen.

          If the result is zero then its sign will be the sign of
          `self'.

               >>> Decimal(18).remainder_near(Decimal(10))
               Decimal('-2')
               >>> Decimal(25).remainder_near(Decimal(10))
               Decimal('5')
               >>> Decimal(35).remainder_near(Decimal(10))
               Decimal('-5')

      -- Method: rotate (other, context=None)

          Return the result of rotating the digits of the first operand
          by an amount specified by the second operand.  The second
          operand must be an integer in the range -precision through
          precision.  The absolute value of the second operand gives the
          number of places to rotate.  If the second operand is positive
          then rotation is to the left; otherwise rotation is to the
          right.  The coefficient of the first operand is padded on the
          left with zeros to length precision if necessary.  The sign
          and exponent of the first operand are unchanged.

      -- Method: same_quantum (other, context=None)

          Test whether self and other have the same exponent or whether
          both are ‘NaN’.

          This operation is unaffected by context and is quiet: no flags
          are changed and no rounding is performed.  As an exception,
          the C version may raise InvalidOperation if the second operand
          cannot be converted exactly.

      -- Method: scaleb (other, context=None)

          Return the first operand with exponent adjusted by the second.
          Equivalently, return the first operand multiplied by
          ‘10**other’.  The second operand must be an integer.

      -- Method: shift (other, context=None)

          Return the result of shifting the digits of the first operand
          by an amount specified by the second operand.  The second
          operand must be an integer in the range -precision through
          precision.  The absolute value of the second operand gives the
          number of places to shift.  If the second operand is positive
          then the shift is to the left; otherwise the shift is to the
          right.  Digits shifted into the coefficient are zeros.  The
          sign and exponent of the first operand are unchanged.

      -- Method: sqrt (context=None)

          Return the square root of the argument to full precision.

      -- Method: to_eng_string (context=None)

          Convert to an engineering-type string.

          Engineering notation has an exponent which is a multiple of 3,
          so there are up to 3 digits left of the decimal place.  For
          example, converts ‘Decimal('123E+1')’ to ‘Decimal('1.23E+3')’.

      -- Method: to_integral (rounding=None, context=None)

          Identical to the *note to_integral_value(): 143e. method.  The
          ‘to_integral’ name has been kept for compatibility with older
          versions.

      -- Method: to_integral_exact (rounding=None, context=None)

          Round to the nearest integer, signaling *note Inexact: 1403.
          or *note Rounded: 1404. as appropriate if rounding occurs.
          The rounding mode is determined by the ‘rounding’ parameter if
          given, else by the given ‘context’.  If neither parameter is
          given then the rounding mode of the current context is used.

      -- Method: to_integral_value (rounding=None, context=None)

          Round to the nearest integer without signaling *note Inexact:
          1403. or *note Rounded: 1404.  If given, applies `rounding';
          otherwise, uses the rounding method in either the supplied
          `context' or the current context.

* Menu:

* Logical operands:: 


File: python.info,  Node: Logical operands,  Up: Decimal objects

5.9.4.3 Logical operands
........................

The ‘logical_and()’, ‘logical_invert()’, ‘logical_or()’, and
‘logical_xor()’ methods expect their arguments to be `logical operands'.
A `logical operand' is a *note Decimal: 618. instance whose exponent and
sign are both zero, and whose digits are all either ‘0’ or ‘1’.


File: python.info,  Node: Context objects,  Next: Constants<3>,  Prev: Decimal objects,  Up: decimal --- Decimal fixed point and floating point arithmetic

5.9.4.4 Context objects
.......................

Contexts are environments for arithmetic operations.  They govern
precision, set rules for rounding, determine which signals are treated
as exceptions, and limit the range for exponents.

Each thread has its own current context which is accessed or changed
using the *note getcontext(): 140a. and *note setcontext(): 140b.
functions:

 -- Function: decimal.getcontext ()

     Return the current context for the active thread.

 -- Function: decimal.setcontext (c)

     Set the current context for the active thread to `c'.

You can also use the *note with: 29d. statement and the *note
localcontext(): 1091. function to temporarily change the active context.

 -- Function: decimal.localcontext (ctx=None)

     Return a context manager that will set the current context for the
     active thread to a copy of `ctx' on entry to the with-statement and
     restore the previous context when exiting the with-statement.  If
     no context is specified, a copy of the current context is used.

     For example, the following code sets the current decimal precision
     to 42 places, performs a calculation, and then automatically
     restores the previous context:

          from decimal import localcontext

          with localcontext() as ctx:
              ctx.prec = 42   # Perform a high precision calculation
              s = calculate_something()
          s = +s  # Round the final result back to the default precision

New contexts can also be created using the *note Context: 61e.
constructor described below.  In addition, the module provides three
pre-made contexts:

 -- Class: decimal.BasicContext

     This is a standard context defined by the General Decimal
     Arithmetic Specification.  Precision is set to nine.  Rounding is
     set to *note ROUND_HALF_UP: 13fe.  All flags are cleared.  All
     traps are enabled (treated as exceptions) except *note Inexact:
     1403, *note Rounded: 1404, and *note Subnormal: 1405.

     Because many of the traps are enabled, this context is useful for
     debugging.

 -- Class: decimal.ExtendedContext

     This is a standard context defined by the General Decimal
     Arithmetic Specification.  Precision is set to nine.  Rounding is
     set to *note ROUND_HALF_EVEN: 13fd.  All flags are cleared.  No
     traps are enabled (so that exceptions are not raised during
     computations).

     Because the traps are disabled, this context is useful for
     applications that prefer to have result value of ‘NaN’ or
     ‘Infinity’ instead of raising exceptions.  This allows an
     application to complete a run in the presence of conditions that
     would otherwise halt the program.

 -- Class: decimal.DefaultContext

     This context is used by the *note Context: 61e. constructor as a
     prototype for new contexts.  Changing a field (such a precision)
     has the effect of changing the default for new contexts created by
     the *note Context: 61e. constructor.

     This context is most useful in multi-threaded environments.
     Changing one of the fields before threads are started has the
     effect of setting system-wide defaults.  Changing the fields after
     threads have started is not recommended as it would require thread
     synchronization to prevent race conditions.

     In single threaded environments, it is preferable to not use this
     context at all.  Instead, simply create contexts explicitly as
     described below.

     The default values are ‘prec’=‘28’, ‘rounding’=*note
     ROUND_HALF_EVEN: 13fd, and enabled traps for *note Overflow: 1406,
     *note InvalidOperation: 619, and *note DivisionByZero: 1402.

In addition to the three supplied contexts, new contexts can be created
with the *note Context: 61e. constructor.

 -- Class: decimal.Context (prec=None, rounding=None, Emin=None,
          Emax=None, capitals=None, clamp=None, flags=None, traps=None)

     Creates a new context.  If a field is not specified or is *note
     None: 19d, the default values are copied from the *note
     DefaultContext: 615.  If the `flags' field is not specified or is
     *note None: 19d, all flags are cleared.

     `prec' is an integer in the range [‘1’, *note MAX_PREC: 1443.] that
     sets the precision for arithmetic operations in the context.

     The `rounding' option is one of the constants listed in the section
     *note Rounding Modes: 1444.

     The `traps' and `flags' fields list any signals to be set.
     Generally, new contexts should only set traps and leave the flags
     clear.

     The `Emin' and `Emax' fields are integers specifying the outer
     limits allowable for exponents.  `Emin' must be in the range [*note
     MIN_EMIN: 1445, ‘0’], `Emax' in the range [‘0’, *note MAX_EMAX:
     1446.].

     The `capitals' field is either ‘0’ or ‘1’ (the default).  If set to
     ‘1’, exponents are printed with a capital ‘E’; otherwise, a
     lowercase ‘e’ is used: ‘Decimal('6.02e+23')’.

     The `clamp' field is either ‘0’ (the default) or ‘1’.  If set to
     ‘1’, the exponent ‘e’ of a *note Decimal: 618. instance
     representable in this context is strictly limited to the range
     ‘Emin - prec + 1 <= e <= Emax - prec + 1’.  If `clamp' is ‘0’ then
     a weaker condition holds: the adjusted exponent of the *note
     Decimal: 618. instance is at most ‘Emax’.  When `clamp' is ‘1’, a
     large normal number will, where possible, have its exponent reduced
     and a corresponding number of zeros added to its coefficient, in
     order to fit the exponent constraints; this preserves the value of
     the number but loses information about significant trailing zeros.
     For example:

          >>> Context(prec=6, Emax=999, clamp=1).create_decimal('1.23e999')
          Decimal('1.23000E+999')

     A `clamp' value of ‘1’ allows compatibility with the fixed-width
     decimal interchange formats specified in IEEE 754.

     The *note Context: 61e. class defines several general purpose
     methods as well as a large number of methods for doing arithmetic
     directly in a given context.  In addition, for each of the *note
     Decimal: 618. methods described above (with the exception of the
     ‘adjusted()’ and ‘as_tuple()’ methods) there is a corresponding
     *note Context: 61e. method.  For example, for a *note Context: 61e.
     instance ‘C’ and *note Decimal: 618. instance ‘x’, ‘C.exp(x)’ is
     equivalent to ‘x.exp(context=C)’.  Each *note Context: 61e. method
     accepts a Python integer (an instance of *note int: 227.) anywhere
     that a Decimal instance is accepted.

      -- Method: clear_flags ()

          Resets all of the flags to ‘0’.

      -- Method: clear_traps ()

          Resets all of the traps to ‘0’.

          New in version 3.3.

      -- Method: copy ()

          Return a duplicate of the context.

      -- Method: copy_decimal (num)

          Return a copy of the Decimal instance num.

      -- Method: create_decimal (num)

          Creates a new Decimal instance from `num' but using `self' as
          context.  Unlike the *note Decimal: 618. constructor, the
          context precision, rounding method, flags, and traps are
          applied to the conversion.

          This is useful because constants are often given to a greater
          precision than is needed by the application.  Another benefit
          is that rounding immediately eliminates unintended effects
          from digits beyond the current precision.  In the following
          example, using unrounded inputs means that adding zero to a
          sum can change the result:

               >>> getcontext().prec = 3
               >>> Decimal('3.4445') + Decimal('1.0023')
               Decimal('4.45')
               >>> Decimal('3.4445') + Decimal(0) + Decimal('1.0023')
               Decimal('4.44')

          This method implements the to-number operation of the IBM
          specification.  If the argument is a string, no leading or
          trailing whitespace is permitted.

      -- Method: create_decimal_from_float (f)

          Creates a new Decimal instance from a float `f' but rounding
          using `self' as the context.  Unlike the *note
          Decimal.from_float(): 7d0. class method, the context
          precision, rounding method, flags, and traps are applied to
          the conversion.

               >>> context = Context(prec=5, rounding=ROUND_DOWN)
               >>> context.create_decimal_from_float(math.pi)
               Decimal('3.1415')
               >>> context = Context(prec=5, traps=[Inexact])
               >>> context.create_decimal_from_float(math.pi)
               Traceback (most recent call last):
                   ...
               decimal.Inexact: None

          New in version 3.1.

      -- Method: Etiny ()

          Returns a value equal to ‘Emin - prec + 1’ which is the
          minimum exponent value for subnormal results.  When underflow
          occurs, the exponent is set to *note Etiny: 144c.

      -- Method: Etop ()

          Returns a value equal to ‘Emax - prec + 1’.

     The usual approach to working with decimals is to create *note
     Decimal: 618. instances and then apply arithmetic operations which
     take place within the current context for the active thread.  An
     alternative approach is to use context methods for calculating
     within a specific context.  The methods are similar to those for
     the *note Decimal: 618. class and are only briefly recounted here.

      -- Method: abs (x)

          Returns the absolute value of `x'.

      -- Method: add (x, y)

          Return the sum of `x' and `y'.

      -- Method: canonical (x)

          Returns the same Decimal object `x'.

      -- Method: compare (x, y)

          Compares `x' and `y' numerically.

      -- Method: compare_signal (x, y)

          Compares the values of the two operands numerically.

      -- Method: compare_total (x, y)

          Compares two operands using their abstract representation.

      -- Method: compare_total_mag (x, y)

          Compares two operands using their abstract representation,
          ignoring sign.

      -- Method: copy_abs (x)

          Returns a copy of `x' with the sign set to 0.

      -- Method: copy_negate (x)

          Returns a copy of `x' with the sign inverted.

      -- Method: copy_sign (x, y)

          Copies the sign from `y' to `x'.

      -- Method: divide (x, y)

          Return `x' divided by `y'.

      -- Method: divide_int (x, y)

          Return `x' divided by `y', truncated to an integer.

      -- Method: divmod (x, y)

          Divides two numbers and returns the integer part of the
          result.

      -- Method: exp (x)

          Returns ‘e ** x’.

      -- Method: fma (x, y, z)

          Returns `x' multiplied by `y', plus `z'.

      -- Method: is_canonical (x)

          Returns ‘True’ if `x' is canonical; otherwise returns ‘False’.

      -- Method: is_finite (x)

          Returns ‘True’ if `x' is finite; otherwise returns ‘False’.

      -- Method: is_infinite (x)

          Returns ‘True’ if `x' is infinite; otherwise returns ‘False’.

      -- Method: is_nan (x)

          Returns ‘True’ if `x' is a qNaN or sNaN; otherwise returns
          ‘False’.

      -- Method: is_normal (x)

          Returns ‘True’ if `x' is a normal number; otherwise returns
          ‘False’.

      -- Method: is_qnan (x)

          Returns ‘True’ if `x' is a quiet NaN; otherwise returns
          ‘False’.

      -- Method: is_signed (x)

          Returns ‘True’ if `x' is negative; otherwise returns ‘False’.

      -- Method: is_snan (x)

          Returns ‘True’ if `x' is a signaling NaN; otherwise returns
          ‘False’.

      -- Method: is_subnormal (x)

          Returns ‘True’ if `x' is subnormal; otherwise returns ‘False’.

      -- Method: is_zero (x)

          Returns ‘True’ if `x' is a zero; otherwise returns ‘False’.

      -- Method: ln (x)

          Returns the natural (base e) logarithm of `x'.

      -- Method: log10 (x)

          Returns the base 10 logarithm of `x'.

      -- Method: logb (x)

          Returns the exponent of the magnitude of the operand’s MSD.

      -- Method: logical_and (x, y)

          Applies the logical operation `and' between each operand’s
          digits.

      -- Method: logical_invert (x)

          Invert all the digits in `x'.

      -- Method: logical_or (x, y)

          Applies the logical operation `or' between each operand’s
          digits.

      -- Method: logical_xor (x, y)

          Applies the logical operation `xor' between each operand’s
          digits.

      -- Method: max (x, y)

          Compares two values numerically and returns the maximum.

      -- Method: max_mag (x, y)

          Compares the values numerically with their sign ignored.

      -- Method: min (x, y)

          Compares two values numerically and returns the minimum.

      -- Method: min_mag (x, y)

          Compares the values numerically with their sign ignored.

      -- Method: minus (x)

          Minus corresponds to the unary prefix minus operator in
          Python.

      -- Method: multiply (x, y)

          Return the product of `x' and `y'.

      -- Method: next_minus (x)

          Returns the largest representable number smaller than `x'.

      -- Method: next_plus (x)

          Returns the smallest representable number larger than `x'.

      -- Method: next_toward (x, y)

          Returns the number closest to `x', in direction towards `y'.

      -- Method: normalize (x)

          Reduces `x' to its simplest form.

      -- Method: number_class (x)

          Returns an indication of the class of `x'.

      -- Method: plus (x)

          Plus corresponds to the unary prefix plus operator in Python.
          This operation applies the context precision and rounding, so
          it is `not' an identity operation.

      -- Method: power (x, y, modulo=None)

          Return ‘x’ to the power of ‘y’, reduced modulo ‘modulo’ if
          given.

          With two arguments, compute ‘x**y’.  If ‘x’ is negative then
          ‘y’ must be integral.  The result will be inexact unless ‘y’
          is integral and the result is finite and can be expressed
          exactly in ’precision’ digits.  The rounding mode of the
          context is used.  Results are always correctly-rounded in the
          Python version.

          Changed in version 3.3: The C module computes *note power():
          1478. in terms of the correctly-rounded *note exp(): 145a. and
          *note ln(): 1465. functions.  The result is well-defined but
          only "almost always correctly-rounded".

          With three arguments, compute ‘(x**y) % modulo’.  For the
          three argument form, the following restrictions on the
          arguments hold:

                  - all three arguments must be integral

                  - ‘y’ must be nonnegative

                  - at least one of ‘x’ or ‘y’ must be nonzero

                  - ‘modulo’ must be nonzero and have at most
                    ’precision’ digits

          The value resulting from ‘Context.power(x, y, modulo)’ is
          equal to the value that would be obtained by computing ‘(x**y)
          % modulo’ with unbounded precision, but is computed more
          efficiently.  The exponent of the result is zero, regardless
          of the exponents of ‘x’, ‘y’ and ‘modulo’.  The result is
          always exact.

      -- Method: quantize (x, y)

          Returns a value equal to `x' (rounded), having the exponent of
          `y'.

      -- Method: radix ()

          Just returns 10, as this is Decimal, :)

      -- Method: remainder (x, y)

          Returns the remainder from integer division.

          The sign of the result, if non-zero, is the same as that of
          the original dividend.

      -- Method: remainder_near (x, y)

          Returns ‘x - y * n’, where `n' is the integer nearest the
          exact value of ‘x / y’ (if the result is 0 then its sign will
          be the sign of `x').

      -- Method: rotate (x, y)

          Returns a rotated copy of `x', `y' times.

      -- Method: same_quantum (x, y)

          Returns ‘True’ if the two operands have the same exponent.

      -- Method: scaleb (x, y)

          Returns the first operand after adding the second value its
          exp.

      -- Method: shift (x, y)

          Returns a shifted copy of `x', `y' times.

      -- Method: sqrt (x)

          Square root of a non-negative number to context precision.

      -- Method: subtract (x, y)

          Return the difference between `x' and `y'.

      -- Method: to_eng_string (x)

          Converts a number to a string, using scientific notation.

      -- Method: to_integral_exact (x)

          Rounds to an integer.

      -- Method: to_sci_string (x)

          Converts a number to a string using scientific notation.


File: python.info,  Node: Constants<3>,  Next: Rounding modes,  Prev: Context objects,  Up: decimal --- Decimal fixed point and floating point arithmetic

5.9.4.5 Constants
.................

The constants in this section are only relevant for the C module.  They
are also included in the pure Python version for compatibility.

                          32-bit                    64-bit
                                                    
----------------------------------------------------------------------------------------
                                                    
 -- Data:                 ‘425000000’               ‘999999999999999999’
          decimal.MAX_PREC                          

 -- Data:                 ‘425000000’               ‘999999999999999999’
          decimal.MAX_EMAX                          

 -- Data:                 ‘-425000000’              ‘-999999999999999999’
          decimal.MIN_EMIN                          

 -- Data:                 ‘-849999999’              ‘-1999999999999999997’
          decimal.MIN_ETINY                         

 -- Data: decimal.HAVE_THREADS

     The default value is ‘True’.  If Python is compiled without
     threads, the C version automatically disables the expensive thread
     local context machinery.  In this case, the value is ‘False’.


File: python.info,  Node: Rounding modes,  Next: Signals,  Prev: Constants<3>,  Up: decimal --- Decimal fixed point and floating point arithmetic

5.9.4.6 Rounding modes
......................

 -- Data: decimal.ROUND_CEILING

     Round towards ‘Infinity’.

 -- Data: decimal.ROUND_DOWN

     Round towards zero.

 -- Data: decimal.ROUND_FLOOR

     Round towards ‘-Infinity’.

 -- Data: decimal.ROUND_HALF_DOWN

     Round to nearest with ties going towards zero.

 -- Data: decimal.ROUND_HALF_EVEN

     Round to nearest with ties going to nearest even integer.

 -- Data: decimal.ROUND_HALF_UP

     Round to nearest with ties going away from zero.

 -- Data: decimal.ROUND_UP

     Round away from zero.

 -- Data: decimal.ROUND_05UP

     Round away from zero if last digit after rounding towards zero
     would have been 0 or 5; otherwise round towards zero.


File: python.info,  Node: Signals,  Next: Floating Point Notes,  Prev: Rounding modes,  Up: decimal --- Decimal fixed point and floating point arithmetic

5.9.4.7 Signals
...............

Signals represent conditions that arise during computation.  Each
corresponds to one context flag and one context trap enabler.

The context flag is set whenever the condition is encountered.  After
the computation, flags may be checked for informational purposes (for
instance, to determine whether a computation was exact).  After checking
the flags, be sure to clear all flags before starting the next
computation.

If the context’s trap enabler is set for the signal, then the condition
causes a Python exception to be raised.  For example, if the *note
DivisionByZero: 1402. trap is set, then a *note DivisionByZero: 1402.
exception is raised upon encountering the condition.

 -- Class: decimal.Clamped

     Altered an exponent to fit representation constraints.

     Typically, clamping occurs when an exponent falls outside the
     context’s ‘Emin’ and ‘Emax’ limits.  If possible, the exponent is
     reduced to fit by adding zeros to the coefficient.

 -- Class: decimal.DecimalException

     Base class for other signals and a subclass of *note
     ArithmeticError: 10b3.

 -- Class: decimal.DivisionByZero

     Signals the division of a non-infinite number by zero.

     Can occur with division, modulo division, or when raising a number
     to a negative power.  If this signal is not trapped, returns
     ‘Infinity’ or ‘-Infinity’ with the sign determined by the inputs to
     the calculation.

 -- Class: decimal.Inexact

     Indicates that rounding occurred and the result is not exact.

     Signals when non-zero digits were discarded during rounding.  The
     rounded result is returned.  The signal flag or trap is used to
     detect when results are inexact.

 -- Class: decimal.InvalidOperation

     An invalid operation was performed.

     Indicates that an operation was requested that does not make sense.
     If not trapped, returns ‘NaN’.  Possible causes include:

          Infinity - Infinity
          0 * Infinity
          Infinity / Infinity
          x % 0
          Infinity % x
          sqrt(-x) and x > 0
          0 ** 0
          x ** (non-integer)
          x ** Infinity

 -- Class: decimal.Overflow

     Numerical overflow.

     Indicates the exponent is larger than ‘Emax’ after rounding has
     occurred.  If not trapped, the result depends on the rounding mode,
     either pulling inward to the largest representable finite number or
     rounding outward to ‘Infinity’.  In either case, *note Inexact:
     1403. and *note Rounded: 1404. are also signaled.

 -- Class: decimal.Rounded

     Rounding occurred though possibly no information was lost.

     Signaled whenever rounding discards digits; even if those digits
     are zero (such as rounding ‘5.00’ to ‘5.0’).  If not trapped,
     returns the result unchanged.  This signal is used to detect loss
     of significant digits.

 -- Class: decimal.Subnormal

     Exponent was lower than ‘Emin’ prior to rounding.

     Occurs when an operation result is subnormal (the exponent is too
     small).  If not trapped, returns the result unchanged.

 -- Class: decimal.Underflow

     Numerical underflow with result rounded to zero.

     Occurs when a subnormal result is pushed to zero by rounding.
     *note Inexact: 1403. and *note Subnormal: 1405. are also signaled.

 -- Class: decimal.FloatOperation

     Enable stricter semantics for mixing floats and Decimals.

     If the signal is not trapped (default), mixing floats and Decimals
     is permitted in the *note Decimal: 618. constructor, *note
     create_decimal(): 61a. and all comparison operators.  Both
     conversion and comparisons are exact.  Any occurrence of a mixed
     operation is silently recorded by setting *note FloatOperation:
     612. in the context flags.  Explicit conversions with *note
     from_float(): 7d0. or *note create_decimal_from_float(): 144b. do
     not set the flag.

     Otherwise (the signal is trapped), only equality comparisons and
     explicit conversions are silent.  All other mixed operations raise
     *note FloatOperation: 612.

The following table summarizes the hierarchy of signals:

     exceptions.ArithmeticError(exceptions.Exception)
         DecimalException
             Clamped
             DivisionByZero(DecimalException, exceptions.ZeroDivisionError)
             Inexact
                 Overflow(Inexact, Rounded)
                 Underflow(Inexact, Rounded, Subnormal)
             InvalidOperation
             Rounded
             Subnormal
             FloatOperation(DecimalException, exceptions.TypeError)


File: python.info,  Node: Floating Point Notes,  Next: Working with threads,  Prev: Signals,  Up: decimal --- Decimal fixed point and floating point arithmetic

5.9.4.8 Floating Point Notes
............................

* Menu:

* Mitigating round-off error with increased precision:: 
* Special values:: 


File: python.info,  Node: Mitigating round-off error with increased precision,  Next: Special values,  Up: Floating Point Notes

5.9.4.9 Mitigating round-off error with increased precision
...........................................................

The use of decimal floating point eliminates decimal representation
error (making it possible to represent ‘0.1’ exactly); however, some
operations can still incur round-off error when non-zero digits exceed
the fixed precision.

The effects of round-off error can be amplified by the addition or
subtraction of nearly offsetting quantities resulting in loss of
significance.  Knuth provides two instructive examples where rounded
floating point arithmetic with insufficient precision causes the
breakdown of the associative and distributive properties of addition:

     # Examples from Seminumerical Algorithms, Section 4.2.2.
     >>> from decimal import Decimal, getcontext
     >>> getcontext().prec = 8

     >>> u, v, w = Decimal(11111113), Decimal(-11111111), Decimal('7.51111111')
     >>> (u + v) + w
     Decimal('9.5111111')
     >>> u + (v + w)
     Decimal('10')

     >>> u, v, w = Decimal(20000), Decimal(-6), Decimal('6.0000003')
     >>> (u*v) + (u*w)
     Decimal('0.01')
     >>> u * (v+w)
     Decimal('0.0060000')

The *note decimal: 34. module makes it possible to restore the
identities by expanding the precision sufficiently to avoid loss of
significance:

     >>> getcontext().prec = 20
     >>> u, v, w = Decimal(11111113), Decimal(-11111111), Decimal('7.51111111')
     >>> (u + v) + w
     Decimal('9.51111111')
     >>> u + (v + w)
     Decimal('9.51111111')
     >>>
     >>> u, v, w = Decimal(20000), Decimal(-6), Decimal('6.0000003')
     >>> (u*v) + (u*w)
     Decimal('0.0060000')
     >>> u * (v+w)
     Decimal('0.0060000')


File: python.info,  Node: Special values,  Prev: Mitigating round-off error with increased precision,  Up: Floating Point Notes

5.9.4.10 Special values
.......................

The number system for the *note decimal: 34. module provides special
values including ‘NaN’, ‘sNaN’, ‘-Infinity’, ‘Infinity’, and two zeros,
‘+0’ and ‘-0’.

Infinities can be constructed directly with: ‘Decimal('Infinity')’.
Also, they can arise from dividing by zero when the *note
DivisionByZero: 1402. signal is not trapped.  Likewise, when the *note
Overflow: 1406. signal is not trapped, infinity can result from rounding
beyond the limits of the largest representable number.

The infinities are signed (affine) and can be used in arithmetic
operations where they get treated as very large, indeterminate numbers.
For instance, adding a constant to infinity gives another infinite
result.

Some operations are indeterminate and return ‘NaN’, or if the *note
InvalidOperation: 619. signal is trapped, raise an exception.  For
example, ‘0/0’ returns ‘NaN’ which means "not a number".  This variety
of ‘NaN’ is quiet and, once created, will flow through other
computations always resulting in another ‘NaN’.  This behavior can be
useful for a series of computations that occasionally have missing
inputs — it allows the calculation to proceed while flagging specific
results as invalid.

A variant is ‘sNaN’ which signals rather than remaining quiet after
every operation.  This is a useful return value when an invalid result
needs to interrupt a calculation for special handling.

The behavior of Python’s comparison operators can be a little surprising
where a ‘NaN’ is involved.  A test for equality where one of the
operands is a quiet or signaling ‘NaN’ always returns *note False: 60d.
(even when doing ‘Decimal('NaN')==Decimal('NaN')’), while a test for
inequality always returns *note True: 9ff.  An attempt to compare two
Decimals using any of the ‘<’, ‘<=’, ‘>’ or ‘>=’ operators will raise
the *note InvalidOperation: 619. signal if either operand is a ‘NaN’,
and return *note False: 60d. if this signal is not trapped.  Note that
the General Decimal Arithmetic specification does not specify the
behavior of direct comparisons; these rules for comparisons involving a
‘NaN’ were taken from the IEEE 854 standard (see Table 3 in section
5.7).  To ensure strict standards-compliance, use the ‘compare()’ and
‘compare-signal()’ methods instead.

The signed zeros can result from calculations that underflow.  They keep
the sign that would have resulted if the calculation had been carried
out to greater precision.  Since their magnitude is zero, both positive
and negative zeros are treated as equal and their sign is informational.

In addition to the two signed zeros which are distinct yet equal, there
are various representations of zero with differing precisions yet
equivalent in value.  This takes a bit of getting used to.  For an eye
accustomed to normalized floating point representations, it is not
immediately obvious that the following calculation returns a value equal
to zero:

     >>> 1 / Decimal('Infinity')
     Decimal('0E-1000026')


File: python.info,  Node: Working with threads,  Next: Recipes,  Prev: Floating Point Notes,  Up: decimal --- Decimal fixed point and floating point arithmetic

5.9.4.11 Working with threads
.............................

The *note getcontext(): 140a. function accesses a different *note
Context: 61e. object for each thread.  Having separate thread contexts
means that threads may make changes (such as ‘getcontext().prec=10’)
without interfering with other threads.

Likewise, the *note setcontext(): 140b. function automatically assigns
its target to the current thread.

If *note setcontext(): 140b. has not been called before *note
getcontext(): 140a, then *note getcontext(): 140a. will automatically
create a new context for use in the current thread.

The new context is copied from a prototype context called
`DefaultContext'.  To control the defaults so that each thread will use
the same values throughout the application, directly modify the
`DefaultContext' object.  This should be done `before' any threads are
started so that there won’t be a race condition between threads calling
*note getcontext(): 140a.  For example:

     # Set applicationwide defaults for all threads about to be launched
     DefaultContext.prec = 12
     DefaultContext.rounding = ROUND_DOWN
     DefaultContext.traps = ExtendedContext.traps.copy()
     DefaultContext.traps[InvalidOperation] = 1
     setcontext(DefaultContext)

     # Afterwards, the threads can be started
     t1.start()
     t2.start()
     t3.start()
      . . .


File: python.info,  Node: Recipes,  Next: Decimal FAQ,  Prev: Working with threads,  Up: decimal --- Decimal fixed point and floating point arithmetic

5.9.4.12 Recipes
................

Here are a few recipes that serve as utility functions and that
demonstrate ways to work with the *note Decimal: 618. class:

     def moneyfmt(value, places=2, curr='', sep=',', dp='.',
                  pos='', neg='-', trailneg=''):
         """Convert Decimal to a money formatted string.

         places:  required number of places after the decimal point
         curr:    optional currency symbol before the sign (may be blank)
         sep:     optional grouping separator (comma, period, space, or blank)
         dp:      decimal point indicator (comma or period)
                  only specify as blank when places is zero
         pos:     optional sign for positive numbers: '+', space or blank
         neg:     optional sign for negative numbers: '-', '(', space or blank
         trailneg:optional trailing minus indicator:  '-', ')', space or blank

         >>> d = Decimal('-1234567.8901')
         >>> moneyfmt(d, curr='$')
         '-$1,234,567.89'
         >>> moneyfmt(d, places=0, sep='.', dp='', neg='', trailneg='-')
         '1.234.568-'
         >>> moneyfmt(d, curr='$', neg='(', trailneg=')')
         '($1,234,567.89)'
         >>> moneyfmt(Decimal(123456789), sep=' ')
         '123 456 789.00'
         >>> moneyfmt(Decimal('-0.02'), neg='<', trailneg='>')
         '<0.02>'

         """
         q = Decimal(10) ** -places      # 2 places --> '0.01'
         sign, digits, exp = value.quantize(q).as_tuple()
         result = []
         digits = list(map(str, digits))
         build, next = result.append, digits.pop
         if sign:
             build(trailneg)
         for i in range(places):
             build(next() if digits else '0')
         if places:
             build(dp)
         if not digits:
             build('0')
         i = 0
         while digits:
             build(next())
             i += 1
             if i == 3 and digits:
                 i = 0
                 build(sep)
         build(curr)
         build(neg if sign else pos)
         return ''.join(reversed(result))

     def pi():
         """Compute Pi to the current precision.

         >>> print(pi())
         3.141592653589793238462643383

         """
         getcontext().prec += 2  # extra digits for intermediate steps
         three = Decimal(3)      # substitute "three=3.0" for regular floats
         lasts, t, s, n, na, d, da = 0, three, 3, 1, 0, 0, 24
         while s != lasts:
             lasts = s
             n, na = n+na, na+8
             d, da = d+da, da+32
             t = (t * n) / d
             s += t
         getcontext().prec -= 2
         return +s               # unary plus applies the new precision

     def exp(x):
         """Return e raised to the power of x.  Result type matches input type.

         >>> print(exp(Decimal(1)))
         2.718281828459045235360287471
         >>> print(exp(Decimal(2)))
         7.389056098930650227230427461
         >>> print(exp(2.0))
         7.38905609893
         >>> print(exp(2+0j))
         (7.38905609893+0j)

         """
         getcontext().prec += 2
         i, lasts, s, fact, num = 0, 0, 1, 1, 1
         while s != lasts:
             lasts = s
             i += 1
             fact *= i
             num *= x
             s += num / fact
         getcontext().prec -= 2
         return +s

     def cos(x):
         """Return the cosine of x as measured in radians.

         The Taylor series approximation works best for a small value of x.
         For larger values, first compute x = x % (2 * pi).

         >>> print(cos(Decimal('0.5')))
         0.8775825618903727161162815826
         >>> print(cos(0.5))
         0.87758256189
         >>> print(cos(0.5+0j))
         (0.87758256189+0j)

         """
         getcontext().prec += 2
         i, lasts, s, fact, num, sign = 0, 0, 1, 1, 1, 1
         while s != lasts:
             lasts = s
             i += 2
             fact *= i * (i-1)
             num *= x * x
             sign *= -1
             s += num / fact * sign
         getcontext().prec -= 2
         return +s

     def sin(x):
         """Return the sine of x as measured in radians.

         The Taylor series approximation works best for a small value of x.
         For larger values, first compute x = x % (2 * pi).

         >>> print(sin(Decimal('0.5')))
         0.4794255386042030002732879352
         >>> print(sin(0.5))
         0.479425538604
         >>> print(sin(0.5+0j))
         (0.479425538604+0j)

         """
         getcontext().prec += 2
         i, lasts, s, fact, num, sign = 1, 0, x, 1, x, 1
         while s != lasts:
             lasts = s
             i += 2
             fact *= i * (i-1)
             num *= x * x
             sign *= -1
             s += num / fact * sign
         getcontext().prec -= 2
         return +s


File: python.info,  Node: Decimal FAQ,  Prev: Recipes,  Up: decimal --- Decimal fixed point and floating point arithmetic

5.9.4.13 Decimal FAQ
....................

Q. It is cumbersome to type ‘decimal.Decimal('1234.5')’.  Is there a way
to minimize typing when using the interactive interpreter?

A. Some users abbreviate the constructor to just a single letter:

     >>> D = decimal.Decimal
     >>> D('1.23') + D('3.45')
     Decimal('4.68')

Q. In a fixed-point application with two decimal places, some inputs
have many places and need to be rounded.  Others are not supposed to
have excess digits and need to be validated.  What methods should be
used?

A. The ‘quantize()’ method rounds to a fixed number of decimal places.
If the *note Inexact: 1403. trap is set, it is also useful for
validation:

     >>> TWOPLACES = Decimal(10) ** -2       # same as Decimal('0.01')

     >>> # Round to two places
     >>> Decimal('3.214').quantize(TWOPLACES)
     Decimal('3.21')

     >>> # Validate that a number does not exceed two places
     >>> Decimal('3.21').quantize(TWOPLACES, context=Context(traps=[Inexact]))
     Decimal('3.21')

     >>> Decimal('3.214').quantize(TWOPLACES, context=Context(traps=[Inexact]))
     Traceback (most recent call last):
        ...
     Inexact: None

Q. Once I have valid two place inputs, how do I maintain that invariant
throughout an application?

A. Some operations like addition, subtraction, and multiplication by an
integer will automatically preserve fixed point.  Others operations,
like division and non-integer multiplication, will change the number of
decimal places and need to be followed-up with a ‘quantize()’ step:

     >>> a = Decimal('102.72')           # Initial fixed-point values
     >>> b = Decimal('3.17')
     >>> a + b                           # Addition preserves fixed-point
     Decimal('105.89')
     >>> a - b
     Decimal('99.55')
     >>> a * 42                          # So does integer multiplication
     Decimal('4314.24')
     >>> (a * b).quantize(TWOPLACES)     # Must quantize non-integer multiplication
     Decimal('325.62')
     >>> (b / a).quantize(TWOPLACES)     # And quantize division
     Decimal('0.03')

In developing fixed-point applications, it is convenient to define
functions to handle the ‘quantize()’ step:

     >>> def mul(x, y, fp=TWOPLACES):
     ...     return (x * y).quantize(fp)
     >>> def div(x, y, fp=TWOPLACES):
     ...     return (x / y).quantize(fp)

     >>> mul(a, b)                       # Automatically preserve fixed-point
     Decimal('325.62')
     >>> div(b, a)
     Decimal('0.03')

Q. There are many ways to express the same value.  The numbers ‘200’,
‘200.000’, ‘2E2’, and ‘02E+4’ all have the same value at various
precisions.  Is there a way to transform them to a single recognizable
canonical value?

A. The ‘normalize()’ method maps all equivalent values to a single
representative:

     >>> values = map(Decimal, '200 200.000 2E2 .02E+4'.split())
     >>> [v.normalize() for v in values]
     [Decimal('2E+2'), Decimal('2E+2'), Decimal('2E+2'), Decimal('2E+2')]

Q. Some decimal values always print with exponential notation.  Is there
a way to get a non-exponential representation?

A. For some values, exponential notation is the only way to express the
number of significant places in the coefficient.  For example,
expressing ‘5.0E+3’ as ‘5000’ keeps the value constant but cannot show
the original’s two-place significance.

If an application does not care about tracking significance, it is easy
to remove the exponent and trailing zeroes, losing significance, but
keeping the value unchanged:

     >>> def remove_exponent(d):
     ...     return d.quantize(Decimal(1)) if d == d.to_integral() else d.normalize()

     >>> remove_exponent(Decimal('5E+3'))
     Decimal('5000')

Q. Is there a way to convert a regular float to a *note Decimal: 618.?

A. Yes, any binary floating point number can be exactly expressed as a
Decimal though an exact conversion may take more precision than
intuition would suggest:

     >>> Decimal(math.pi)
     Decimal('3.141592653589793115997963468544185161590576171875')

Q. Within a complex calculation, how can I make sure that I haven’t
gotten a spurious result because of insufficient precision or rounding
anomalies.

A. The decimal module makes it easy to test results.  A best practice is
to re-run calculations using greater precision and with various rounding
modes.  Widely differing results indicate insufficient precision,
rounding mode issues, ill-conditioned inputs, or a numerically unstable
algorithm.

Q. I noticed that context precision is applied to the results of
operations but not to the inputs.  Is there anything to watch out for
when mixing values of different precisions?

A. Yes.  The principle is that all values are considered to be exact and
so is the arithmetic on those values.  Only the results are rounded.
The advantage for inputs is that "what you type is what you get".  A
disadvantage is that the results can look odd if you forget that the
inputs haven’t been rounded:

     >>> getcontext().prec = 3
     >>> Decimal('3.104') + Decimal('2.104')
     Decimal('5.21')
     >>> Decimal('3.104') + Decimal('0.000') + Decimal('2.104')
     Decimal('5.20')

The solution is either to increase precision or to force rounding of
inputs using the unary plus operation:

     >>> getcontext().prec = 3
     >>> +Decimal('1.23456789')      # unary plus triggers rounding
     Decimal('1.23')

Alternatively, inputs can be rounded upon creation using the *note
Context.create_decimal(): 61a. method:

     >>> Context(prec=5, rounding=ROUND_DOWN).create_decimal('1.2345678')
     Decimal('1.2345')


File: python.info,  Node: fractions --- Rational numbers,  Next: random --- Generate pseudo-random numbers,  Prev: decimal --- Decimal fixed point and floating point arithmetic,  Up: Numeric and Mathematical Modules

5.9.5 ‘fractions’ — Rational numbers
------------------------------------

`Source code:' Lib/fractions.py(1)

__________________________________________________________________

The *note fractions: 82. module provides support for rational number
arithmetic.

A Fraction instance can be constructed from a pair of integers, from
another rational number, or from a string.

 -- Class: fractions.Fraction (numerator=0, denominator=1)

 -- Class: fractions.Fraction (other_fraction)

 -- Class: fractions.Fraction (float)

 -- Class: fractions.Fraction (decimal)

 -- Class: fractions.Fraction (string)

     The first version requires that `numerator' and `denominator' are
     instances of *note numbers.Rational: 8c1. and returns a new *note
     Fraction: 378. instance with value ‘numerator/denominator’.  If
     `denominator' is ‘0’, it raises a *note ZeroDivisionError: c6a.
     The second version requires that `other_fraction' is an instance of
     *note numbers.Rational: 8c1. and returns a *note Fraction: 378.
     instance with the same value.  The next two versions accept either
     a *note float: 57a. or a *note decimal.Decimal: 618. instance, and
     return a *note Fraction: 378. instance with exactly the same value.
     Note that due to the usual issues with binary floating-point (see
     *note Floating Point Arithmetic; Issues and Limitations: ce3.), the
     argument to ‘Fraction(1.1)’ is not exactly equal to 11/10, and so
     ‘Fraction(1.1)’ does `not' return ‘Fraction(11, 10)’ as one might
     expect.  (But see the documentation for the *note
     limit_denominator(): 1498. method below.)  The last version of the
     constructor expects a string or unicode instance.  The usual form
     for this instance is:

          [sign] numerator ['/' denominator]

     where the optional ‘sign’ may be either ’+’ or ’-’ and ‘numerator’
     and ‘denominator’ (if present) are strings of decimal digits.  In
     addition, any string that represents a finite value and is accepted
     by the *note float: 57a. constructor is also accepted by the *note
     Fraction: 378. constructor.  In either form the input string may
     also have leading and/or trailing whitespace.  Here are some
     examples:

          >>> from fractions import Fraction
          >>> Fraction(16, -10)
          Fraction(-8, 5)
          >>> Fraction(123)
          Fraction(123, 1)
          >>> Fraction()
          Fraction(0, 1)
          >>> Fraction('3/7')
          Fraction(3, 7)
          >>> Fraction(' -3/7 ')
          Fraction(-3, 7)
          >>> Fraction('1.414213 \t\n')
          Fraction(1414213, 1000000)
          >>> Fraction('-.125')
          Fraction(-1, 8)
          >>> Fraction('7e-6')
          Fraction(7, 1000000)
          >>> Fraction(2.25)
          Fraction(9, 4)
          >>> Fraction(1.1)
          Fraction(2476979795053773, 2251799813685248)
          >>> from decimal import Decimal
          >>> Fraction(Decimal('1.1'))
          Fraction(11, 10)

     The *note Fraction: 378. class inherits from the abstract base
     class *note numbers.Rational: 8c1, and implements all of the
     methods and operations from that class.  *note Fraction: 378.
     instances are hashable, and should be treated as immutable.  In
     addition, *note Fraction: 378. has the following properties and
     methods:

     Changed in version 3.2: The *note Fraction: 378. constructor now
     accepts *note float: 57a. and *note decimal.Decimal: 618.
     instances.

      -- Attribute: numerator

          Numerator of the Fraction in lowest term.

      -- Attribute: denominator

          Denominator of the Fraction in lowest term.

      -- Method: from_float (flt)

          This class method constructs a *note Fraction: 378.
          representing the exact value of `flt', which must be a *note
          float: 57a.  Beware that ‘Fraction.from_float(0.3)’ is not the
          same value as ‘Fraction(3, 10)’.

               Note: From Python 3.2 onwards, you can also construct a
               *note Fraction: 378. instance directly from a *note
               float: 57a.

      -- Method: from_decimal (dec)

          This class method constructs a *note Fraction: 378.
          representing the exact value of `dec', which must be a *note
          decimal.Decimal: 618. instance.

               Note: From Python 3.2 onwards, you can also construct a
               *note Fraction: 378. instance directly from a *note
               decimal.Decimal: 618. instance.

      -- Method: limit_denominator (max_denominator=1000000)

          Finds and returns the closest *note Fraction: 378. to ‘self’
          that has denominator at most max_denominator.  This method is
          useful for finding rational approximations to a given
          floating-point number:

               >>> from fractions import Fraction
               >>> Fraction('3.1415926535897932').limit_denominator(1000)
               Fraction(355, 113)

          or for recovering a rational number that’s represented as a
          float:

               >>> from math import pi, cos
               >>> Fraction(cos(pi/3))
               Fraction(4503599627370497, 9007199254740992)
               >>> Fraction(cos(pi/3)).limit_denominator()
               Fraction(1, 2)
               >>> Fraction(1.1).limit_denominator()
               Fraction(11, 10)

      -- Method: __floor__ ()

          Returns the greatest *note int: 227. ‘<= self’.  This method
          can also be accessed through the *note math.floor(): 9a0.
          function:

               >>> from math import floor
               >>> floor(Fraction(355, 113))
               3

      -- Method: __ceil__ ()

          Returns the least *note int: 227. ‘>= self’.  This method can
          also be accessed through the *note math.ceil(): 9a1. function.

      -- Method: __round__ ()

      -- Method: __round__ (ndigits)

          The first version returns the nearest *note int: 227. to
          ‘self’, rounding half to even.  The second version rounds
          ‘self’ to the nearest multiple of ‘Fraction(1, 10**ndigits)’
          (logically, if ‘ndigits’ is negative), again rounding half
          toward even.  This method can also be accessed through the
          *note round(): 8d9. function.

 -- Function: fractions.gcd (a, b)

     Return the greatest common divisor of the integers `a' and `b'.  If
     either `a' or `b' is nonzero, then the absolute value of ‘gcd(a,
     b)’ is the largest integer that divides both `a' and `b'.
     ‘gcd(a,b)’ has the same sign as `b' if `b' is nonzero; otherwise it
     takes the sign of `a'.  ‘gcd(0, 0)’ returns ‘0’.

     Deprecated since version 3.5: Use *note math.gcd(): 2d2. instead.

See also
........

Module *note numbers: bf.

     The abstract base classes making up the numeric tower.

   ---------- Footnotes ----------

   (1) https://hg.python.org/cpython/file/default/Lib/fractions.py


File: python.info,  Node: random --- Generate pseudo-random numbers,  Next: statistics --- Mathematical statistics functions,  Prev: fractions --- Rational numbers,  Up: Numeric and Mathematical Modules

5.9.6 ‘random’ — Generate pseudo-random numbers
-----------------------------------------------

`Source code:' Lib/random.py(1)

__________________________________________________________________

This module implements pseudo-random number generators for various
distributions.

For integers, there is uniform selection from a range.  For sequences,
there is uniform selection of a random element, a function to generate a
random permutation of a list in-place, and a function for random
sampling without replacement.

On the real line, there are functions to compute uniform, normal
(Gaussian), lognormal, negative exponential, gamma, and beta
distributions.  For generating distributions of angles, the von Mises
distribution is available.

Almost all module functions depend on the basic function *note random():
14a0, which generates a random float uniformly in the semi-open range
[0.0, 1.0).  Python uses the Mersenne Twister as the core generator.  It
produces 53-bit precision floats and has a period of 2**19937-1.  The
underlying implementation in C is both fast and threadsafe.  The
Mersenne Twister is one of the most extensively tested random number
generators in existence.  However, being completely deterministic, it is
not suitable for all purposes, and is completely unsuitable for
cryptographic purposes.

The functions supplied by this module are actually bound methods of a
hidden instance of the ‘random.Random’ class.  You can instantiate your
own instances of ‘Random’ to get generators that don’t share state.

Class ‘Random’ can also be subclassed if you want to use a different
basic generator of your own devising: in that case, override the
‘random()’, ‘seed()’, ‘getstate()’, and ‘setstate()’ methods.
Optionally, a new generator can supply a ‘getrandbits()’ method — this
allows *note randrange(): 819. to produce selections over an arbitrarily
large range.

The *note random: da. module also provides the *note SystemRandom: 14a1.
class which uses the system function *note os.urandom(): 2df. to
generate random numbers from sources provided by the operating system.

     Warning: The pseudo-random generators of this module should not be
     used for security purposes.  For security or cryptographic uses,
     see the *note secrets: e2. module.

Bookkeeping functions:

 -- Function: random.seed (a=None, version=2)

     Initialize the random number generator.

     If `a' is omitted or ‘None’, the current system time is used.  If
     randomness sources are provided by the operating system, they are
     used instead of the system time (see the *note os.urandom(): 2df.
     function for details on availability).

     If `a' is an int, it is used directly.

     With version 2 (the default), a *note str: 25a, *note bytes: 1db,
     or *note bytearray: 1dc. object gets converted to an *note int:
     227. and all of its bits are used.  With version 1, the *note
     hash(): 5e6. of `a' is used instead.

     Changed in version 3.2: Moved to the version 2 scheme which uses
     all of the bits in a string seed.

 -- Function: random.getstate ()

     Return an object capturing the current internal state of the
     generator.  This object can be passed to *note setstate(): 14a3. to
     restore the state.

 -- Function: random.setstate (state)

     `state' should have been obtained from a previous call to *note
     getstate(): 14a2, and *note setstate(): 14a3. restores the internal
     state of the generator to what it was at the time *note getstate():
     14a2. was called.

 -- Function: random.getrandbits (k)

     Returns a Python integer with `k' random bits.  This method is
     supplied with the MersenneTwister generator and some other
     generators may also provide it as an optional part of the API. When
     available, *note getrandbits(): 53b. enables *note randrange():
     819. to handle arbitrarily large ranges.

Functions for integers:

 -- Function: random.randrange (stop)

 -- Function: random.randrange (start, stop[, step])

     Return a randomly selected element from ‘range(start, stop, step)’.
     This is equivalent to ‘choice(range(start, stop, step))’, but
     doesn’t actually build a range object.

     The positional argument pattern matches that of *note range(): 5e0.
     Keyword arguments should not be used because the function may use
     them in unexpected ways.

     Changed in version 3.2: *note randrange(): 819. is more
     sophisticated about producing equally distributed values.  Formerly
     it used a style like ‘int(random()*n)’ which could produce slightly
     uneven distributions.

 -- Function: random.randint (a, b)

     Return a random integer `N' such that ‘a <= N <= b’.  Alias for
     ‘randrange(a, b+1)’.

Functions for sequences:

 -- Function: random.choice (seq)

     Return a random element from the non-empty sequence `seq'.  If
     `seq' is empty, raises *note IndexError: afb.

 -- Function: random.shuffle (x[, random])

     Shuffle the sequence `x' in place.  The optional argument `random'
     is a 0-argument function returning a random float in [0.0, 1.0); by
     default, this is the function *note random(): 14a0.

     Note that for even rather small ‘len(x)’, the total number of
     permutations of `x' is larger than the period of most random number
     generators; this implies that most permutations of a long sequence
     can never be generated.

 -- Function: random.sample (population, k)

     Return a `k' length list of unique elements chosen from the
     population sequence or set.  Used for random sampling without
     replacement.

     Returns a new list containing elements from the population while
     leaving the original population unchanged.  The resulting list is
     in selection order so that all sub-slices will also be valid random
     samples.  This allows raffle winners (the sample) to be partitioned
     into grand prize and second place winners (the subslices).

     Members of the population need not be *note hashable: de9. or
     unique.  If the population contains repeats, then each occurrence
     is a possible selection in the sample.

     To choose a sample from a range of integers, use an *note range():
     5e0. object as an argument.  This is especially fast and space
     efficient for sampling from a large population:
     ‘sample(range(10000000), 60)’.

     If the sample size is larger than the population size, a *note
     ValueError: 19c. is raised.

The following functions generate specific real-valued distributions.
Function parameters are named after the corresponding variables in the
distribution’s equation, as used in common mathematical practice; most
of these equations can be found in any statistics text.

 -- Function: random.random ()

     Return the next random floating point number in the range [0.0,
     1.0).

 -- Function: random.uniform (a, b)

     Return a random floating point number `N' such that ‘a <= N <= b’
     for ‘a <= b’ and ‘b <= N <= a’ for ‘b < a’.

     The end-point value ‘b’ may or may not be included in the range
     depending on floating-point rounding in the equation ‘a + (b-a) *
     random()’.

 -- Function: random.triangular (low, high, mode)

     Return a random floating point number `N' such that ‘low <= N <=
     high’ and with the specified `mode' between those bounds.  The
     `low' and `high' bounds default to zero and one.  The `mode'
     argument defaults to the midpoint between the bounds, giving a
     symmetric distribution.

 -- Function: random.betavariate (alpha, beta)

     Beta distribution.  Conditions on the parameters are ‘alpha > 0’
     and ‘beta > 0’.  Returned values range between 0 and 1.

 -- Function: random.expovariate (lambd)

     Exponential distribution.  `lambd' is 1.0 divided by the desired
     mean.  It should be nonzero.  (The parameter would be called
     "lambda", but that is a reserved word in Python.)  Returned values
     range from 0 to positive infinity if `lambd' is positive, and from
     negative infinity to 0 if `lambd' is negative.

 -- Function: random.gammavariate (alpha, beta)

     Gamma distribution.  (`Not' the gamma function!)  Conditions on the
     parameters are ‘alpha > 0’ and ‘beta > 0’.

     The probability distribution function is:

                    x ** (alpha - 1) * math.exp(-x / beta)
          pdf(x) =  --------------------------------------
                      math.gamma(alpha) * beta ** alpha

 -- Function: random.gauss (mu, sigma)

     Gaussian distribution.  `mu' is the mean, and `sigma' is the
     standard deviation.  This is slightly faster than the *note
     normalvariate(): 14aa. function defined below.

 -- Function: random.lognormvariate (mu, sigma)

     Log normal distribution.  If you take the natural logarithm of this
     distribution, you’ll get a normal distribution with mean `mu' and
     standard deviation `sigma'.  `mu' can have any value, and `sigma'
     must be greater than zero.

 -- Function: random.normalvariate (mu, sigma)

     Normal distribution.  `mu' is the mean, and `sigma' is the standard
     deviation.

 -- Function: random.vonmisesvariate (mu, kappa)

     `mu' is the mean angle, expressed in radians between 0 and 2*`pi',
     and `kappa' is the concentration parameter, which must be greater
     than or equal to zero.  If `kappa' is equal to zero, this
     distribution reduces to a uniform random angle over the range 0 to
     2*`pi'.

 -- Function: random.paretovariate (alpha)

     Pareto distribution.  `alpha' is the shape parameter.

 -- Function: random.weibullvariate (alpha, beta)

     Weibull distribution.  `alpha' is the scale parameter and `beta' is
     the shape parameter.

Alternative Generator:

 -- Class: random.SystemRandom ([seed])

     Class that uses the *note os.urandom(): 2df. function for
     generating random numbers from sources provided by the operating
     system.  Not available on all systems.  Does not rely on software
     state, and sequences are not reproducible.  Accordingly, the *note
     seed(): 869. method has no effect and is ignored.  The *note
     getstate(): 14a2. and *note setstate(): 14a3. methods raise *note
     NotImplementedError: 569. if called.

See also
........

M. Matsumoto and T. Nishimura, "Mersenne Twister: A 623-dimensionally
equidistributed uniform pseudorandom number generator", ACM Transactions
on Modeling and Computer Simulation Vol.  8, No.  1, January pp.3-30
1998.

Complementary-Multiply-with-Carry recipe(2) for a compatible alternative
random number generator with a long period and comparatively simple
update operations.

* Menu:

* Notes on Reproducibility:: 
* Examples and Recipes:: 

   ---------- Footnotes ----------

   (1) https://hg.python.org/cpython/file/default/Lib/random.py

   (2) https://code.activestate.com/recipes/576707/


File: python.info,  Node: Notes on Reproducibility,  Next: Examples and Recipes,  Up: random --- Generate pseudo-random numbers

5.9.6.1 Notes on Reproducibility
................................

Sometimes it is useful to be able to reproduce the sequences given by a
pseudo random number generator.  By re-using a seed value, the same
sequence should be reproducible from run to run as long as multiple
threads are not running.

Most of the random module’s algorithms and seeding functions are subject
to change across Python versions, but two aspects are guaranteed not to
change:

   * If a new seeding method is added, then a backward compatible seeder
     will be offered.

   * The generator’s ‘random()’ method will continue to produce the same
     sequence when the compatible seeder is given the same seed.


File: python.info,  Node: Examples and Recipes,  Prev: Notes on Reproducibility,  Up: random --- Generate pseudo-random numbers

5.9.6.2 Examples and Recipes
............................

Basic usage:

     >>> random.random()                      # Random float x, 0.0 <= x < 1.0
     0.37444887175646646

     >>> random.uniform(1, 10)                # Random float x, 1.0 <= x < 10.0
     1.1800146073117523

     >>> random.randrange(10)                 # Integer from 0 to 9
     7

     >>> random.randrange(0, 101, 2)          # Even integer from 0 to 100
     26

     >>> random.choice('abcdefghij')          # Single random element
     'c'

     >>> items = [1, 2, 3, 4, 5, 6, 7]
     >>> random.shuffle(items)
     >>> items
     [7, 3, 2, 5, 6, 4, 1]

     >>> random.sample([1, 2, 3, 4, 5],  3)   # Three samples without replacement
     [4, 1, 5]

A common task is to make a *note random.choice(): 81b. with weighted
probabilities.

If the weights are small integer ratios, a simple technique is to build
a sample population with repeats:

     >>> weighted_choices = [('Red', 3), ('Blue', 2), ('Yellow', 1), ('Green', 4)]
     >>> population = [val for val, cnt in weighted_choices for i in range(cnt)]
     >>> random.choice(population)
     'Green'

A more general approach is to arrange the weights in a cumulative
distribution with *note itertools.accumulate(): 64a, and then locate the
random value with *note bisect.bisect(): 1315.:

     >>> choices, weights = zip(*weighted_choices)
     >>> cumdist = list(itertools.accumulate(weights))
     >>> x = random.random() * cumdist[-1]
     >>> choices[bisect.bisect(cumdist, x)]
     'Blue'


File: python.info,  Node: statistics --- Mathematical statistics functions,  Prev: random --- Generate pseudo-random numbers,  Up: Numeric and Mathematical Modules

5.9.7 ‘statistics’ — Mathematical statistics functions
------------------------------------------------------

New in version 3.4.

`Source code:' Lib/statistics.py(1)

__________________________________________________________________

This module provides functions for calculating mathematical statistics
of numeric (‘Real’-valued) data.

     Note: Unless explicitly noted otherwise, these functions support
     *note int: 227, *note float: 57a, *note decimal.Decimal: 618. and
     *note fractions.Fraction: 378.  Behaviour with other types (whether
     in the numeric tower or not) is currently unsupported.  Mixed types
     are also undefined and implementation-dependent.  If your input
     data consists of mixed types, you may be able to use *note map():
     892. to ensure a consistent result, e.g.  ‘map(float, input_data)’.

* Menu:

* Averages and measures of central location:: 
* Measures of spread:: 
* Function details:: 
* Exceptions: Exceptions<3>. 

   ---------- Footnotes ----------

   (1) https://hg.python.org/cpython/file/default/Lib/statistics.py


File: python.info,  Node: Averages and measures of central location,  Next: Measures of spread,  Up: statistics --- Mathematical statistics functions

5.9.7.1 Averages and measures of central location
.................................................

These functions calculate an average or typical value from a population
or sample.

*note mean(): 14b4.         Arithmetic mean ("average") of data.
                            
                            
*note median(): 14b5.       Median (middle value) of data.
                            
                            
*note median_low(): 14b6.   Low median of data.
                            
                            
*note median_high(): 14b7.  High median of data.
                            
                            
*note median_grouped(): 14b8.Median, or 50th percentile, of grouped data.
                            
                            
*note mode(): 14b9.         Mode (most common value) of discrete data.
                            


File: python.info,  Node: Measures of spread,  Next: Function details,  Prev: Averages and measures of central location,  Up: statistics --- Mathematical statistics functions

5.9.7.2 Measures of spread
..........................

These functions calculate a measure of how much the population or sample
tends to deviate from the typical or average values.

*note pstdev(): 14bb.       Population standard deviation of data.
                            
                            
*note pvariance(): 14bc.    Population variance of data.
                            
                            
*note stdev(): 14bd.        Sample standard deviation of data.
                            
                            
*note variance(): 14be.     Sample variance of data.
                            


File: python.info,  Node: Function details,  Next: Exceptions<3>,  Prev: Measures of spread,  Up: statistics --- Mathematical statistics functions

5.9.7.3 Function details
........................

Note: The functions do not require the data given to them to be sorted.
However, for reading convenience, most of the examples show sorted
sequences.

 -- Function: statistics.mean (data)

     Return the sample arithmetic mean of `data', a sequence or iterator
     of real-valued numbers.

     The arithmetic mean is the sum of the data divided by the number of
     data points.  It is commonly called "the average", although it is
     only one of many different mathematical averages.  It is a measure
     of the central location of the data.

     If `data' is empty, *note StatisticsError: 14c0. will be raised.

     Some examples of use:

          >>> mean([1, 2, 3, 4, 4])
          2.8
          >>> mean([-1.0, 2.5, 3.25, 5.75])
          2.625

          >>> from fractions import Fraction as F
          >>> mean([F(3, 7), F(1, 21), F(5, 3), F(1, 3)])
          Fraction(13, 21)

          >>> from decimal import Decimal as D
          >>> mean([D("0.5"), D("0.75"), D("0.625"), D("0.375")])
          Decimal('0.5625')

          Note: The mean is strongly affected by outliers and is not a
          robust estimator for central location: the mean is not
          necessarily a typical example of the data points.  For more
          robust, although less efficient, measures of central location,
          see *note median(): 14b5. and *note mode(): 14b9.  (In this
          case, "efficient" refers to statistical efficiency rather than
          computational efficiency.)

          The sample mean gives an unbiased estimate of the true
          population mean, which means that, taken on average over all
          the possible samples, ‘mean(sample)’ converges on the true
          mean of the entire population.  If `data' represents the
          entire population rather than a sample, then ‘mean(data)’ is
          equivalent to calculating the true population mean μ.

 -- Function: statistics.median (data)

     Return the median (middle value) of numeric data, using the common
     "mean of middle two" method.  If `data' is empty, *note
     StatisticsError: 14c0. is raised.

     The median is a robust measure of central location, and is less
     affected by the presence of outliers in your data.  When the number
     of data points is odd, the middle data point is returned:

          >>> median([1, 3, 5])
          3

     When the number of data points is even, the median is interpolated
     by taking the average of the two middle values:

          >>> median([1, 3, 5, 7])
          4.0

     This is suited for when your data is discrete, and you don’t mind
     that the median may not be an actual data point.

     See also
     ........

     *note median_low(): 14b6, *note median_high(): 14b7, *note
     median_grouped(): 14b8.

 -- Function: statistics.median_low (data)

     Return the low median of numeric data.  If `data' is empty, *note
     StatisticsError: 14c0. is raised.

     The low median is always a member of the data set.  When the number
     of data points is odd, the middle value is returned.  When it is
     even, the smaller of the two middle values is returned.

          >>> median_low([1, 3, 5])
          3
          >>> median_low([1, 3, 5, 7])
          3

     Use the low median when your data are discrete and you prefer the
     median to be an actual data point rather than interpolated.

 -- Function: statistics.median_high (data)

     Return the high median of data.  If `data' is empty, *note
     StatisticsError: 14c0. is raised.

     The high median is always a member of the data set.  When the
     number of data points is odd, the middle value is returned.  When
     it is even, the larger of the two middle values is returned.

          >>> median_high([1, 3, 5])
          3
          >>> median_high([1, 3, 5, 7])
          5

     Use the high median when your data are discrete and you prefer the
     median to be an actual data point rather than interpolated.

 -- Function: statistics.median_grouped (data, interval=1)

     Return the median of grouped continuous data, calculated as the
     50th percentile, using interpolation.  If `data' is empty, *note
     StatisticsError: 14c0. is raised.

          >>> median_grouped([52, 52, 53, 54])
          52.5

     In the following example, the data are rounded, so that each value
     represents the midpoint of data classes, e.g.  1 is the midpoint of
     the class 0.5-1.5, 2 is the midpoint of 1.5-2.5, 3 is the midpoint
     of 2.5-3.5, etc.  With the data given, the middle value falls
     somewhere in the class 3.5-4.5, and interpolation is used to
     estimate it:

          >>> median_grouped([1, 2, 2, 3, 4, 4, 4, 4, 4, 5])
          3.7

     Optional argument `interval' represents the class interval, and
     defaults to 1.  Changing the class interval naturally will change
     the interpolation:

          >>> median_grouped([1, 3, 3, 5, 7], interval=1)
          3.25
          >>> median_grouped([1, 3, 3, 5, 7], interval=2)
          3.5

     This function does not check whether the data points are at least
     `interval' apart.

     `CPython implementation detail:' Under some circumstances, *note
     median_grouped(): 14b8. may coerce data points to floats.  This
     behaviour is likely to change in the future.

     See also
     ........

        * "Statistics for the Behavioral Sciences", Frederick J
          Gravetter and Larry B Wallnau (8th Edition).

        * Calculating the median(1).

        * The SSMEDIAN(2) function in the Gnome Gnumeric spreadsheet,
          including this discussion(3).

 -- Function: statistics.mode (data)

     Return the most common data point from discrete or nominal `data'.
     The mode (when it exists) is the most typical value, and is a
     robust measure of central location.

     If `data' is empty, or if there is not exactly one most common
     value, *note StatisticsError: 14c0. is raised.

     ‘mode’ assumes discrete data, and returns a single value.  This is
     the standard treatment of the mode as commonly taught in schools:

          >>> mode([1, 1, 2, 3, 3, 3, 3, 4])
          3

     The mode is unique in that it is the only statistic which also
     applies to nominal (non-numeric) data:

          >>> mode(["red", "blue", "blue", "red", "green", "red", "red"])
          'red'

 -- Function: statistics.pstdev (data, mu=None)

     Return the population standard deviation (the square root of the
     population variance).  See *note pvariance(): 14bc. for arguments
     and other details.

          >>> pstdev([1.5, 2.5, 2.5, 2.75, 3.25, 4.75])
          0.986893273527251

 -- Function: statistics.pvariance (data, mu=None)

     Return the population variance of `data', a non-empty iterable of
     real-valued numbers.  Variance, or second moment about the mean, is
     a measure of the variability (spread or dispersion) of data.  A
     large variance indicates that the data is spread out; a small
     variance indicates it is clustered closely around the mean.

     If the optional second argument `mu' is given, it should be the
     mean of `data'.  If it is missing or ‘None’ (the default), the mean
     is automatically calculated.

     Use this function to calculate the variance from the entire
     population.  To estimate the variance from a sample, the *note
     variance(): 14be. function is usually a better choice.

     Raises *note StatisticsError: 14c0. if `data' is empty.

     Examples:

          >>> data = [0.0, 0.25, 0.25, 1.25, 1.5, 1.75, 2.75, 3.25]
          >>> pvariance(data)
          1.25

     If you have already calculated the mean of your data, you can pass
     it as the optional second argument `mu' to avoid recalculation:

          >>> mu = mean(data)
          >>> pvariance(data, mu)
          1.25

     This function does not attempt to verify that you have passed the
     actual mean as `mu'.  Using arbitrary values for `mu' may lead to
     invalid or impossible results.

     Decimals and Fractions are supported:

          >>> from decimal import Decimal as D
          >>> pvariance([D("27.5"), D("30.25"), D("30.25"), D("34.5"), D("41.75")])
          Decimal('24.815')

          >>> from fractions import Fraction as F
          >>> pvariance([F(1, 4), F(5, 4), F(1, 2)])
          Fraction(13, 72)

          Note: When called with the entire population, this gives the
          population variance σ².  When called on a sample instead, this
          is the biased sample variance s², also known as variance with
          N degrees of freedom.

          If you somehow know the true population mean μ, you may use
          this function to calculate the variance of a sample, giving
          the known population mean as the second argument.  Provided
          the data points are representative (e.g.  independent and
          identically distributed), the result will be an unbiased
          estimate of the population variance.

 -- Function: statistics.stdev (data, xbar=None)

     Return the sample standard deviation (the square root of the sample
     variance).  See *note variance(): 14be. for arguments and other
     details.

          >>> stdev([1.5, 2.5, 2.5, 2.75, 3.25, 4.75])
          1.0810874155219827

 -- Function: statistics.variance (data, xbar=None)

     Return the sample variance of `data', an iterable of at least two
     real-valued numbers.  Variance, or second moment about the mean, is
     a measure of the variability (spread or dispersion) of data.  A
     large variance indicates that the data is spread out; a small
     variance indicates it is clustered closely around the mean.

     If the optional second argument `xbar' is given, it should be the
     mean of `data'.  If it is missing or ‘None’ (the default), the mean
     is automatically calculated.

     Use this function when your data is a sample from a population.  To
     calculate the variance from the entire population, see *note
     pvariance(): 14bc.

     Raises *note StatisticsError: 14c0. if `data' has fewer than two
     values.

     Examples:

          >>> data = [2.75, 1.75, 1.25, 0.25, 0.5, 1.25, 3.5]
          >>> variance(data)
          1.3720238095238095

     If you have already calculated the mean of your data, you can pass
     it as the optional second argument `xbar' to avoid recalculation:

          >>> m = mean(data)
          >>> variance(data, m)
          1.3720238095238095

     This function does not attempt to verify that you have passed the
     actual mean as `xbar'.  Using arbitrary values for `xbar' can lead
     to invalid or impossible results.

     Decimal and Fraction values are supported:

          >>> from decimal import Decimal as D
          >>> variance([D("27.5"), D("30.25"), D("30.25"), D("34.5"), D("41.75")])
          Decimal('31.01875')

          >>> from fractions import Fraction as F
          >>> variance([F(1, 6), F(1, 2), F(5, 3)])
          Fraction(67, 108)

          Note: This is the sample variance s² with Bessel’s correction,
          also known as variance with N-1 degrees of freedom.  Provided
          that the data points are representative (e.g.  independent and
          identically distributed), the result should be an unbiased
          estimate of the true population variance.

          If you somehow know the actual population mean μ you should
          pass it to the *note pvariance(): 14bc. function as the `mu'
          parameter to get the variance of a sample.

   ---------- Footnotes ----------

   (1) http://www.ualberta.ca/~opscan/median.html

   (2) 
https://help.gnome.org/users/gnumeric/stable/gnumeric.html#gnumeric-function-SSMEDIAN

   (3) 
https://mail.gnome.org/archives/gnumeric-list/2011-April/msg00018.html


File: python.info,  Node: Exceptions<3>,  Prev: Function details,  Up: statistics --- Mathematical statistics functions

5.9.7.4 Exceptions
..................

A single exception is defined:

 -- Exception: statistics.StatisticsError

     Subclass of *note ValueError: 19c. for statistics-related
     exceptions.


File: python.info,  Node: Functional Programming Modules,  Next: File and Directory Access,  Prev: Numeric and Mathematical Modules,  Up: The Python Standard Library

5.10 Functional Programming Modules
===================================

The modules described in this chapter provide functions and classes that
support a functional programming style, and general operations on
callables.

The following modules are documented in this chapter:

* Menu:

* itertools: itertools --- Functions creating iterators for efficient looping. Functions creating iterators for efficient looping
* functools: functools --- Higher-order functions and operations on callable objects. Higher-order functions and operations on callable
                        objects
* operator: operator --- Standard operators as functions. Standard operators as functions


File: python.info,  Node: itertools --- Functions creating iterators for efficient looping,  Next: functools --- Higher-order functions and operations on callable objects,  Up: Functional Programming Modules

5.10.1 ‘itertools’ — Functions creating iterators for efficient looping
-----------------------------------------------------------------------

This module implements a number of *note iterator: e4f. building blocks
inspired by constructs from APL, Haskell, and SML. Each has been recast
in a form suitable for Python.

The module standardizes a core set of fast, memory efficient tools that
are useful by themselves or in combination.  Together, they form an
"iterator algebra" making it possible to construct specialized tools
succinctly and efficiently in pure Python.

For instance, SML provides a tabulation tool: ‘tabulate(f)’ which
produces a sequence ‘f(0), f(1), ...’.  The same effect can be achieved
in Python by combining *note map(): 892. and *note count(): 87f. to form
‘map(f, count())’.

These tools and their built-in counterparts also work well with the
high-speed functions in the *note operator: c0. module.  For example,
the multiplication operator can be mapped across two vectors to form an
efficient dot-product: ‘sum(map(operator.mul, vector1, vector2))’.

`Infinite Iterators:'

Iterator               Arguments             Results                                               Example
                                                                                                   
-------------------------------------------------------------------------------------------------------------------------------------------------
                                                                                                   
*note count(): 87f.    start, [step]         start, start+step, start+2*step, ...                  ‘count(10) --> 10 11 12 13 14 ...’
                                                                                                   
                                                                                                   
*note cycle(): 14c6.   p                     p0, p1, ...  plast, p0, p1, ...                       ‘cycle('ABCD') --> A B C D A B C D ...’
                                                                                                   
                                                                                                   
*note repeat(): 14c7.  elem [,n]             elem, elem, elem, ...  endlessly or up to n times     ‘repeat(10, 3) --> 10 10 10’
                                                                                                   

`Iterators terminating on the shortest input sequence:'

Iterator                         Arguments                        Results                                               Example
                                                                                                                        
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
                                                                                                                        
*note accumulate(): 64a.         p [,func]                        p0, p0+p1, p0+p1+p2, ...                              ‘accumulate([1,2,3,4,5]) --> 1 3 6 10 15’
                                                                                                                        
                                                                                                                        
*note chain(): fba.              p, q, ...                        p0, p1, ...  plast, q0, q1, ...                       ‘chain('ABC', 'DEF') --> A B C D E F’
                                                                                                                        
                                                                                                                        
*note chain.from_iterable(): 14c8.iterable                        p0, p1, ...  plast, q0, q1, ...                       ‘chain.from_iterable(['ABC', 'DEF']) --> A B C D E F’
                                                                                                                        
                                                                                                                        
*note compress(): 87e.           data, selectors                  (d[0] if s[0]), (d[1] if s[1]), ...                   ‘compress('ABCDEF', [1,0,1,0,1,1]) --> A C E F’
                                                                                                                        
                                                                                                                        
*note dropwhile(): 14c9.         pred, seq                        seq[n], seq[n+1], starting when pred fails            ‘dropwhile(lambda x: x<5, [1,4,6,4,1]) --> 6 4 1’
                                                                                                                        
                                                                                                                        
*note filterfalse(): fa3.        pred, seq                        elements of seq where pred(elem) is false             ‘filterfalse(lambda x: x%2, range(10)) --> 0 2 4 6 8’
                                                                                                                        
                                                                                                                        
*note groupby(): 14ca.           iterable[, keyfunc]              sub-iterators grouped by value of keyfunc(v)
                                                                  
                                                                                                                        
*note islice(): a0d.             seq, [start,] stop [, step]      elements from seq[start:stop:step]                    ‘islice('ABCDEFG', 2, None) --> C D E F G’
                                                                                                                        
                                                                                                                        
*note starmap(): 659.            func, seq                        func(*seq[0]), func(*seq[1]), ...                     ‘starmap(pow, [(2,5), (3,2), (10,3)]) --> 32 9 1000’
                                                                                                                        
                                                                                                                        
*note takewhile(): 14cb.         pred, seq                        seq[0], seq[1], until pred fails                      ‘takewhile(lambda x: x<5, [1,4,6,4,1]) --> 1 4’
                                                                                                                        
                                                                                                                        
*note tee(): 14cc.               it, n                            it1, it2, ...  itn splits one iterator into n
                                                                  
                                                                                                                        
*note zip_longest(): 896.        p, q, ...                        (p[0], q[0]), (p[1], q[1]), ...                       ‘zip_longest('ABCD', 'xy', fillvalue='-') --> Ax By C- D-’
                                                                                                                        

`Combinatoric generators:'

Iterator                                           Arguments                Results
                                                                            
----------------------------------------------------------------------------------------------------------------------------------------------
                                                                            
*note product(): 91a.                              p, q, ...  [repeat=1]    cartesian product, equivalent to a nested for-loop
                                                                            
                                                                            
*note permutations(): 14cd.                        p[, r]                   r-length tuples, all possible orderings, no repeated elements
                                                                            
                                                                            
*note combinations(): 919.                         p, r                     r-length tuples, in sorted order, no repeated elements
                                                                            
                                                                            
*note combinations_with_replacement(): 87d.        p, r                     r-length tuples, in sorted order, with repeated elements
                                                                            
                                                                            
‘product('ABCD', repeat=2)’                                                 ‘AA AB AC AD BA BB BC BD CA CB CC CD DA DB DC DD’
                                                                            
                                                                            
‘permutations('ABCD', 2)’                                                   ‘AB AC AD BA BC BD CA CB CD DA DB DC’
                                                                            
                                                                            
‘combinations('ABCD', 2)’                                                   ‘AB AC AD BC BD CD’
                                                                            
                                                                            
‘combinations_with_replacement('ABCD', 2)’                                  ‘AA AB AC AD BB BC BD CC CD DD’
                                                                            

* Menu:

* Itertool functions:: 
* Itertools Recipes:: 


File: python.info,  Node: Itertool functions,  Next: Itertools Recipes,  Up: itertools --- Functions creating iterators for efficient looping

5.10.1.1 Itertool functions
...........................

The following module functions all construct and return iterators.  Some
provide streams of infinite length, so they should only be accessed by
functions or loops that truncate the stream.

 -- Function: itertools.accumulate (iterable[, func])

     Make an iterator that returns accumulated sums, or accumulated
     results of other binary functions (specified via the optional
     `func' argument).  If `func' is supplied, it should be a function
     of two arguments.  Elements of the input `iterable' may be any type
     that can be accepted as arguments to `func'.  (For example, with
     the default operation of addition, elements may be any addable type
     including *note Decimal: 618. or *note Fraction: 378.)  If the
     input iterable is empty, the output iterable will also be empty.

     Equivalent to:

          def accumulate(iterable, func=operator.add):
              'Return running totals'
              # accumulate([1,2,3,4,5]) --> 1 3 6 10 15
              # accumulate([1,2,3,4,5], operator.mul) --> 1 2 6 24 120
              it = iter(iterable)
              try:
                  total = next(it)
              except StopIteration:
                  return
              yield total
              for element in it:
                  total = func(total, element)
                  yield total

     There are a number of uses for the `func' argument.  It can be set
     to *note min(): 3f9. for a running minimum, *note max(): 3fa. for a
     running maximum, or *note operator.mul(): 14d0. for a running
     product.  Amortization tables can be built by accumulating interest
     and applying payments.  First-order recurrence relations(1) can be
     modeled by supplying the initial value in the iterable and using
     only the accumulated total in `func' argument:

          >>> data = [3, 4, 6, 2, 1, 9, 0, 7, 5, 8]
          >>> list(accumulate(data, operator.mul))     # running product
          [3, 12, 72, 144, 144, 1296, 0, 0, 0, 0]
          >>> list(accumulate(data, max))              # running maximum
          [3, 4, 6, 6, 6, 9, 9, 9, 9, 9]

          # Amortize a 5% loan of 1000 with 4 annual payments of 90
          >>> cashflows = [1000, -90, -90, -90, -90]
          >>> list(accumulate(cashflows, lambda bal, pmt: bal*1.05 + pmt))
          [1000, 960.0, 918.0, 873.9000000000001, 827.5950000000001]

          # Chaotic recurrence relation https://en.wikipedia.org/wiki/Logistic_map
          >>> logistic_map = lambda x, _:  r * x * (1 - x)
          >>> r = 3.8
          >>> x0 = 0.4
          >>> inputs = repeat(x0, 36)     # only the initial value is used
          >>> [format(x, '.2f') for x in accumulate(inputs, logistic_map)]
          ['0.40', '0.91', '0.30', '0.81', '0.60', '0.92', '0.29', '0.79', '0.63',
           '0.88', '0.39', '0.90', '0.33', '0.84', '0.52', '0.95', '0.18', '0.57',
           '0.93', '0.25', '0.71', '0.79', '0.63', '0.88', '0.39', '0.91', '0.32',
           '0.83', '0.54', '0.95', '0.20', '0.60', '0.91', '0.30', '0.80', '0.60']

     See *note functools.reduce(): 8db. for a similar function that
     returns only the final accumulated value.

     New in version 3.2.

     Changed in version 3.3: Added the optional `func' parameter.

 -- Function: itertools.chain (*iterables)

     Make an iterator that returns elements from the first iterable
     until it is exhausted, then proceeds to the next iterable, until
     all of the iterables are exhausted.  Used for treating consecutive
     sequences as a single sequence.  Equivalent to:

          def chain(*iterables):
              # chain('ABC', 'DEF') --> A B C D E F
              for it in iterables:
                  for element in it:
                      yield element

 -- Class Method: chain.from_iterable (iterable)

     Alternate constructor for *note chain(): fba.  Gets chained inputs
     from a single iterable argument that is evaluated lazily.  Roughly
     equivalent to:

          def from_iterable(iterables):
              # chain.from_iterable(['ABC', 'DEF']) --> A B C D E F
              for it in iterables:
                  for element in it:
                      yield element

 -- Function: itertools.combinations (iterable, r)

     Return `r' length subsequences of elements from the input
     `iterable'.

     Combinations are emitted in lexicographic sort order.  So, if the
     input `iterable' is sorted, the combination tuples will be produced
     in sorted order.

     Elements are treated as unique based on their position, not on
     their value.  So if the input elements are unique, there will be no
     repeat values in each combination.

     Equivalent to:

          def combinations(iterable, r):
              # combinations('ABCD', 2) --> AB AC AD BC BD CD
              # combinations(range(4), 3) --> 012 013 023 123
              pool = tuple(iterable)
              n = len(pool)
              if r > n:
                  return
              indices = list(range(r))
              yield tuple(pool[i] for i in indices)
              while True:
                  for i in reversed(range(r)):
                      if indices[i] != i + n - r:
                          break
                  else:
                      return
                  indices[i] += 1
                  for j in range(i+1, r):
                      indices[j] = indices[j-1] + 1
                  yield tuple(pool[i] for i in indices)

     The code for *note combinations(): 919. can be also expressed as a
     subsequence of *note permutations(): 14cd. after filtering entries
     where the elements are not in sorted order (according to their
     position in the input pool):

          def combinations(iterable, r):
              pool = tuple(iterable)
              n = len(pool)
              for indices in permutations(range(n), r):
                  if sorted(indices) == list(indices):
                      yield tuple(pool[i] for i in indices)

     The number of items returned is ‘n! / r! / (n-r)!’ when ‘0 <= r <=
     n’ or zero when ‘r > n’.

 -- Function: itertools.combinations_with_replacement (iterable, r)

     Return `r' length subsequences of elements from the input
     `iterable' allowing individual elements to be repeated more than
     once.

     Combinations are emitted in lexicographic sort order.  So, if the
     input `iterable' is sorted, the combination tuples will be produced
     in sorted order.

     Elements are treated as unique based on their position, not on
     their value.  So if the input elements are unique, the generated
     combinations will also be unique.

     Equivalent to:

          def combinations_with_replacement(iterable, r):
              # combinations_with_replacement('ABC', 2) --> AA AB AC BB BC CC
              pool = tuple(iterable)
              n = len(pool)
              if not n and r:
                  return
              indices = [0] * r
              yield tuple(pool[i] for i in indices)
              while True:
                  for i in reversed(range(r)):
                      if indices[i] != n - 1:
                          break
                  else:
                      return
                  indices[i:] = [indices[i] + 1] * (r - i)
                  yield tuple(pool[i] for i in indices)

     The code for *note combinations_with_replacement(): 87d. can be
     also expressed as a subsequence of *note product(): 91a. after
     filtering entries where the elements are not in sorted order
     (according to their position in the input pool):

          def combinations_with_replacement(iterable, r):
              pool = tuple(iterable)
              n = len(pool)
              for indices in product(range(n), repeat=r):
                  if sorted(indices) == list(indices):
                      yield tuple(pool[i] for i in indices)

     The number of items returned is ‘(n+r-1)! / r! / (n-1)!’ when ‘n >
     0’.

     New in version 3.1.

 -- Function: itertools.compress (data, selectors)

     Make an iterator that filters elements from `data' returning only
     those that have a corresponding element in `selectors' that
     evaluates to ‘True’.  Stops when either the `data' or `selectors'
     iterables has been exhausted.  Equivalent to:

          def compress(data, selectors):
              # compress('ABCDEF', [1,0,1,0,1,1]) --> A C E F
              return (d for d, s in zip(data, selectors) if s)

     New in version 3.1.

 -- Function: itertools.count (start=0, step=1)

     Make an iterator that returns evenly spaced values starting with
     number `start'.  Often used as an argument to *note map(): 892. to
     generate consecutive data points.  Also, used with *note zip():
     897. to add sequence numbers.  Equivalent to:

          def count(start=0, step=1):
              # count(10) --> 10 11 12 13 14 ...
              # count(2.5, 0.5) -> 2.5 3.0 3.5 ...
              n = start
              while True:
                  yield n
                  n += step

     When counting with floating point numbers, better accuracy can
     sometimes be achieved by substituting multiplicative code such as:
     ‘(start + step * i for i in count())’.

     Changed in version 3.1: Added `step' argument and allowed
     non-integer arguments.

 -- Function: itertools.cycle (iterable)

     Make an iterator returning elements from the iterable and saving a
     copy of each.  When the iterable is exhausted, return elements from
     the saved copy.  Repeats indefinitely.  Equivalent to:

          def cycle(iterable):
              # cycle('ABCD') --> A B C D A B C D A B C D ...
              saved = []
              for element in iterable:
                  yield element
                  saved.append(element)
              while saved:
                  for element in saved:
                        yield element

     Note, this member of the toolkit may require significant auxiliary
     storage (depending on the length of the iterable).

 -- Function: itertools.dropwhile (predicate, iterable)

     Make an iterator that drops elements from the iterable as long as
     the predicate is true; afterwards, returns every element.  Note,
     the iterator does not produce `any' output until the predicate
     first becomes false, so it may have a lengthy start-up time.
     Equivalent to:

          def dropwhile(predicate, iterable):
              # dropwhile(lambda x: x<5, [1,4,6,4,1]) --> 6 4 1
              iterable = iter(iterable)
              for x in iterable:
                  if not predicate(x):
                      yield x
                      break
              for x in iterable:
                  yield x

 -- Function: itertools.filterfalse (predicate, iterable)

     Make an iterator that filters elements from iterable returning only
     those for which the predicate is ‘False’.  If `predicate' is
     ‘None’, return the items that are false.  Equivalent to:

          def filterfalse(predicate, iterable):
              # filterfalse(lambda x: x%2, range(10)) --> 0 2 4 6 8
              if predicate is None:
                  predicate = bool
              for x in iterable:
                  if not predicate(x):
                      yield x

 -- Function: itertools.groupby (iterable, key=None)

     Make an iterator that returns consecutive keys and groups from the
     `iterable'.  The `key' is a function computing a key value for each
     element.  If not specified or is ‘None’, `key' defaults to an
     identity function and returns the element unchanged.  Generally,
     the iterable needs to already be sorted on the same key function.

     The operation of *note groupby(): 14ca. is similar to the ‘uniq’
     filter in Unix.  It generates a break or new group every time the
     value of the key function changes (which is why it is usually
     necessary to have sorted the data using the same key function).
     That behavior differs from SQL’s GROUP BY which aggregates common
     elements regardless of their input order.

     The returned group is itself an iterator that shares the underlying
     iterable with *note groupby(): 14ca.  Because the source is shared,
     when the *note groupby(): 14ca. object is advanced, the previous
     group is no longer visible.  So, if that data is needed later, it
     should be stored as a list:

          groups = []
          uniquekeys = []
          data = sorted(data, key=keyfunc)
          for k, g in groupby(data, keyfunc):
              groups.append(list(g))      # Store group iterator as a list
              uniquekeys.append(k)

     *note groupby(): 14ca. is equivalent to:

          class groupby:
              # [k for k, g in groupby('AAAABBBCCDAABBB')] --> A B C D A B
              # [list(g) for k, g in groupby('AAAABBBCCD')] --> AAAA BBB CC D
              def __init__(self, iterable, key=None):
                  if key is None:
                      key = lambda x: x
                  self.keyfunc = key
                  self.it = iter(iterable)
                  self.tgtkey = self.currkey = self.currvalue = object()
              def __iter__(self):
                  return self
              def __next__(self):
                  while self.currkey == self.tgtkey:
                      self.currvalue = next(self.it)    # Exit on StopIteration
                      self.currkey = self.keyfunc(self.currvalue)
                  self.tgtkey = self.currkey
                  return (self.currkey, self._grouper(self.tgtkey))
              def _grouper(self, tgtkey):
                  while self.currkey == tgtkey:
                      yield self.currvalue
                      try:
                          self.currvalue = next(self.it)
                      except StopIteration:
                          return
                      self.currkey = self.keyfunc(self.currvalue)

 -- Function: itertools.islice (iterable, stop)

 -- Function: itertools.islice (iterable, start, stop[, step])

     Make an iterator that returns selected elements from the iterable.
     If `start' is non-zero, then elements from the iterable are skipped
     until start is reached.  Afterward, elements are returned
     consecutively unless `step' is set higher than one which results in
     items being skipped.  If `stop' is ‘None’, then iteration continues
     until the iterator is exhausted, if at all; otherwise, it stops at
     the specified position.  Unlike regular slicing, *note islice():
     a0d. does not support negative values for `start', `stop', or
     `step'.  Can be used to extract related fields from data where the
     internal structure has been flattened (for example, a multi-line
     report may list a name field on every third line).  Equivalent to:

          def islice(iterable, *args):
              # islice('ABCDEFG', 2) --> A B
              # islice('ABCDEFG', 2, 4) --> C D
              # islice('ABCDEFG', 2, None) --> C D E F G
              # islice('ABCDEFG', 0, None, 2) --> A C E G
              s = slice(*args)
              it = iter(range(s.start or 0, s.stop or sys.maxsize, s.step or 1))
              try:
                  nexti = next(it)
              except StopIteration:
                  return
              for i, element in enumerate(iterable):
                  if i == nexti:
                      yield element
                      nexti = next(it)

     If `start' is ‘None’, then iteration starts at zero.  If `step' is
     ‘None’, then the step defaults to one.

 -- Function: itertools.permutations (iterable, r=None)

     Return successive `r' length permutations of elements in the
     `iterable'.

     If `r' is not specified or is ‘None’, then `r' defaults to the
     length of the `iterable' and all possible full-length permutations
     are generated.

     Permutations are emitted in lexicographic sort order.  So, if the
     input `iterable' is sorted, the permutation tuples will be produced
     in sorted order.

     Elements are treated as unique based on their position, not on
     their value.  So if the input elements are unique, there will be no
     repeat values in each permutation.

     Equivalent to:

          def permutations(iterable, r=None):
              # permutations('ABCD', 2) --> AB AC AD BA BC BD CA CB CD DA DB DC
              # permutations(range(3)) --> 012 021 102 120 201 210
              pool = tuple(iterable)
              n = len(pool)
              r = n if r is None else r
              if r > n:
                  return
              indices = list(range(n))
              cycles = list(range(n, n-r, -1))
              yield tuple(pool[i] for i in indices[:r])
              while n:
                  for i in reversed(range(r)):
                      cycles[i] -= 1
                      if cycles[i] == 0:
                          indices[i:] = indices[i+1:] + indices[i:i+1]
                          cycles[i] = n - i
                      else:
                          j = cycles[i]
                          indices[i], indices[-j] = indices[-j], indices[i]
                          yield tuple(pool[i] for i in indices[:r])
                          break
                  else:
                      return

     The code for *note permutations(): 14cd. can be also expressed as a
     subsequence of *note product(): 91a, filtered to exclude entries
     with repeated elements (those from the same position in the input
     pool):

          def permutations(iterable, r=None):
              pool = tuple(iterable)
              n = len(pool)
              r = n if r is None else r
              for indices in product(range(n), repeat=r):
                  if len(set(indices)) == r:
                      yield tuple(pool[i] for i in indices)

     The number of items returned is ‘n! / (n-r)!’ when ‘0 <= r <= n’ or
     zero when ‘r > n’.

 -- Function: itertools.product (*iterables, repeat=1)

     Cartesian product of input iterables.

     Equivalent to nested for-loops in a generator expression.  For
     example, ‘product(A, B)’ returns the same as ‘((x,y) for x in A for
     y in B)’.

     The nested loops cycle like an odometer with the rightmost element
     advancing on every iteration.  This pattern creates a lexicographic
     ordering so that if the input’s iterables are sorted, the product
     tuples are emitted in sorted order.

     To compute the product of an iterable with itself, specify the
     number of repetitions with the optional `repeat' keyword argument.
     For example, ‘product(A, repeat=4)’ means the same as ‘product(A,
     A, A, A)’.

     This function is equivalent to the following code, except that the
     actual implementation does not build up intermediate results in
     memory:

          def product(*args, repeat=1):
              # product('ABCD', 'xy') --> Ax Ay Bx By Cx Cy Dx Dy
              # product(range(2), repeat=3) --> 000 001 010 011 100 101 110 111
              pools = [tuple(pool) for pool in args] * repeat
              result = [[]]
              for pool in pools:
                  result = [x+[y] for x in result for y in pool]
              for prod in result:
                  yield tuple(prod)

 -- Function: itertools.repeat (object[, times])

     Make an iterator that returns `object' over and over again.  Runs
     indefinitely unless the `times' argument is specified.  Used as
     argument to *note map(): 892. for invariant parameters to the
     called function.  Also used with *note zip(): 897. to create an
     invariant part of a tuple record.  Equivalent to:

          def repeat(object, times=None):
              # repeat(10, 3) --> 10 10 10
              if times is None:
                  while True:
                      yield object
              else:
                  for i in range(times):
                      yield object

     A common use for `repeat' is to supply a stream of constant values
     to `map' or `zip':

          >>> list(map(pow, range(10), repeat(2)))
          [0, 1, 4, 9, 16, 25, 36, 49, 64, 81]

 -- Function: itertools.starmap (function, iterable)

     Make an iterator that computes the function using arguments
     obtained from the iterable.  Used instead of *note map(): 892. when
     argument parameters are already grouped in tuples from a single
     iterable (the data has been "pre-zipped").  The difference between
     *note map(): 892. and *note starmap(): 659. parallels the
     distinction between ‘function(a,b)’ and ‘function(*c)’.  Equivalent
     to:

          def starmap(function, iterable):
              # starmap(pow, [(2,5), (3,2), (10,3)]) --> 32 9 1000
              for args in iterable:
                  yield function(*args)

 -- Function: itertools.takewhile (predicate, iterable)

     Make an iterator that returns elements from the iterable as long as
     the predicate is true.  Equivalent to:

          def takewhile(predicate, iterable):
              # takewhile(lambda x: x<5, [1,4,6,4,1]) --> 1 4
              for x in iterable:
                  if predicate(x):
                      yield x
                  else:
                      break

 -- Function: itertools.tee (iterable, n=2)

     Return `n' independent iterators from a single iterable.

     The following Python code helps explain what `tee' does (although
     the actual implementation is more complex and uses only a single
     underlying FIFO queue):

          def tee(iterable, n=2):
              it = iter(iterable)
              deques = [collections.deque() for i in range(n)]
              def gen(mydeque):
                  while True:
                      if not mydeque:             # when the local deque is empty
                          try:
                              newval = next(it)   # fetch a new value and
                          except StopIteration:
                              return
                          for d in deques:        # load it to all the deques
                              d.append(newval)
                      yield mydeque.popleft()
              return tuple(gen(d) for d in deques)

     Once *note tee(): 14cc. has made a split, the original `iterable'
     should not be used anywhere else; otherwise, the `iterable' could
     get advanced without the tee objects being informed.

     This itertool may require significant auxiliary storage (depending
     on how much temporary data needs to be stored).  In general, if one
     iterator uses most or all of the data before another iterator
     starts, it is faster to use *note list(): 25d. instead of *note
     tee(): 14cc.

 -- Function: itertools.zip_longest (*iterables, fillvalue=None)

     Make an iterator that aggregates elements from each of the
     iterables.  If the iterables are of uneven length, missing values
     are filled-in with `fillvalue'.  Iteration continues until the
     longest iterable is exhausted.  Equivalent to:

          class ZipExhausted(Exception):
              pass

          def zip_longest(*args, **kwds):
              # zip_longest('ABCD', 'xy', fillvalue='-') --> Ax By C- D-
              fillvalue = kwds.get('fillvalue')
              counter = len(args) - 1
              def sentinel():
                  nonlocal counter
                  if not counter:
                      raise ZipExhausted
                  counter -= 1
                  yield fillvalue
              fillers = repeat(fillvalue)
              iterators = [chain(it, sentinel(), fillers) for it in args]
              try:
                  while iterators:
                      yield tuple(map(next, iterators))
              except ZipExhausted:
                  pass

     If one of the iterables is potentially infinite, then the *note
     zip_longest(): 896. function should be wrapped with something that
     limits the number of calls (for example *note islice(): a0d. or
     *note takewhile(): 14cb.).  If not specified, `fillvalue' defaults
     to ‘None’.

   ---------- Footnotes ----------

   (1) https://en.wikipedia.org/wiki/Recurrence_relation


File: python.info,  Node: Itertools Recipes,  Prev: Itertool functions,  Up: itertools --- Functions creating iterators for efficient looping

5.10.1.2 Itertools Recipes
..........................

This section shows recipes for creating an extended toolset using the
existing itertools as building blocks.

The extended tools offer the same high performance as the underlying
toolset.  The superior memory performance is kept by processing elements
one at a time rather than bringing the whole iterable into memory all at
once.  Code volume is kept small by linking the tools together in a
functional style which helps eliminate temporary variables.  High speed
is retained by preferring "vectorized" building blocks over the use of
for-loops and *note generator: 5c0.s which incur interpreter overhead.

     def take(n, iterable):
         "Return first n items of the iterable as a list"
         return list(islice(iterable, n))

     def tabulate(function, start=0):
         "Return function(0), function(1), ..."
         return map(function, count(start))

     def tail(n, iterable):
         "Return an iterator over the last n items"
         # tail(3, 'ABCDEFG') --> E F G
         return iter(collections.deque(iterable, maxlen=n))

     def consume(iterator, n):
         "Advance the iterator n-steps ahead. If n is none, consume entirely."
         # Use functions that consume iterators at C speed.
         if n is None:
             # feed the entire iterator into a zero-length deque
             collections.deque(iterator, maxlen=0)
         else:
             # advance to the empty slice starting at position n
             next(islice(iterator, n, n), None)

     def nth(iterable, n, default=None):
         "Returns the nth item or a default value"
         return next(islice(iterable, n, None), default)

     def all_equal(iterable):
         "Returns True if all the elements are equal to each other"
         g = groupby(iterable)
         return next(g, True) and not next(g, False)

     def quantify(iterable, pred=bool):
         "Count how many times the predicate is true"
         return sum(map(pred, iterable))

     def padnone(iterable):
         """Returns the sequence elements and then returns None indefinitely.

         Useful for emulating the behavior of the built-in map() function.
         """
         return chain(iterable, repeat(None))

     def ncycles(iterable, n):
         "Returns the sequence elements n times"
         return chain.from_iterable(repeat(tuple(iterable), n))

     def dotproduct(vec1, vec2):
         return sum(map(operator.mul, vec1, vec2))

     def flatten(listOfLists):
         "Flatten one level of nesting"
         return chain.from_iterable(listOfLists)

     def repeatfunc(func, times=None, *args):
         """Repeat calls to func with specified arguments.

         Example:  repeatfunc(random.random)
         """
         if times is None:
             return starmap(func, repeat(args))
         return starmap(func, repeat(args, times))

     def pairwise(iterable):
         "s -> (s0,s1), (s1,s2), (s2, s3), ..."
         a, b = tee(iterable)
         next(b, None)
         return zip(a, b)

     def grouper(iterable, n, fillvalue=None):
         "Collect data into fixed-length chunks or blocks"
         # grouper('ABCDEFG', 3, 'x') --> ABC DEF Gxx"
         args = [iter(iterable)] * n
         return zip_longest(*args, fillvalue=fillvalue)

     def roundrobin(*iterables):
         "roundrobin('ABC', 'D', 'EF') --> A D E B F C"
         # Recipe credited to George Sakkis
         pending = len(iterables)
         nexts = cycle(iter(it).__next__ for it in iterables)
         while pending:
             try:
                 for next in nexts:
                     yield next()
             except StopIteration:
                 pending -= 1
                 nexts = cycle(islice(nexts, pending))

     def partition(pred, iterable):
         'Use a predicate to partition entries into false entries and true entries'
         # partition(is_odd, range(10)) --> 0 2 4 6 8   and  1 3 5 7 9
         t1, t2 = tee(iterable)
         return filterfalse(pred, t1), filter(pred, t2)

     def powerset(iterable):
         "powerset([1,2,3]) --> () (1,) (2,) (3,) (1,2) (1,3) (2,3) (1,2,3)"
         s = list(iterable)
         return chain.from_iterable(combinations(s, r) for r in range(len(s)+1))

     def unique_everseen(iterable, key=None):
         "List unique elements, preserving order. Remember all elements ever seen."
         # unique_everseen('AAAABBBCCDAABBB') --> A B C D
         # unique_everseen('ABBCcAD', str.lower) --> A B C D
         seen = set()
         seen_add = seen.add
         if key is None:
             for element in filterfalse(seen.__contains__, iterable):
                 seen_add(element)
                 yield element
         else:
             for element in iterable:
                 k = key(element)
                 if k not in seen:
                     seen_add(k)
                     yield element

     def unique_justseen(iterable, key=None):
         "List unique elements, preserving order. Remember only the element just seen."
         # unique_justseen('AAAABBBCCDAABBB') --> A B C D A B
         # unique_justseen('ABBCcAD', str.lower) --> A B C A D
         return map(next, map(itemgetter(1), groupby(iterable, key)))

     def iter_except(func, exception, first=None):
         """ Call a function repeatedly until an exception is raised.

         Converts a call-until-exception interface to an iterator interface.
         Like builtins.iter(func, sentinel) but uses an exception instead
         of a sentinel to end the loop.

         Examples:
             iter_except(functools.partial(heappop, h), IndexError)   # priority queue iterator
             iter_except(d.popitem, KeyError)                         # non-blocking dict iterator
             iter_except(d.popleft, IndexError)                       # non-blocking deque iterator
             iter_except(q.get_nowait, Queue.Empty)                   # loop over a producer Queue
             iter_except(s.pop, KeyError)                             # non-blocking set iterator

         """
         try:
             if first is not None:
                 yield first()            # For database APIs needing an initial cast to db.first()
             while True:
                 yield func()
         except exception:
             pass

     def first_true(iterable, default=False, pred=None):
         """Returns the first true value in the iterable.

         If no true value is found, returns *default*

         If *pred* is not None, returns the first item
         for which pred(item) is true.

         """
         # first_true([a,b,c], x) --> a or b or c or x
         # first_true([a,b], x, f) --> a if f(a) else b if f(b) else x
         return next(filter(pred, iterable), default)

     def random_product(*args, repeat=1):
         "Random selection from itertools.product(*args, **kwds)"
         pools = [tuple(pool) for pool in args] * repeat
         return tuple(random.choice(pool) for pool in pools)

     def random_permutation(iterable, r=None):
         "Random selection from itertools.permutations(iterable, r)"
         pool = tuple(iterable)
         r = len(pool) if r is None else r
         return tuple(random.sample(pool, r))

     def random_combination(iterable, r):
         "Random selection from itertools.combinations(iterable, r)"
         pool = tuple(iterable)
         n = len(pool)
         indices = sorted(random.sample(range(n), r))
         return tuple(pool[i] for i in indices)

     def random_combination_with_replacement(iterable, r):
         "Random selection from itertools.combinations_with_replacement(iterable, r)"
         pool = tuple(iterable)
         n = len(pool)
         indices = sorted(random.randrange(n) for i in range(r))
         return tuple(pool[i] for i in indices)

Note, many of the above recipes can be optimized by replacing global
lookups with local variables defined as default values.  For example,
the `dotproduct' recipe can be written as:

     def dotproduct(vec1, vec2, sum=sum, map=map, mul=operator.mul):
         return sum(map(mul, vec1, vec2))


File: python.info,  Node: functools --- Higher-order functions and operations on callable objects,  Next: operator --- Standard operators as functions,  Prev: itertools --- Functions creating iterators for efficient looping,  Up: Functional Programming Modules

5.10.2 ‘functools’ — Higher-order functions and operations on callable objects
------------------------------------------------------------------------------

`Source code:' Lib/functools.py(1)

__________________________________________________________________

The *note functools: 84. module is for higher-order functions: functions
that act on or return other functions.  In general, any callable object
can be treated as a function for the purposes of this module.

The *note functools: 84. module defines the following functions:

 -- Function: functools.cmp_to_key (func)

     Transform an old-style comparison function to a *note key function:
     293.  Used with tools that accept key functions (such as *note
     sorted(): 84e, *note min(): 3f9, *note max(): 3fa, *note
     heapq.nlargest(): 130c, *note heapq.nsmallest(): 130d, *note
     itertools.groupby(): 14ca.).  This function is primarily used as a
     transition tool for programs being converted from Python 2 which
     supported the use of comparison functions.

     A comparison function is any callable that accept two arguments,
     compares them, and returns a negative number for less-than, zero
     for equality, or a positive number for greater-than.  A key
     function is a callable that accepts one argument and returns
     another value to be used as the sort key.

     Example:

          sorted(iterable, key=cmp_to_key(locale.strcoll))  # locale-aware sort order

     For sorting examples and a brief sorting tutorial, see *note
     Sorting HOW TO: fb8.

     New in version 3.2.

 -- Function: @functools.lru_cache (maxsize=128, typed=False)

     Decorator to wrap a function with a memoizing callable that saves
     up to the `maxsize' most recent calls.  It can save time when an
     expensive or I/O bound function is periodically called with the
     same arguments.

     Since a dictionary is used to cache results, the positional and
     keyword arguments to the function must be hashable.

     If `maxsize' is set to None, the LRU feature is disabled and the
     cache can grow without bound.  The LRU feature performs best when
     `maxsize' is a power-of-two.

     If `typed' is set to True, function arguments of different types
     will be cached separately.  For example, ‘f(3)’ and ‘f(3.0)’ will
     be treated as distinct calls with distinct results.

     To help measure the effectiveness of the cache and tune the
     `maxsize' parameter, the wrapped function is instrumented with a
     ‘cache_info()’ function that returns a *note named tuple: 787.
     showing `hits', `misses', `maxsize' and `currsize'.  In a
     multi-threaded environment, the hits and misses are approximate.

     The decorator also provides a ‘cache_clear()’ function for clearing
     or invalidating the cache.

     The original underlying function is accessible through the
     ‘__wrapped__’ attribute.  This is useful for introspection, for
     bypassing the cache, or for rewrapping the function with a
     different cache.

     An LRU (least recently used) cache(2) works best when the most
     recent calls are the best predictors of upcoming calls (for
     example, the most popular articles on a news server tend to change
     each day).  The cache’s size limit assures that the cache does not
     grow without bound on long-running processes such as web servers.

     Example of an LRU cache for static web content:

          @lru_cache(maxsize=32)
          def get_pep(num):
              'Retrieve text of a Python Enhancement Proposal'
              resource = 'http://www.python.org/dev/peps/pep-%04d/' % num
              try:
                  with urllib.request.urlopen(resource) as s:
                      return s.read()
              except urllib.error.HTTPError:
                  return 'Not Found'

          >>> for n in 8, 290, 308, 320, 8, 218, 320, 279, 289, 320, 9991:
          ...     pep = get_pep(n)
          ...     print(n, len(pep))

          >>> get_pep.cache_info()
          CacheInfo(hits=3, misses=8, maxsize=32, currsize=8)

     Example of efficiently computing Fibonacci numbers(3) using a cache
     to implement a dynamic programming(4) technique:

          @lru_cache(maxsize=None)
          def fib(n):
              if n < 2:
                  return n
              return fib(n-1) + fib(n-2)

          >>> [fib(n) for n in range(16)]
          [0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610]

          >>> fib.cache_info()
          CacheInfo(hits=28, misses=16, maxsize=None, currsize=16)

     New in version 3.2.

     Changed in version 3.3: Added the `typed' option.

 -- Function: @functools.total_ordering

     Given a class defining one or more rich comparison ordering
     methods, this class decorator supplies the rest.  This simplifies
     the effort involved in specifying all of the possible rich
     comparison operations:

     The class must define one of *note __lt__(): 899, *note __le__():
     913, *note __gt__(): 914, or *note __ge__(): 915.  In addition, the
     class should supply an *note __eq__(): 89a. method.

     For example:

          @total_ordering
          class Student:
              def _is_valid_operand(self, other):
                  return (hasattr(other, "lastname") and
                          hasattr(other, "firstname"))
              def __eq__(self, other):
                  if not self._is_valid_operand(other):
                      return NotImplemented
                  return ((self.lastname.lower(), self.firstname.lower()) ==
                          (other.lastname.lower(), other.firstname.lower()))
              def __lt__(self, other):
                  if not self._is_valid_operand(other):
                      return NotImplemented
                  return ((self.lastname.lower(), self.firstname.lower()) <
                          (other.lastname.lower(), other.firstname.lower()))

          Note: While this decorator makes it easy to create well
          behaved totally ordered types, it `does' come at the cost of
          slower execution and more complex stack traces for the derived
          comparison methods.  If performance benchmarking indicates
          this is a bottleneck for a given application, implementing all
          six rich comparison methods instead is likely to provide an
          easy speed boost.

     New in version 3.2.

     Changed in version 3.4: Returning NotImplemented from the
     underlying comparison function for unrecognised types is now
     supported.

 -- Function: functools.partial (func, *args, **keywords)

     Return a new *note partial: 3b7. object which when called will
     behave like `func' called with the positional arguments `args' and
     keyword arguments `keywords'.  If more arguments are supplied to
     the call, they are appended to `args'.  If additional keyword
     arguments are supplied, they extend and override `keywords'.
     Roughly equivalent to:

          def partial(func, *args, **keywords):
              def newfunc(*fargs, **fkeywords):
                  newkeywords = keywords.copy()
                  newkeywords.update(fkeywords)
                  return func(*(args + fargs), **newkeywords)
              newfunc.func = func
              newfunc.args = args
              newfunc.keywords = keywords
              return newfunc

     The *note partial(): 3b7. is used for partial function application
     which "freezes" some portion of a function’s arguments and/or
     keywords resulting in a new object with a simplified signature.
     For example, *note partial(): 3b7. can be used to create a callable
     that behaves like the *note int(): 227. function where the `base'
     argument defaults to two:

          >>> from functools import partial
          >>> basetwo = partial(int, base=2)
          >>> basetwo.__doc__ = 'Convert base 2 string to an int.'
          >>> basetwo('10010')
          18

 -- Class: functools.partialmethod (func, *args, **keywords)

     Return a new *note partialmethod: 43e. descriptor which behaves
     like *note partial: 3b7. except that it is designed to be used as a
     method definition rather than being directly callable.

     `func' must be a *note descriptor: 14d4. or a callable (objects
     which are both, like normal functions, are handled as descriptors).

     When `func' is a descriptor (such as a normal Python function,
     *note classmethod(): 5f4, *note staticmethod(): 5f6,
     ‘abstractmethod()’ or another instance of *note partialmethod:
     43e.), calls to ‘__get__’ are delegated to the underlying
     descriptor, and an appropriate *note partial: 3b7. object returned
     as the result.

     When `func' is a non-descriptor callable, an appropriate bound
     method is created dynamically.  This behaves like a normal Python
     function when used as a method: the `self' argument will be
     inserted as the first positional argument, even before the `args'
     and `keywords' supplied to the *note partialmethod: 43e.
     constructor.

     Example:

          >>> class Cell(object):
          ...     def __init__(self):
          ...         self._alive = False
          ...     @property
          ...     def alive(self):
          ...         return self._alive
          ...     def set_state(self, state):
          ...         self._alive = bool(state)
          ...     set_alive = partialmethod(set_state, True)
          ...     set_dead = partialmethod(set_state, False)
          ...
          >>> c = Cell()
          >>> c.alive
          False
          >>> c.set_alive()
          >>> c.alive
          True

     New in version 3.4.

 -- Function: functools.reduce (function, iterable[, initializer])

     Apply `function' of two arguments cumulatively to the items of
     `sequence', from left to right, so as to reduce the sequence to a
     single value.  For example, ‘reduce(lambda x, y: x+y, [1, 2, 3, 4,
     5])’ calculates ‘((((1+2)+3)+4)+5)’.  The left argument, `x', is
     the accumulated value and the right argument, `y', is the update
     value from the `sequence'.  If the optional `initializer' is
     present, it is placed before the items of the sequence in the
     calculation, and serves as a default when the sequence is empty.
     If `initializer' is not given and `sequence' contains only one
     item, the first item is returned.

     Roughly equivalent to:

          def reduce(function, iterable, initializer=None):
              it = iter(iterable)
              if initializer is None:
                  value = next(it)
              else:
                  value = initializer
              for element in it:
                  value = function(value, element)
              return value

 -- Function: @functools.singledispatch (default)

     Transforms a function into a *note single-dispatch: 14d5. *note
     generic function: 14d6.

     To define a generic function, decorate it with the
     ‘@singledispatch’ decorator.  Note that the dispatch happens on the
     type of the first argument, create your function accordingly:

          >>> from functools import singledispatch
          >>> @singledispatch
          ... def fun(arg, verbose=False):
          ...     if verbose:
          ...         print("Let me just say,", end=" ")
          ...     print(arg)

     To add overloaded implementations to the function, use the
     ‘register()’ attribute of the generic function.  It is a decorator,
     taking a type parameter and decorating a function implementing the
     operation for that type:

          >>> @fun.register(int)
          ... def _(arg, verbose=False):
          ...     if verbose:
          ...         print("Strength in numbers, eh?", end=" ")
          ...     print(arg)
          ...
          >>> @fun.register(list)
          ... def _(arg, verbose=False):
          ...     if verbose:
          ...         print("Enumerate this:")
          ...     for i, elem in enumerate(arg):
          ...         print(i, elem)

     To enable registering lambdas and pre-existing functions, the
     ‘register()’ attribute can be used in a functional form:

          >>> def nothing(arg, verbose=False):
          ...     print("Nothing.")
          ...
          >>> fun.register(type(None), nothing)

     The ‘register()’ attribute returns the undecorated function which
     enables decorator stacking, pickling, as well as creating unit
     tests for each variant independently:

          >>> @fun.register(float)
          ... @fun.register(Decimal)
          ... def fun_num(arg, verbose=False):
          ...     if verbose:
          ...         print("Half of your number:", end=" ")
          ...     print(arg / 2)
          ...
          >>> fun_num is fun
          False

     When called, the generic function dispatches on the type of the
     first argument:

          >>> fun("Hello, world.")
          Hello, world.
          >>> fun("test.", verbose=True)
          Let me just say, test.
          >>> fun(42, verbose=True)
          Strength in numbers, eh? 42
          >>> fun(['spam', 'spam', 'eggs', 'spam'], verbose=True)
          Enumerate this:
          0 spam
          1 spam
          2 eggs
          3 spam
          >>> fun(None)
          Nothing.
          >>> fun(1.23)
          0.615

     Where there is no registered implementation for a specific type,
     its method resolution order is used to find a more generic
     implementation.  The original function decorated with
     ‘@singledispatch’ is registered for the base ‘object’ type, which
     means it is used if no better implementation is found.

     To check which implementation will the generic function choose for
     a given type, use the ‘dispatch()’ attribute:

          >>> fun.dispatch(float)
          <function fun_num at 0x1035a2840>
          >>> fun.dispatch(dict)    # note: default implementation
          <function fun at 0x103fe0000>

     To access all registered implementations, use the read-only
     ‘registry’ attribute:

          >>> fun.registry.keys()
          dict_keys([<class 'NoneType'>, <class 'int'>, <class 'object'>,
                    <class 'decimal.Decimal'>, <class 'list'>,
                    <class 'float'>])
          >>> fun.registry[float]
          <function fun_num at 0x1035a2840>
          >>> fun.registry[object]
          <function fun at 0x103fe0000>

     New in version 3.4.

 -- Function: functools.update_wrapper (wrapper, wrapped,
          assigned=WRAPPER_ASSIGNMENTS, updated=WRAPPER_UPDATES)

     Update a `wrapper' function to look like the `wrapped' function.
     The optional arguments are tuples to specify which attributes of
     the original function are assigned directly to the matching
     attributes on the wrapper function and which attributes of the
     wrapper function are updated with the corresponding attributes from
     the original function.  The default values for these arguments are
     the module level constants ‘WRAPPER_ASSIGNMENTS’ (which assigns to
     the wrapper function’s ‘__module__’, ‘__name__’, ‘__qualname__’,
     ‘__annotations__’ and ‘__doc__’, the documentation string) and
     ‘WRAPPER_UPDATES’ (which updates the wrapper function’s ‘__dict__’,
     i.e.  the instance dictionary).

     To allow access to the original function for introspection and
     other purposes (e.g.  bypassing a caching decorator such as *note
     lru_cache(): 1c1.), this function automatically adds a
     ‘__wrapped__’ attribute to the wrapper that refers to the function
     being wrapped.

     The main intended use for this function is in *note decorator: f6c.
     functions which wrap the decorated function and return the wrapper.
     If the wrapper function is not updated, the metadata of the
     returned function will reflect the wrapper definition rather than
     the original function definition, which is typically less than
     helpful.

     *note update_wrapper(): 572. may be used with callables other than
     functions.  Any attributes named in `assigned' or `updated' that
     are missing from the object being wrapped are ignored (i.e.  this
     function will not attempt to set them on the wrapper function).
     *note AttributeError: 356. is still raised if the wrapper function
     itself is missing any attributes named in `updated'.

     New in version 3.2: Automatic addition of the ‘__wrapped__’
     attribute.

     New in version 3.2: Copying of the ‘__annotations__’ attribute by
     default.

     Changed in version 3.2: Missing attributes no longer trigger an
     *note AttributeError: 356.

     Changed in version 3.4: The ‘__wrapped__’ attribute now always
     refers to the wrapped function, even if that function defined a
     ‘__wrapped__’ attribute.  (see issue 17482(5))

 -- Function: @functools.wraps (wrapped, assigned=WRAPPER_ASSIGNMENTS,
          updated=WRAPPER_UPDATES)

     This is a convenience function for invoking *note update_wrapper():
     572. as a function decorator when defining a wrapper function.  It
     is equivalent to ‘partial(update_wrapper, wrapped=wrapped,
     assigned=assigned, updated=updated)’.  For example:

          >>> from functools import wraps
          >>> def my_decorator(f):
          ...     @wraps(f)
          ...     def wrapper(*args, **kwds):
          ...         print('Calling decorated function')
          ...         return f(*args, **kwds)
          ...     return wrapper
          ...
          >>> @my_decorator
          ... def example():
          ...     """Docstring"""
          ...     print('Called example function')
          ...
          >>> example()
          Calling decorated function
          Called example function
          >>> example.__name__
          'example'
          >>> example.__doc__
          'Docstring'

     Without the use of this decorator factory, the name of the example
     function would have been ‘'wrapper'’, and the docstring of the
     original ‘example()’ would have been lost.

* Menu:

* partial Objects:: 

   ---------- Footnotes ----------

   (1) https://hg.python.org/cpython/file/default/Lib/functools.py

   (2) https://en.wikipedia.org/wiki/Cache_algorithms#Examples

   (3) https://en.wikipedia.org/wiki/Fibonacci_number

   (4) https://en.wikipedia.org/wiki/Dynamic_programming

   (5) https://bugs.python.org/issue17482


File: python.info,  Node: partial Objects,  Up: functools --- Higher-order functions and operations on callable objects

5.10.2.1 ‘partial’ Objects
..........................

*note partial: 3b7. objects are callable objects created by *note
partial(): 3b7.  They have three read-only attributes:

 -- Attribute: partial.func

     A callable object or function.  Calls to the *note partial: 3b7.
     object will be forwarded to *note func: 14d9. with new arguments
     and keywords.

 -- Attribute: partial.args

     The leftmost positional arguments that will be prepended to the
     positional arguments provided to a *note partial: 3b7. object call.

 -- Attribute: partial.keywords

     The keyword arguments that will be supplied when the *note partial:
     3b7. object is called.

*note partial: 3b7. objects are like ‘function’ objects in that they are
callable, weak referencable, and can have attributes.  There are some
important differences.  For instance, the *note __name__: 8d3. and
‘__doc__’ attributes are not created automatically.  Also, *note
partial: 3b7. objects defined in classes behave like static methods and
do not transform into bound methods during instance attribute look-up.


File: python.info,  Node: operator --- Standard operators as functions,  Prev: functools --- Higher-order functions and operations on callable objects,  Up: Functional Programming Modules

5.10.3 ‘operator’ — Standard operators as functions
---------------------------------------------------

`Source code:' Lib/operator.py(1)

__________________________________________________________________

The *note operator: c0. module exports a set of efficient functions
corresponding to the intrinsic operators of Python.  For example,
‘operator.add(x, y)’ is equivalent to the expression ‘x+y’.  The
function names are those used for special class methods; variants
without leading and trailing ‘__’ are also provided for convenience.

The functions fall into categories that perform object comparisons,
logical operations, mathematical operations and sequence operations.

The object comparison functions are useful for all objects, and are
named after the rich comparison operators they support:

 -- Function: operator.lt (a, b)
 -- Function: operator.le (a, b)
 -- Function: operator.eq (a, b)
 -- Function: operator.ne (a, b)
 -- Function: operator.ge (a, b)
 -- Function: operator.gt (a, b)
 -- Function: operator.__lt__ (a, b)
 -- Function: operator.__le__ (a, b)
 -- Function: operator.__eq__ (a, b)
 -- Function: operator.__ne__ (a, b)
 -- Function: operator.__ge__ (a, b)
 -- Function: operator.__gt__ (a, b)

     Perform "rich comparisons" between `a' and `b'.  Specifically,
     ‘lt(a, b)’ is equivalent to ‘a < b’, ‘le(a, b)’ is equivalent to ‘a
     <= b’, ‘eq(a, b)’ is equivalent to ‘a == b’, ‘ne(a, b)’ is
     equivalent to ‘a != b’, ‘gt(a, b)’ is equivalent to ‘a > b’ and
     ‘ge(a, b)’ is equivalent to ‘a >= b’.  Note that these functions
     can return any value, which may or may not be interpretable as a
     Boolean value.  See *note Comparisons: efc. for more information
     about rich comparisons.

The logical operations are also generally applicable to all objects, and
support truth tests, identity tests, and boolean operations:

 -- Function: operator.not_ (obj)
 -- Function: operator.__not__ (obj)

     Return the outcome of *note not: f08. `obj'.  (Note that there is
     no *note __not__(): 14eb. method for object instances; only the
     interpreter core defines this operation.  The result is affected by
     the *note __bool__(): 8d4. and *note __len__(): a47. methods.)

 -- Function: operator.truth (obj)

     Return *note True: 9ff. if `obj' is true, and *note False: 60d.
     otherwise.  This is equivalent to using the *note bool: a72.
     constructor.

 -- Function: operator.is_ (a, b)

     Return ‘a is b’.  Tests object identity.

 -- Function: operator.is_not (a, b)

     Return ‘a is not b’.  Tests object identity.

The mathematical and bitwise operations are the most numerous:

 -- Function: operator.abs (obj)
 -- Function: operator.__abs__ (obj)

     Return the absolute value of `obj'.

 -- Function: operator.add (a, b)
 -- Function: operator.__add__ (a, b)

     Return ‘a + b’, for `a' and `b' numbers.

 -- Function: operator.and_ (a, b)
 -- Function: operator.__and__ (a, b)

     Return the bitwise and of `a' and `b'.

 -- Function: operator.floordiv (a, b)
 -- Function: operator.__floordiv__ (a, b)

     Return ‘a // b’.

 -- Function: operator.index (a)
 -- Function: operator.__index__ (a)

     Return `a' converted to an integer.  Equivalent to ‘a.__index__()’.

 -- Function: operator.inv (obj)
 -- Function: operator.invert (obj)
 -- Function: operator.__inv__ (obj)
 -- Function: operator.__invert__ (obj)

     Return the bitwise inverse of the number `obj'.  This is equivalent
     to ‘~obj’.

 -- Function: operator.lshift (a, b)
 -- Function: operator.__lshift__ (a, b)

     Return `a' shifted left by `b'.

 -- Function: operator.mod (a, b)
 -- Function: operator.__mod__ (a, b)

     Return ‘a % b’.

 -- Function: operator.mul (a, b)
 -- Function: operator.__mul__ (a, b)

     Return ‘a * b’, for `a' and `b' numbers.

 -- Function: operator.matmul (a, b)
 -- Function: operator.__matmul__ (a, b)

     Return ‘a @ b’.

     New in version 3.5.

 -- Function: operator.neg (obj)
 -- Function: operator.__neg__ (obj)

     Return `obj' negated (‘-obj’).

 -- Function: operator.or_ (a, b)
 -- Function: operator.__or__ (a, b)

     Return the bitwise or of `a' and `b'.

 -- Function: operator.pos (obj)
 -- Function: operator.__pos__ (obj)

     Return `obj' positive (‘+obj’).

 -- Function: operator.pow (a, b)
 -- Function: operator.__pow__ (a, b)

     Return ‘a ** b’, for `a' and `b' numbers.

 -- Function: operator.rshift (a, b)
 -- Function: operator.__rshift__ (a, b)

     Return `a' shifted right by `b'.

 -- Function: operator.sub (a, b)
 -- Function: operator.__sub__ (a, b)

     Return ‘a - b’.

 -- Function: operator.truediv (a, b)
 -- Function: operator.__truediv__ (a, b)

     Return ‘a / b’ where 2/3 is .66 rather than 0.  This is also known
     as "true" division.

 -- Function: operator.xor (a, b)
 -- Function: operator.__xor__ (a, b)

     Return the bitwise exclusive or of `a' and `b'.

Operations which work with sequences (some of them with mappings too)
include:

 -- Function: operator.concat (a, b)
 -- Function: operator.__concat__ (a, b)

     Return ‘a + b’ for `a' and `b' sequences.

 -- Function: operator.contains (a, b)
 -- Function: operator.__contains__ (a, b)

     Return the outcome of the test ‘b in a’.  Note the reversed
     operands.

 -- Function: operator.countOf (a, b)

     Return the number of occurrences of `b' in `a'.

 -- Function: operator.delitem (a, b)
 -- Function: operator.__delitem__ (a, b)

     Remove the value of `a' at index `b'.

 -- Function: operator.getitem (a, b)
 -- Function: operator.__getitem__ (a, b)

     Return the value of `a' at index `b'.

 -- Function: operator.indexOf (a, b)

     Return the index of the first of occurrence of `b' in `a'.

 -- Function: operator.setitem (a, b, c)
 -- Function: operator.__setitem__ (a, b, c)

     Set the value of `a' at index `b' to `c'.

 -- Function: operator.length_hint (obj, default=0)

     Return an estimated length for the object `o'.  First try to return
     its actual length, then an estimate using *note
     object.__length_hint__(): 3fc, and finally return the default
     value.

     New in version 3.4.

The *note operator: c0. module also defines tools for generalized
attribute and item lookups.  These are useful for making fast field
extractors as arguments for *note map(): 892, *note sorted(): 84e, *note
itertools.groupby(): 14ca, or other functions that expect a function
argument.

 -- Function: operator.attrgetter (attr)

 -- Function: operator.attrgetter (*attrs)

     Return a callable object that fetches `attr' from its operand.  If
     more than one attribute is requested, returns a tuple of
     attributes.  The attribute names can also contain dots.  For
     example:

        * After ‘f = attrgetter('name')’, the call ‘f(b)’ returns
          ‘b.name’.

        * After ‘f = attrgetter('name', 'date')’, the call ‘f(b)’
          returns ‘(b.name, b.date)’.

        * After ‘f = attrgetter('name.first', 'name.last')’, the call
          ‘f(b)’ returns ‘(b.name.first, b.name.last)’.

     Equivalent to:

          def attrgetter(*items):
              if any(not isinstance(item, str) for item in items):
                  raise TypeError('attribute name must be a string')
              if len(items) == 1:
                  attr = items[0]
                  def g(obj):
                      return resolve_attr(obj, attr)
              else:
                  def g(obj):
                      return tuple(resolve_attr(obj, attr) for attr in items)
              return g

          def resolve_attr(obj, attr):
              for name in attr.split("."):
                  obj = getattr(obj, name)
              return obj

 -- Function: operator.itemgetter (item)

 -- Function: operator.itemgetter (*items)

     Return a callable object that fetches `item' from its operand using
     the operand’s *note __getitem__(): 151a. method.  If multiple items
     are specified, returns a tuple of lookup values.  For example:

        * After ‘f = itemgetter(2)’, the call ‘f(r)’ returns ‘r[2]’.

        * After ‘g = itemgetter(2, 5, 3)’, the call ‘g(r)’ returns
          ‘(r[2], r[5], r[3])’.

     Equivalent to:

          def itemgetter(*items):
              if len(items) == 1:
                  item = items[0]
                  def g(obj):
                      return obj[item]
              else:
                  def g(obj):
                      return tuple(obj[item] for item in items)
              return g

     The items can be any type accepted by the operand’s *note
     __getitem__(): 151a. method.  Dictionaries accept any hashable
     value.  Lists, tuples, and strings accept an index or a slice:

          >>> itemgetter(1)('ABCDEFG')
          'B'
          >>> itemgetter(1,3,5)('ABCDEFG')
          ('B', 'D', 'F')
          >>> itemgetter(slice(2,None))('ABCDEFG')
          'CDEFG'

     Example of using *note itemgetter(): 2d8. to retrieve specific
     fields from a tuple record:

          >>> inventory = [('apple', 3), ('banana', 2), ('pear', 5), ('orange', 1)]
          >>> getcount = itemgetter(1)
          >>> list(map(getcount, inventory))
          [3, 2, 5, 1]
          >>> sorted(inventory, key=getcount)
          [('orange', 1), ('banana', 2), ('apple', 3), ('pear', 5)]

 -- Function: operator.methodcaller (name[, args...])

     Return a callable object that calls the method `name' on its
     operand.  If additional arguments and/or keyword arguments are
     given, they will be given to the method as well.  For example:

        * After ‘f = methodcaller('name')’, the call ‘f(b)’ returns
          ‘b.name()’.

        * After ‘f = methodcaller('name', 'foo', bar=1)’, the call
          ‘f(b)’ returns ‘b.name('foo', bar=1)’.

     Equivalent to:

          def methodcaller(name, *args, **kwargs):
              def caller(obj):
                  return getattr(obj, name)(*args, **kwargs)
              return caller

* Menu:

* Mapping Operators to Functions:: 
* Inplace Operators:: 

   ---------- Footnotes ----------

   (1) https://hg.python.org/cpython/file/default/Lib/operator.py


File: python.info,  Node: Mapping Operators to Functions,  Next: Inplace Operators,  Up: operator --- Standard operators as functions

5.10.3.1 Mapping Operators to Functions
.......................................

This table shows how abstract operations correspond to operator symbols
in the Python syntax and the functions in the *note operator: c0.
module.

Operation                   Syntax                        Function
                                                          
------------------------------------------------------------------------------------------------------
                                                          
Addition                    ‘a + b’                       ‘add(a, b)’
                                                          
                                                          
Concatenation               ‘seq1 + seq2’                 ‘concat(seq1, seq2)’
                                                          
                                                          
Containment Test            ‘obj in seq’                  ‘contains(seq, obj)’
                                                          
                                                          
Division                    ‘a / b’                       ‘truediv(a, b)’
                                                          
                                                          
Division                    ‘a // b’                      ‘floordiv(a, b)’
                                                          
                                                          
Bitwise And                 ‘a & b’                       ‘and_(a, b)’
                                                          
                                                          
Bitwise Exclusive Or        ‘a ^ b’                       ‘xor(a, b)’
                                                          
                                                          
Bitwise Inversion           ‘~ a’                         ‘invert(a)’
                                                          
                                                          
Bitwise Or                  ‘a | b’                       ‘or_(a, b)’
                                                          
                                                          
Exponentiation              ‘a ** b’                      ‘pow(a, b)’
                                                          
                                                          
Identity                    ‘a is b’                      ‘is_(a, b)’
                                                          
                                                          
Identity                    ‘a is not b’                  ‘is_not(a, b)’
                                                          
                                                          
Indexed Assignment          ‘obj[k] = v’                  ‘setitem(obj, k, v)’
                                                          
                                                          
Indexed Deletion            ‘del obj[k]’                  ‘delitem(obj, k)’
                                                          
                                                          
Indexing                    ‘obj[k]’                      ‘getitem(obj, k)’
                                                          
                                                          
Left Shift                  ‘a << b’                      ‘lshift(a, b)’
                                                          
                                                          
Modulo                      ‘a % b’                       ‘mod(a, b)’
                                                          
                                                          
Multiplication              ‘a * b’                       ‘mul(a, b)’
                                                          
                                                          
Matrix Multiplication       ‘a @ b’                       ‘matmul(a, b)’
                                                          
                                                          
Negation (Arithmetic)       ‘- a’                         ‘neg(a)’
                                                          
                                                          
Negation (Logical)          ‘not a’                       ‘not_(a)’
                                                          
                                                          
Positive                    ‘+ a’                         ‘pos(a)’
                                                          
                                                          
Right Shift                 ‘a >> b’                      ‘rshift(a, b)’
                                                          
                                                          
Slice Assignment            ‘seq[i:j] = values’           ‘setitem(seq, slice(i, j), values)’
                                                          
                                                          
Slice Deletion              ‘del seq[i:j]’                ‘delitem(seq, slice(i, j))’
                                                          
                                                          
Slicing                     ‘seq[i:j]’                    ‘getitem(seq, slice(i, j))’
                                                          
                                                          
String Formatting           ‘s % obj’                     ‘mod(s, obj)’
                                                          
                                                          
Subtraction                 ‘a - b’                       ‘sub(a, b)’
                                                          
                                                          
Truth Test                  ‘obj’                         ‘truth(obj)’
                                                          
                                                          
Ordering                    ‘a < b’                       ‘lt(a, b)’
                                                          
                                                          
Ordering                    ‘a <= b’                      ‘le(a, b)’
                                                          
                                                          
Equality                    ‘a == b’                      ‘eq(a, b)’
                                                          
                                                          
Difference                  ‘a != b’                      ‘ne(a, b)’
                                                          
                                                          
Ordering                    ‘a >= b’                      ‘ge(a, b)’
                                                          
                                                          
Ordering                    ‘a > b’                       ‘gt(a, b)’
                                                          


File: python.info,  Node: Inplace Operators,  Prev: Mapping Operators to Functions,  Up: operator --- Standard operators as functions

5.10.3.2 Inplace Operators
..........................

Many operations have an "in-place" version.  Listed below are functions
providing a more primitive access to in-place operators than the usual
syntax does; for example, the *note statement: 1521. ‘x += y’ is
equivalent to ‘x = operator.iadd(x, y)’.  Another way to put it is to
say that ‘z = operator.iadd(x, y)’ is equivalent to the compound
statement ‘z = x; z += y’.

In those examples, note that when an in-place method is called, the
computation and assignment are performed in two separate steps.  The
in-place functions listed below only do the first step, calling the
in-place method.  The second step, assignment, is not handled.

For immutable targets such as strings, numbers, and tuples, the updated
value is computed, but not assigned back to the input variable:

     >>> a = 'hello'
     >>> iadd(a, ' world')
     'hello world'
     >>> a
     'hello'

For mutable targets such as lists and dictionaries, the inplace method
will perform the update, so no subsequent assignment is necessary:

     >>> s = ['h', 'e', 'l', 'l', 'o']
     >>> iadd(s, [' ', 'w', 'o', 'r', 'l', 'd'])
     ['h', 'e', 'l', 'l', 'o', ' ', 'w', 'o', 'r', 'l', 'd']
     >>> s
     ['h', 'e', 'l', 'l', 'o', ' ', 'w', 'o', 'r', 'l', 'd']

 -- Function: operator.iadd (a, b)
 -- Function: operator.__iadd__ (a, b)

     ‘a = iadd(a, b)’ is equivalent to ‘a += b’.

 -- Function: operator.iand (a, b)
 -- Function: operator.__iand__ (a, b)

     ‘a = iand(a, b)’ is equivalent to ‘a &= b’.

 -- Function: operator.iconcat (a, b)
 -- Function: operator.__iconcat__ (a, b)

     ‘a = iconcat(a, b)’ is equivalent to ‘a += b’ for `a' and `b'
     sequences.

 -- Function: operator.ifloordiv (a, b)
 -- Function: operator.__ifloordiv__ (a, b)

     ‘a = ifloordiv(a, b)’ is equivalent to ‘a //= b’.

 -- Function: operator.ilshift (a, b)
 -- Function: operator.__ilshift__ (a, b)

     ‘a = ilshift(a, b)’ is equivalent to ‘a <<= b’.

 -- Function: operator.imod (a, b)
 -- Function: operator.__imod__ (a, b)

     ‘a = imod(a, b)’ is equivalent to ‘a %= b’.

 -- Function: operator.imul (a, b)
 -- Function: operator.__imul__ (a, b)

     ‘a = imul(a, b)’ is equivalent to ‘a *= b’.

 -- Function: operator.imatmul (a, b)
 -- Function: operator.__imatmul__ (a, b)

     ‘a = imatmul(a, b)’ is equivalent to ‘a @= b’.

     New in version 3.5.

 -- Function: operator.ior (a, b)
 -- Function: operator.__ior__ (a, b)

     ‘a = ior(a, b)’ is equivalent to ‘a |= b’.

 -- Function: operator.ipow (a, b)
 -- Function: operator.__ipow__ (a, b)

     ‘a = ipow(a, b)’ is equivalent to ‘a **= b’.

 -- Function: operator.irshift (a, b)
 -- Function: operator.__irshift__ (a, b)

     ‘a = irshift(a, b)’ is equivalent to ‘a >>= b’.

 -- Function: operator.isub (a, b)
 -- Function: operator.__isub__ (a, b)

     ‘a = isub(a, b)’ is equivalent to ‘a -= b’.

 -- Function: operator.itruediv (a, b)
 -- Function: operator.__itruediv__ (a, b)

     ‘a = itruediv(a, b)’ is equivalent to ‘a /= b’.

 -- Function: operator.ixor (a, b)
 -- Function: operator.__ixor__ (a, b)

     ‘a = ixor(a, b)’ is equivalent to ‘a ^= b’.


File: python.info,  Node: File and Directory Access,  Next: Data Persistence,  Prev: Functional Programming Modules,  Up: The Python Standard Library

5.11 File and Directory Access
==============================

The modules described in this chapter deal with disk files and
directories.  For example, there are modules for reading the properties
of files, manipulating paths in a portable way, and creating temporary
files.  The full list of modules in this chapter is:

* Menu:

* pathlib: pathlib --- Object-oriented filesystem paths. Object-oriented filesystem paths
* os.path: os path --- Common pathname manipulations. Common pathname manipulations
* fileinput: fileinput --- Iterate over lines from multiple input streams. Iterate over lines from multiple input streams
* stat: stat --- Interpreting stat results. Interpreting stat() results
* filecmp: filecmp --- File and Directory Comparisons. File and Directory Comparisons
* tempfile: tempfile --- Generate temporary files and directories. Generate temporary files and directories
* glob: glob --- Unix style pathname pattern expansion. Unix style pathname pattern expansion
* fnmatch: fnmatch --- Unix filename pattern matching. Unix filename pattern matching
* linecache: linecache --- Random access to text lines. Random access to text lines
* shutil: shutil --- High-level file operations. High-level file operations
* macpath: macpath --- Mac OS 9 path manipulation functions. Mac OS 9 path manipulation functions


File: python.info,  Node: pathlib --- Object-oriented filesystem paths,  Next: os path --- Common pathname manipulations,  Up: File and Directory Access

5.11.1 ‘pathlib’ — Object-oriented filesystem paths
---------------------------------------------------

New in version 3.4.

This module offers classes representing filesystem paths with semantics
appropriate for different operating systems.  Path classes are divided
between *note pure paths: 1542, which provide purely computational
operations without I/O, and *note concrete paths: 1543, which inherit
from pure paths but also provide I/O operations.

 [image src="pathlib-inheritance.png" ]

If you’ve never used this module before or just aren’t sure which class
is right for your task, *note Path: 2e8. is most likely what you need.
It instantiates a *note concrete path: 1543. for the platform the code
is running on.

Pure paths are useful in some special cases; for example:

  1. If you want to manipulate Windows paths on a Unix machine (or vice
     versa).  You cannot instantiate a *note WindowsPath: 1544. when
     running on Unix, but you can instantiate *note PureWindowsPath:
     1545.

  2. You want to make sure that your code only manipulates paths without
     actually accessing the OS. In this case, instantiating one of the
     pure classes may be useful since those simply don’t have any
     OS-accessing operations.

     Note: This module has been included in the standard library on a
     *note provisional basis: 59d.  Backwards incompatible changes (up
     to and including removal of the package) may occur if deemed
     necessary by the core developers.

See also
........

PEP 428(1): The pathlib module – object-oriented filesystem paths.

See also
........

For low-level path manipulation on strings, you can also use the *note
os.path: c3. module.

* Menu:

* Basic use:: 
* Pure paths:: 
* Concrete paths:: 

   ---------- Footnotes ----------

   (1) https://www.python.org/dev/peps/pep-0428


File: python.info,  Node: Basic use,  Next: Pure paths,  Up: pathlib --- Object-oriented filesystem paths

5.11.1.1 Basic use
..................

Importing the main class:

     >>> from pathlib import Path

Listing subdirectories:

     >>> p = Path('.')
     >>> [x for x in p.iterdir() if x.is_dir()]
     [PosixPath('.hg'), PosixPath('docs'), PosixPath('dist'),
      PosixPath('__pycache__'), PosixPath('build')]

Listing Python source files in this directory tree:

     >>> list(p.glob('**/*.py'))
     [PosixPath('test_pathlib.py'), PosixPath('setup.py'),
      PosixPath('pathlib.py'), PosixPath('docs/conf.py'),
      PosixPath('build/lib/pathlib.py')]

Navigating inside a directory tree:

     >>> p = Path('/etc')
     >>> q = p / 'init.d' / 'reboot'
     >>> q
     PosixPath('/etc/init.d/reboot')
     >>> q.resolve()
     PosixPath('/etc/rc.d/init.d/halt')

Querying path properties:

     >>> q.exists()
     True
     >>> q.is_dir()
     False

Opening a file:

     >>> with q.open() as f: f.readline()
     ...
     '#!/bin/bash\n'


File: python.info,  Node: Pure paths,  Next: Concrete paths,  Prev: Basic use,  Up: pathlib --- Object-oriented filesystem paths

5.11.1.2 Pure paths
...................

Pure path objects provide path-handling operations which don’t actually
access a filesystem.  There are three ways to access these classes,
which we also call `flavours':

 -- Class: pathlib.PurePath (*pathsegments)

     A generic class that represents the system’s path flavour
     (instantiating it creates either a *note PurePosixPath: 1549. or a
     *note PureWindowsPath: 1545.):

          >>> PurePath('setup.py')      # Running on a Unix machine
          PurePosixPath('setup.py')

     Each element of `pathsegments' can be either a string representing
     a path segment, or another path object:

          >>> PurePath('foo', 'some/path', 'bar')
          PurePosixPath('foo/some/path/bar')
          >>> PurePath(Path('foo'), Path('bar'))
          PurePosixPath('foo/bar')

     When `pathsegments' is empty, the current directory is assumed:

          >>> PurePath()
          PurePosixPath('.')

     When several absolute paths are given, the last is taken as an
     anchor (mimicking *note os.path.join(): 154a.’s behaviour):

          >>> PurePath('/etc', '/usr', 'lib64')
          PurePosixPath('/usr/lib64')
          >>> PureWindowsPath('c:/Windows', 'd:bar')
          PureWindowsPath('d:bar')

     However, in a Windows path, changing the local root doesn’t discard
     the previous drive setting:

          >>> PureWindowsPath('c:/Windows', '/Program Files')
          PureWindowsPath('c:/Program Files')

     Spurious slashes and single dots are collapsed, but double dots
     (‘'..'’) are not, since this would change the meaning of a path in
     the face of symbolic links:

          >>> PurePath('foo//bar')
          PurePosixPath('foo/bar')
          >>> PurePath('foo/./bar')
          PurePosixPath('foo/bar')
          >>> PurePath('foo/../bar')
          PurePosixPath('foo/../bar')

     (a naïve approach would make ‘PurePosixPath('foo/../bar')’
     equivalent to ‘PurePosixPath('bar')’, which is wrong if ‘foo’ is a
     symbolic link to another directory)

 -- Class: pathlib.PurePosixPath (*pathsegments)

     A subclass of *note PurePath: 1548, this path flavour represents
     non-Windows filesystem paths:

          >>> PurePosixPath('/etc')
          PurePosixPath('/etc')

     `pathsegments' is specified similarly to *note PurePath: 1548.

 -- Class: pathlib.PureWindowsPath (*pathsegments)

     A subclass of *note PurePath: 1548, this path flavour represents
     Windows filesystem paths:

          >>> PureWindowsPath('c:/Program Files/')
          PureWindowsPath('c:/Program Files')

     `pathsegments' is specified similarly to *note PurePath: 1548.

Regardless of the system you’re running on, you can instantiate all of
these classes, since they don’t provide any operation that does system
calls.

* Menu:

* General properties:: 
* Operators: Operators<2>. 
* Accessing individual parts:: 
* Methods and properties:: 


File: python.info,  Node: General properties,  Next: Operators<2>,  Up: Pure paths

5.11.1.3 General properties
...........................

Paths are immutable and hashable.  Paths of a same flavour are
comparable and orderable.  These properties respect the flavour’s
case-folding semantics:

     >>> PurePosixPath('foo') == PurePosixPath('FOO')
     False
     >>> PureWindowsPath('foo') == PureWindowsPath('FOO')
     True
     >>> PureWindowsPath('FOO') in { PureWindowsPath('foo') }
     True
     >>> PureWindowsPath('C:') < PureWindowsPath('d:')
     True

Paths of a different flavour compare unequal and cannot be ordered:

     >>> PureWindowsPath('foo') == PurePosixPath('foo')
     False
     >>> PureWindowsPath('foo') < PurePosixPath('foo')
     Traceback (most recent call last):
       File "<stdin>", line 1, in <module>
     TypeError: '<' not supported between instances of 'PureWindowsPath' and 'PurePosixPath'


File: python.info,  Node: Operators<2>,  Next: Accessing individual parts,  Prev: General properties,  Up: Pure paths

5.11.1.4 Operators
..................

The slash operator helps create child paths, similarly to *note
os.path.join(): 154a.:

     >>> p = PurePath('/etc')
     >>> p
     PurePosixPath('/etc')
     >>> p / 'init.d' / 'apache2'
     PurePosixPath('/etc/init.d/apache2')
     >>> q = PurePath('bin')
     >>> '/usr' / q
     PurePosixPath('/usr/bin')

The string representation of a path is the raw filesystem path itself
(in native form, e.g.  with backslashes under Windows), which you can
pass to any function taking a file path as a string:

     >>> p = PurePath('/etc')
     >>> str(p)
     '/etc'
     >>> p = PureWindowsPath('c:/Program Files')
     >>> str(p)
     'c:\\Program Files'

Similarly, calling *note bytes: 1db. on a path gives the raw filesystem
path as a bytes object, as encoded by *note os.fsencode(): 7ea.:

     >>> bytes(p)
     b'/etc'

     Note: Calling *note bytes: 1db. is only recommended under Unix.
     Under Windows, the unicode form is the canonical representation of
     filesystem paths.


File: python.info,  Node: Accessing individual parts,  Next: Methods and properties,  Prev: Operators<2>,  Up: Pure paths

5.11.1.5 Accessing individual parts
...................................

To access the individual "parts" (components) of a path, use the
following property:

 -- Data: PurePath.parts

     A tuple giving access to the path’s various components:

          >>> p = PurePath('/usr/bin/python3')
          >>> p.parts
          ('/', 'usr', 'bin', 'python3')

          >>> p = PureWindowsPath('c:/Program Files/PSF')
          >>> p.parts
          ('c:\\', 'Program Files', 'PSF')

     (note how the drive and local root are regrouped in a single part)


File: python.info,  Node: Methods and properties,  Prev: Accessing individual parts,  Up: Pure paths

5.11.1.6 Methods and properties
...............................

Pure paths provide the following methods and properties:

 -- Data: PurePath.drive

     A string representing the drive letter or name, if any:

          >>> PureWindowsPath('c:/Program Files/').drive
          'c:'
          >>> PureWindowsPath('/Program Files/').drive
          ''
          >>> PurePosixPath('/etc').drive
          ''

     UNC shares are also considered drives:

          >>> PureWindowsPath('//host/share/foo.txt').drive
          '\\\\host\\share'

 -- Data: PurePath.root

     A string representing the (local or global) root, if any:

          >>> PureWindowsPath('c:/Program Files/').root
          '\\'
          >>> PureWindowsPath('c:Program Files/').root
          ''
          >>> PurePosixPath('/etc').root
          '/'

     UNC shares always have a root:

          >>> PureWindowsPath('//host/share').root
          '\\'

 -- Data: PurePath.anchor

     The concatenation of the drive and root:

          >>> PureWindowsPath('c:/Program Files/').anchor
          'c:\\'
          >>> PureWindowsPath('c:Program Files/').anchor
          'c:'
          >>> PurePosixPath('/etc').anchor
          '/'
          >>> PureWindowsPath('//host/share').anchor
          '\\\\host\\share\\'

 -- Data: PurePath.parents

     An immutable sequence providing access to the logical ancestors of
     the path:

          >>> p = PureWindowsPath('c:/foo/bar/setup.py')
          >>> p.parents[0]
          PureWindowsPath('c:/foo/bar')
          >>> p.parents[1]
          PureWindowsPath('c:/foo')
          >>> p.parents[2]
          PureWindowsPath('c:/')

 -- Data: PurePath.parent

     The logical parent of the path:

          >>> p = PurePosixPath('/a/b/c/d')
          >>> p.parent
          PurePosixPath('/a/b/c')

     You cannot go past an anchor, or empty path:

          >>> p = PurePosixPath('/')
          >>> p.parent
          PurePosixPath('/')
          >>> p = PurePosixPath('.')
          >>> p.parent
          PurePosixPath('.')

          Note: This is a purely lexical operation, hence the following
          behaviour:

               >>> p = PurePosixPath('foo/..')
               >>> p.parent
               PurePosixPath('foo')

          If you want to walk an arbitrary filesystem path upwards, it
          is recommended to first call *note Path.resolve(): 1555. so as
          to resolve symlinks and eliminate ‘".."’ components.

 -- Data: PurePath.name

     A string representing the final path component, excluding the drive
     and root, if any:

          >>> PurePosixPath('my/library/setup.py').name
          'setup.py'

     UNC drive names are not considered:

          >>> PureWindowsPath('//some/share/setup.py').name
          'setup.py'
          >>> PureWindowsPath('//some/share').name
          ''

 -- Data: PurePath.path

     A string representing the full path:

          >>> PurePosixPath('my/library/setup.py').path
          'my/library/setup.py'

     This always returns the same value as ‘str(p)’; it is included to
     serve as a one-off protocol.  Code that wants to support both
     strings and ‘pathlib.Path’ objects as filenames can write ‘arg =
     getattr(arg, 'path', arg)’ to get the path as a string.  This can
     then be passed to various system calls or library functions that
     expect a string.  Unlike the alternative ‘arg = str(arg)’, this
     will still raise an exception if an object of some other type is
     given by accident.

     A nice advantage is that this protocol is also supported by *note
     os.DirEntry: 2dd. objects returned by *note os.scandir(): 164.

     New in version 3.4.5.

     New in version 3.5.2.

 -- Data: PurePath.suffix

     The file extension of the final component, if any:

          >>> PurePosixPath('my/library/setup.py').suffix
          '.py'
          >>> PurePosixPath('my/library.tar.gz').suffix
          '.gz'
          >>> PurePosixPath('my/library').suffix
          ''

 -- Data: PurePath.suffixes

     A list of the path’s file extensions:

          >>> PurePosixPath('my/library.tar.gar').suffixes
          ['.tar', '.gar']
          >>> PurePosixPath('my/library.tar.gz').suffixes
          ['.tar', '.gz']
          >>> PurePosixPath('my/library').suffixes
          []

 -- Data: PurePath.stem

     The final path component, without its suffix:

          >>> PurePosixPath('my/library.tar.gz').stem
          'library.tar'
          >>> PurePosixPath('my/library.tar').stem
          'library'
          >>> PurePosixPath('my/library').stem
          'library'

 -- Method: PurePath.as_posix ()

     Return a string representation of the path with forward slashes
     (‘/’):

          >>> p = PureWindowsPath('c:\\windows')
          >>> str(p)
          'c:\\windows'
          >>> p.as_posix()
          'c:/windows'

 -- Method: PurePath.as_uri ()

     Represent the path as a ‘file’ URI. *note ValueError: 19c. is
     raised if the path isn’t absolute.

          >>> p = PurePosixPath('/etc/passwd')
          >>> p.as_uri()
          'file:///etc/passwd'
          >>> p = PureWindowsPath('c:/Windows')
          >>> p.as_uri()
          'file:///c:/Windows'

 -- Method: PurePath.is_absolute ()

     Return whether the path is absolute or not.  A path is considered
     absolute if it has both a root and (if the flavour allows) a drive:

          >>> PurePosixPath('/a/b').is_absolute()
          True
          >>> PurePosixPath('a/b').is_absolute()
          False

          >>> PureWindowsPath('c:/a/b').is_absolute()
          True
          >>> PureWindowsPath('/a/b').is_absolute()
          False
          >>> PureWindowsPath('c:').is_absolute()
          False
          >>> PureWindowsPath('//some/share').is_absolute()
          True

 -- Method: PurePath.is_reserved ()

     With *note PureWindowsPath: 1545, return ‘True’ if the path is
     considered reserved under Windows, ‘False’ otherwise.  With *note
     PurePosixPath: 1549, ‘False’ is always returned.

          >>> PureWindowsPath('nul').is_reserved()
          True
          >>> PurePosixPath('nul').is_reserved()
          False

     File system calls on reserved paths can fail mysteriously or have
     unintended effects.

 -- Method: PurePath.joinpath (*other)

     Calling this method is equivalent to combining the path with each
     of the `other' arguments in turn:

          >>> PurePosixPath('/etc').joinpath('passwd')
          PurePosixPath('/etc/passwd')
          >>> PurePosixPath('/etc').joinpath(PurePosixPath('passwd'))
          PurePosixPath('/etc/passwd')
          >>> PurePosixPath('/etc').joinpath('init.d', 'apache2')
          PurePosixPath('/etc/init.d/apache2')
          >>> PureWindowsPath('c:').joinpath('/Program Files')
          PureWindowsPath('c:/Program Files')

 -- Method: PurePath.match (pattern)

     Match this path against the provided glob-style pattern.  Return
     ‘True’ if matching is successful, ‘False’ otherwise.

     If `pattern' is relative, the path can be either relative or
     absolute, and matching is done from the right:

          >>> PurePath('a/b.py').match('*.py')
          True
          >>> PurePath('/a/b/c.py').match('b/*.py')
          True
          >>> PurePath('/a/b/c.py').match('a/*.py')
          False

     If `pattern' is absolute, the path must be absolute, and the whole
     path must match:

          >>> PurePath('/a.py').match('/*.py')
          True
          >>> PurePath('a/b.py').match('/*.py')
          False

     As with other methods, case-sensitivity is observed:

          >>> PureWindowsPath('b.py').match('*.PY')
          True

 -- Method: PurePath.relative_to (*other)

     Compute a version of this path relative to the path represented by
     `other'.  If it’s impossible, ValueError is raised:

          >>> p = PurePosixPath('/etc/passwd')
          >>> p.relative_to('/')
          PurePosixPath('etc/passwd')
          >>> p.relative_to('/etc')
          PurePosixPath('passwd')
          >>> p.relative_to('/usr')
          Traceback (most recent call last):
            File "<stdin>", line 1, in <module>
            File "pathlib.py", line 694, in relative_to
              .format(str(self), str(formatted)))
          ValueError: '/etc/passwd' does not start with '/usr'

 -- Method: PurePath.with_name (name)

     Return a new path with the *note name: 1556. changed.  If the
     original path doesn’t have a name, ValueError is raised:

          >>> p = PureWindowsPath('c:/Downloads/pathlib.tar.gz')
          >>> p.with_name('setup.py')
          PureWindowsPath('c:/Downloads/setup.py')
          >>> p = PureWindowsPath('c:/')
          >>> p.with_name('setup.py')
          Traceback (most recent call last):
            File "<stdin>", line 1, in <module>
            File "/home/antoine/cpython/default/Lib/pathlib.py", line 751, in with_name
              raise ValueError("%r has an empty name" % (self,))
          ValueError: PureWindowsPath('c:/') has an empty name

 -- Method: PurePath.with_suffix (suffix)

     Return a new path with the *note suffix: 1558. changed.  If the
     original path doesn’t have a suffix, the new `suffix' is appended
     instead:

          >>> p = PureWindowsPath('c:/Downloads/pathlib.tar.gz')
          >>> p.with_suffix('.bz2')
          PureWindowsPath('c:/Downloads/pathlib.tar.bz2')
          >>> p = PureWindowsPath('README')
          >>> p.with_suffix('.txt')
          PureWindowsPath('README.txt')


File: python.info,  Node: Concrete paths,  Prev: Pure paths,  Up: pathlib --- Object-oriented filesystem paths

5.11.1.7 Concrete paths
.......................

Concrete paths are subclasses of the pure path classes.  In addition to
operations provided by the latter, they also provide methods to do
system calls on path objects.  There are three ways to instantiate
concrete paths:

 -- Class: pathlib.Path (*pathsegments)

     A subclass of *note PurePath: 1548, this class represents concrete
     paths of the system’s path flavour (instantiating it creates either
     a *note PosixPath: 1565. or a *note WindowsPath: 1544.):

          >>> Path('setup.py')
          PosixPath('setup.py')

     `pathsegments' is specified similarly to *note PurePath: 1548.

 -- Class: pathlib.PosixPath (*pathsegments)

     A subclass of *note Path: 2e8. and *note PurePosixPath: 1549, this
     class represents concrete non-Windows filesystem paths:

          >>> PosixPath('/etc')
          PosixPath('/etc')

     `pathsegments' is specified similarly to *note PurePath: 1548.

 -- Class: pathlib.WindowsPath (*pathsegments)

     A subclass of *note Path: 2e8. and *note PureWindowsPath: 1545,
     this class represents concrete Windows filesystem paths:

          >>> WindowsPath('c:/Program Files/')
          WindowsPath('c:/Program Files')

     `pathsegments' is specified similarly to *note PurePath: 1548.

You can only instantiate the class flavour that corresponds to your
system (allowing system calls on non-compatible path flavours could lead
to bugs or failures in your application):

     >>> import os
     >>> os.name
     'posix'
     >>> Path('setup.py')
     PosixPath('setup.py')
     >>> PosixPath('setup.py')
     PosixPath('setup.py')
     >>> WindowsPath('setup.py')
     Traceback (most recent call last):
       File "<stdin>", line 1, in <module>
       File "pathlib.py", line 798, in __new__
         % (cls.__name__,))
     NotImplementedError: cannot instantiate 'WindowsPath' on your system

* Menu:

* Methods: Methods<2>. 


File: python.info,  Node: Methods<2>,  Up: Concrete paths

5.11.1.8 Methods
................

Concrete paths provide the following methods in addition to pure paths
methods.  Many of these methods can raise an *note OSError: 4b6. if a
system call fails (for example because the path doesn’t exist):

 -- Class Method: Path.cwd ()

     Return a new path object representing the current directory (as
     returned by *note os.getcwd(): 1568.):

          >>> Path.cwd()
          PosixPath('/home/antoine/pathlib')

 -- Class Method: Path.home ()

     Return a new path object representing the user’s home directory (as
     returned by *note os.path.expanduser(): 1569. with ‘~’ construct):

          >>> Path.home()
          PosixPath('/home/antoine')

     New in version 3.5.

 -- Method: Path.stat ()

     Return information about this path (similarly to *note os.stat():
     1e2.).  The result is looked up at each call to this method.

          >>> p = Path('setup.py')
          >>> p.stat().st_size
          956
          >>> p.stat().st_mtime
          1327883547.852554

 -- Method: Path.chmod (mode)

     Change the file mode and permissions, like *note os.chmod(): 665.:

          >>> p = Path('setup.py')
          >>> p.stat().st_mode
          33277
          >>> p.chmod(0o444)
          >>> p.stat().st_mode
          33060

 -- Method: Path.exists ()

     Whether the path points to an existing file or directory:

          >>> Path('.').exists()
          True
          >>> Path('setup.py').exists()
          True
          >>> Path('/etc').exists()
          True
          >>> Path('nonexistentfile').exists()
          False

          Note: If the path points to a symlink, *note exists(): 156c.
          returns whether the symlink `points to' an existing file or
          directory.

 -- Method: Path.expanduser ()

     Return a new path with expanded ‘~’ and ‘~user’ constructs, as
     returned by *note os.path.expanduser(): 1569.:

          >>> p = PosixPath('~/films/Monty Python')
          >>> p.expanduser()
          PosixPath('/home/eric/films/Monty Python')

     New in version 3.5.

 -- Method: Path.glob (pattern)

     Glob the given `pattern' in the directory represented by this path,
     yielding all matching files (of any kind):

          >>> sorted(Path('.').glob('*.py'))
          [PosixPath('pathlib.py'), PosixPath('setup.py'), PosixPath('test_pathlib.py')]
          >>> sorted(Path('.').glob('*/*.py'))
          [PosixPath('docs/conf.py')]

     The "‘**’" pattern means "this directory and all subdirectories,
     recursively".  In other words, it enables recursive globbing:

          >>> sorted(Path('.').glob('**/*.py'))
          [PosixPath('build/lib/pathlib.py'),
           PosixPath('docs/conf.py'),
           PosixPath('pathlib.py'),
           PosixPath('setup.py'),
           PosixPath('test_pathlib.py')]

          Note: Using the "‘**’" pattern in large directory trees may
          consume an inordinate amount of time.

 -- Method: Path.group ()

     Return the name of the group owning the file.  *note KeyError: 1a7.
     is raised if the file’s gid isn’t found in the system database.

 -- Method: Path.is_dir ()

     Return ‘True’ if the path points to a directory (or a symbolic link
     pointing to a directory), ‘False’ if it points to another kind of
     file.

     ‘False’ is also returned if the path doesn’t exist or is a broken
     symlink; other errors (such as permission errors) are propagated.

 -- Method: Path.is_file ()

     Return ‘True’ if the path points to a regular file (or a symbolic
     link pointing to a regular file), ‘False’ if it points to another
     kind of file.

     ‘False’ is also returned if the path doesn’t exist or is a broken
     symlink; other errors (such as permission errors) are propagated.

 -- Method: Path.is_symlink ()

     Return ‘True’ if the path points to a symbolic link, ‘False’
     otherwise.

     ‘False’ is also returned if the path doesn’t exist; other errors
     (such as permission errors) are propagated.

 -- Method: Path.is_socket ()

     Return ‘True’ if the path points to a Unix socket (or a symbolic
     link pointing to a Unix socket), ‘False’ if it points to another
     kind of file.

     ‘False’ is also returned if the path doesn’t exist or is a broken
     symlink; other errors (such as permission errors) are propagated.

 -- Method: Path.is_fifo ()

     Return ‘True’ if the path points to a FIFO (or a symbolic link
     pointing to a FIFO), ‘False’ if it points to another kind of file.

     ‘False’ is also returned if the path doesn’t exist or is a broken
     symlink; other errors (such as permission errors) are propagated.

 -- Method: Path.is_block_device ()

     Return ‘True’ if the path points to a block device (or a symbolic
     link pointing to a block device), ‘False’ if it points to another
     kind of file.

     ‘False’ is also returned if the path doesn’t exist or is a broken
     symlink; other errors (such as permission errors) are propagated.

 -- Method: Path.is_char_device ()

     Return ‘True’ if the path points to a character device (or a
     symbolic link pointing to a character device), ‘False’ if it points
     to another kind of file.

     ‘False’ is also returned if the path doesn’t exist or is a broken
     symlink; other errors (such as permission errors) are propagated.

 -- Method: Path.iterdir ()

     When the path points to a directory, yield path objects of the
     directory contents:

          >>> p = Path('docs')
          >>> for child in p.iterdir(): child
          ...
          PosixPath('docs/conf.py')
          PosixPath('docs/_templates')
          PosixPath('docs/make.bat')
          PosixPath('docs/index.rst')
          PosixPath('docs/_build')
          PosixPath('docs/_static')
          PosixPath('docs/Makefile')

 -- Method: Path.lchmod (mode)

     Like *note Path.chmod(): 156b. but, if the path points to a
     symbolic link, the symbolic link’s mode is changed rather than its
     target’s.

 -- Method: Path.lstat ()

     Like *note Path.stat(): 156a. but, if the path points to a symbolic
     link, return the symbolic link’s information rather than its
     target’s.

 -- Method: Path.mkdir (mode=0o777, parents=False, exist_ok=False)

     Create a new directory at this given path.  If `mode' is given, it
     is combined with the process’ ‘umask’ value to determine the file
     mode and access flags.  If the path already exists, *note
     FileExistsError: 56f. is raised.

     If `parents' is true, any missing parents of this path are created
     as needed; they are created with the default permissions without
     taking `mode' into account (mimicking the POSIX ‘mkdir -p’
     command).

     If `parents' is false (the default), a missing parent raises *note
     FileNotFoundError: 3aa.

     If `exist_ok' is false (the default), an *note FileExistsError:
     56f. is raised if the target directory already exists.

     If `exist_ok' is true, *note FileExistsError: 56f. exceptions will
     be ignored (same behavior as the POSIX ‘mkdir -p’ command), but
     only if the last path component is not an existing non-directory
     file.

     Changed in version 3.5: The `exist_ok' parameter was added.

 -- Method: Path.open (mode='r', buffering=-1, encoding=None,
          errors=None, newline=None)

     Open the file pointed to by the path, like the built-in *note
     open(): 1e8. function does:

          >>> p = Path('setup.py')
          >>> with p.open() as f:
          ...     f.readline()
          ...
          '#!/usr/bin/env python3\n'

 -- Method: Path.owner ()

     Return the name of the user owning the file.  *note KeyError: 1a7.
     is raised if the file’s uid isn’t found in the system database.

 -- Method: Path.read_bytes ()

     Return the binary contents of the pointed-to file as a bytes
     object:

          >>> p = Path('my_binary_file')
          >>> p.write_bytes(b'Binary file contents')
          20
          >>> p.read_bytes()
          b'Binary file contents'

     New in version 3.5.

 -- Method: Path.read_text (encoding=None, errors=None)

     Return the decoded contents of the pointed-to file as a string:

          >>> p = Path('my_text_file')
          >>> p.write_text('Text file contents')
          18
          >>> p.read_text()
          'Text file contents'

     The optional parameters have the same meaning as in *note open():
     1e8.

     New in version 3.5.

 -- Method: Path.rename (target)

     Rename this file or directory to the given `target'.  `target' can
     be either a string or another path object:

          >>> p = Path('foo')
          >>> p.open('w').write('some text')
          9
          >>> target = Path('bar')
          >>> p.rename(target)
          >>> target.open().read()
          'some text'

 -- Method: Path.replace (target)

     Rename this file or directory to the given `target'.  If `target'
     points to an existing file or directory, it will be unconditionally
     replaced.

 -- Method: Path.resolve ()

     Make the path absolute, resolving any symlinks.  A new path object
     is returned:

          >>> p = Path()
          >>> p
          PosixPath('.')
          >>> p.resolve()
          PosixPath('/home/antoine/pathlib')

     ‘".."’ components are also eliminated (this is the only method to
     do so):

          >>> p = Path('docs/../setup.py')
          >>> p.resolve()
          PosixPath('/home/antoine/pathlib/setup.py')

     If the path doesn’t exist, *note FileNotFoundError: 3aa. is raised.
     If an infinite loop is encountered along the resolution path, *note
     RuntimeError: 193. is raised.

 -- Method: Path.rglob (pattern)

     This is like calling *note glob(): 89. with "‘**’" added in front
     of the given `pattern':

          >>> sorted(Path().rglob("*.py"))
          [PosixPath('build/lib/pathlib.py'),
           PosixPath('docs/conf.py'),
           PosixPath('pathlib.py'),
           PosixPath('setup.py'),
           PosixPath('test_pathlib.py')]

 -- Method: Path.rmdir ()

     Remove this directory.  The directory must be empty.

 -- Method: Path.samefile (other_path)

     Return whether this path points to the same file as `other_path',
     which can be either a Path object, or a string.  The semantics are
     similar to *note os.path.samefile(): 47b. and *note
     os.path.samestat(): 47a.

     An *note OSError: 4b6. can be raised if either file cannot be
     accessed for some reason.

          >>> p = Path('spam')
          >>> q = Path('eggs')
          >>> p.samefile(q)
          False
          >>> p.samefile('spam')
          True

     New in version 3.5.

 -- Method: Path.symlink_to (target, target_is_directory=False)

     Make this path a symbolic link to `target'.  Under Windows,
     `target_is_directory' must be true (default ‘False’) if the link’s
     target is a directory.  Under POSIX, `target_is_directory'’s value
     is ignored.

          >>> p = Path('mylink')
          >>> p.symlink_to('setup.py')
          >>> p.resolve()
          PosixPath('/home/antoine/pathlib/setup.py')
          >>> p.stat().st_size
          956
          >>> p.lstat().st_size
          8

          Note: The order of arguments (link, target) is the reverse of
          *note os.symlink(): 66f.’s.

 -- Method: Path.touch (mode=0o777, exist_ok=True)

     Create a file at this given path.  If `mode' is given, it is
     combined with the process’ ‘umask’ value to determine the file mode
     and access flags.  If the file already exists, the function
     succeeds if `exist_ok' is true (and its modification time is
     updated to the current time), otherwise *note FileExistsError: 56f.
     is raised.

 -- Method: Path.unlink ()

     Remove this file or symbolic link.  If the path points to a
     directory, use *note Path.rmdir(): 157e. instead.

 -- Method: Path.write_bytes (data)

     Open the file pointed to in bytes mode, write `data' to it, and
     close the file:

          >>> p = Path('my_binary_file')
          >>> p.write_bytes(b'Binary file contents')
          20
          >>> p.read_bytes()
          b'Binary file contents'

     An existing file of the same name is overwritten.

     New in version 3.5.

 -- Method: Path.write_text (data, encoding=None, errors=None)

     Open the file pointed to in text mode, write `data' to it, and
     close the file:

          >>> p = Path('my_text_file')
          >>> p.write_text('Text file contents')
          18
          >>> p.read_text()
          'Text file contents'

     New in version 3.5.

