This is python.info, produced by makeinfo version 6.0 from python.texi.

     Python 3.6.0a0, May 06, 2016

     Georg Brandl

     Copyright © 2001-2016, Python Software Foundation

INFO-DIR-SECTION Documentation tools
START-INFO-DIR-ENTRY
* Python: (python.info). The Python Programming Language
END-INFO-DIR-ENTRY


   Generated by Sphinx 1.4.1.


File: python.info,  Node: mboxMessage,  Next: MHMessage,  Prev: MaildirMessage,  Up: Message objects

5.19.4.9 ‘mboxMessage’
......................

 -- Class: mailbox.mboxMessage (message=None)

     A message with mbox-specific behaviors.  Parameter `message' has
     the same meaning as with the *note Message: 845. constructor.

     Messages in an mbox mailbox are stored together in a single file.
     The sender’s envelope address and the time of delivery are
     typically stored in a line beginning with "From " that is used to
     indicate the start of a message, though there is considerable
     variation in the exact format of this data among mbox
     implementations.  Flags that indicate the state of the message,
     such as whether it has been read or marked as important, are
     typically stored in ‘Status’ and ‘X-Status’ headers.

     Conventional flags for mbox messages are as follows:

     Flag       Meaning        Explanation
                               
     ---------------------------------------------------------------
                               
     R          Read           Read
                               
                               
     O          Old            Previously detected by MUA
                               
                               
     D          Deleted        Marked for subsequent deletion
                               
                               
     F          Flagged        Marked as important
                               
                               
     A          Answered       Replied to
                               

     The "R" and "O" flags are stored in the ‘Status’ header, and the
     "D", "F", and "A" flags are stored in the ‘X-Status’ header.  The
     flags and headers typically appear in the order mentioned.

     *note mboxMessage: 21bc. instances offer the following methods:

      -- Method: get_from ()

          Return a string representing the "From " line that marks the
          start of the message in an mbox mailbox.  The leading "From "
          and the trailing newline are excluded.

      -- Method: set_from (from_, time_=None)

          Set the "From " line to `from_', which should be specified
          without a leading "From " or trailing newline.  For
          convenience, `time_' may be specified and will be formatted
          appropriately and appended to `from_'.  If `time_' is
          specified, it should be a *note time.struct_time: 125c.
          instance, a tuple suitable for passing to *note
          time.strftime(): 7b1, or ‘True’ (to use *note time.gmtime():
          786.).

      -- Method: get_flags ()

          Return a string specifying the flags that are currently set.
          If the message complies with the conventional format, the
          result is the concatenation in the following order of zero or
          one occurrence of each of ‘'R'’, ‘'O'’, ‘'D'’, ‘'F'’, and
          ‘'A'’.

      -- Method: set_flags (flags)

          Set the flags specified by `flags' and unset all others.
          Parameter `flags' should be the concatenation in any order of
          zero or more occurrences of each of ‘'R'’, ‘'O'’, ‘'D'’,
          ‘'F'’, and ‘'A'’.

      -- Method: add_flag (flag)

          Set the flag(s) specified by `flag' without changing other
          flags.  To add more than one flag at a time, `flag' may be a
          string of more than one character.

      -- Method: remove_flag (flag)

          Unset the flag(s) specified by `flag' without changing other
          flags.  To remove more than one flag at a time, `flag' maybe a
          string of more than one character.

When an *note mboxMessage: 21bc. instance is created based upon a *note
MaildirMessage: 21d5. instance, a "From " line is generated based upon
the *note MaildirMessage: 21d5. instance’s delivery date, and the
following conversions take place:

Resulting state       *note MaildirMessage: 21d5. state
                      
----------------------------------------------------------
                      
R flag                S flag
                      
                      
O flag                "cur" subdirectory
                      
                      
D flag                T flag
                      
                      
F flag                F flag
                      
                      
A flag                R flag
                      

When an *note mboxMessage: 21bc. instance is created based upon an *note
MHMessage: 21ed. instance, the following conversions take place:

Resulting state         *note MHMessage: 21ed. state
                        
-------------------------------------------------------
                        
R flag and O flag       no "unseen" sequence
                        
                        
O flag                  "unseen" sequence
                        
                        
F flag                  "flagged" sequence
                        
                        
A flag                  "replied" sequence
                        

When an *note mboxMessage: 21bc. instance is created based upon a *note
BabylMessage: 2200. instance, the following conversions take place:

Resulting state         *note BabylMessage: 2200. state
                        
----------------------------------------------------------
                        
R flag and O flag       no "unseen" label
                        
                        
O flag                  "unseen" label
                        
                        
D flag                  "deleted" label
                        
                        
A flag                  "answered" label
                        

When a *note Message: 845. instance is created based upon an *note
MMDFMessage: 2208. instance, the "From " line is copied and all flags
directly correspond:

Resulting state       *note MMDFMessage: 2208. state
                      
-------------------------------------------------------
                      
R flag                R flag
                      
                      
O flag                O flag
                      
                      
D flag                D flag
                      
                      
F flag                F flag
                      
                      
A flag                A flag
                      


File: python.info,  Node: MHMessage,  Next: BabylMessage,  Prev: mboxMessage,  Up: Message objects

5.19.4.10 ‘MHMessage’
.....................

 -- Class: mailbox.MHMessage (message=None)

     A message with MH-specific behaviors.  Parameter `message' has the
     same meaning as with the *note Message: 845. constructor.

     MH messages do not support marks or flags in the traditional sense,
     but they do support sequences, which are logical groupings of
     arbitrary messages.  Some mail reading programs (although not the
     standard ‘mh’ and ‘nmh’) use sequences in much the same way flags
     are used with other formats, as follows:

     Sequence       Explanation
                    
     --------------------------------------------------------------
                    
     unseen         Not read, but previously detected by MUA
                    
                    
     replied        Replied to
                    
                    
     flagged        Marked as important
                    

     *note MHMessage: 21ed. instances offer the following methods:

      -- Method: get_sequences ()

          Return a list of the names of sequences that include this
          message.

      -- Method: set_sequences (sequences)

          Set the list of sequences that include this message.

      -- Method: add_sequence (sequence)

          Add `sequence' to the list of sequences that include this
          message.

      -- Method: remove_sequence (sequence)

          Remove `sequence' from the list of sequences that include this
          message.

When an *note MHMessage: 21ed. instance is created based upon a *note
MaildirMessage: 21d5. instance, the following conversions take place:

Resulting state          *note MaildirMessage: 21d5. state
                         
-------------------------------------------------------------
                         
"unseen" sequence        no S flag
                         
                         
"replied" sequence       R flag
                         
                         
"flagged" sequence       F flag
                         

When an *note MHMessage: 21ed. instance is created based upon an *note
mboxMessage: 21bc. or *note MMDFMessage: 2208. instance, the ‘Status’
and ‘X-Status’ headers are omitted and the following conversions take
place:

Resulting state          *note mboxMessage: 21bc. or
                         *note MMDFMessage: 2208. state
                         
----------------------------------------------------------------------------
                         
"unseen" sequence        no R flag
                         
                         
"replied" sequence       A flag
                         
                         
"flagged" sequence       F flag
                         

When an *note MHMessage: 21ed. instance is created based upon a *note
BabylMessage: 2200. instance, the following conversions take place:

Resulting state          *note BabylMessage: 2200. state
                         
-----------------------------------------------------------
                         
"unseen" sequence        "unseen" label
                         
                         
"replied" sequence       "answered" label
                         


File: python.info,  Node: BabylMessage,  Next: MMDFMessage,  Prev: MHMessage,  Up: Message objects

5.19.4.11 ‘BabylMessage’
........................

 -- Class: mailbox.BabylMessage (message=None)

     A message with Babyl-specific behaviors.  Parameter `message' has
     the same meaning as with the *note Message: 845. constructor.

     Certain message labels, called `attributes', are defined by
     convention to have special meanings.  The attributes are as
     follows:

     Label           Explanation
                     
     ---------------------------------------------------------------
                     
     unseen          Not read, but previously detected by MUA
                     
                     
     deleted         Marked for subsequent deletion
                     
                     
     filed           Copied to another file or mailbox
                     
                     
     answered        Replied to
                     
                     
     forwarded       Forwarded
                     
                     
     edited          Modified by the user
                     
                     
     resent          Resent
                     

     By default, Rmail displays only visible headers.  The *note
     BabylMessage: 2200. class, though, uses the original headers
     because they are more complete.  Visible headers may be accessed
     explicitly if desired.

     *note BabylMessage: 2200. instances offer the following methods:

      -- Method: get_labels ()

          Return a list of labels on the message.

      -- Method: set_labels (labels)

          Set the list of labels on the message to `labels'.

      -- Method: add_label (label)

          Add `label' to the list of labels on the message.

      -- Method: remove_label (label)

          Remove `label' from the list of labels on the message.

      -- Method: get_visible ()

          Return an *note Message: 845. instance whose headers are the
          message’s visible headers and whose body is empty.

      -- Method: set_visible (visible)

          Set the message’s visible headers to be the same as the
          headers in `message'.  Parameter `visible' should be a *note
          Message: 845. instance, an *note email.message.Message: 3d2.
          instance, a string, or a file-like object (which should be
          open in text mode).

      -- Method: update_visible ()

          When a *note BabylMessage: 2200. instance’s original headers
          are modified, the visible headers are not automatically
          modified to correspond.  This method updates the visible
          headers as follows: each visible header with a corresponding
          original header is set to the value of the original header,
          each visible header without a corresponding original header is
          removed, and any of ‘Date’, ‘From’, ‘Reply-To’, ‘To’, ‘CC’,
          and ‘Subject’ that are present in the original headers but not
          the visible headers are added to the visible headers.

When a *note BabylMessage: 2200. instance is created based upon a *note
MaildirMessage: 21d5. instance, the following conversions take place:

Resulting state         *note MaildirMessage: 21d5. state
                        
------------------------------------------------------------
                        
"unseen" label          no S flag
                        
                        
"deleted" label         T flag
                        
                        
"answered" label        R flag
                        
                        
"forwarded" label       P flag
                        

When a *note BabylMessage: 2200. instance is created based upon an *note
mboxMessage: 21bc. or *note MMDFMessage: 2208. instance, the ‘Status’
and ‘X-Status’ headers are omitted and the following conversions take
place:

Resulting state        *note mboxMessage: 21bc. or
                       *note MMDFMessage: 2208. state
                       
--------------------------------------------------------------------------
                       
"unseen" label         no R flag
                       
                       
"deleted" label        D flag
                       
                       
"answered" label       A flag
                       

When a *note BabylMessage: 2200. instance is created based upon an *note
MHMessage: 21ed. instance, the following conversions take place:

Resulting state        *note MHMessage: 21ed. state
                       
------------------------------------------------------
                       
"unseen" label         "unseen" sequence
                       
                       
"answered" label       "replied" sequence
                       


File: python.info,  Node: MMDFMessage,  Prev: BabylMessage,  Up: Message objects

5.19.4.12 ‘MMDFMessage’
.......................

 -- Class: mailbox.MMDFMessage (message=None)

     A message with MMDF-specific behaviors.  Parameter `message' has
     the same meaning as with the *note Message: 845. constructor.

     As with message in an mbox mailbox, MMDF messages are stored with
     the sender’s address and the delivery date in an initial line
     beginning with "From ".  Likewise, flags that indicate the state of
     the message are typically stored in ‘Status’ and ‘X-Status’
     headers.

     Conventional flags for MMDF messages are identical to those of mbox
     message and are as follows:

     Flag       Meaning        Explanation
                               
     ---------------------------------------------------------------
                               
     R          Read           Read
                               
                               
     O          Old            Previously detected by MUA
                               
                               
     D          Deleted        Marked for subsequent deletion
                               
                               
     F          Flagged        Marked as important
                               
                               
     A          Answered       Replied to
                               

     The "R" and "O" flags are stored in the ‘Status’ header, and the
     "D", "F", and "A" flags are stored in the ‘X-Status’ header.  The
     flags and headers typically appear in the order mentioned.

     *note MMDFMessage: 2208. instances offer the following methods,
     which are identical to those offered by *note mboxMessage: 21bc.:

      -- Method: get_from ()

          Return a string representing the "From " line that marks the
          start of the message in an mbox mailbox.  The leading "From "
          and the trailing newline are excluded.

      -- Method: set_from (from_, time_=None)

          Set the "From " line to `from_', which should be specified
          without a leading "From " or trailing newline.  For
          convenience, `time_' may be specified and will be formatted
          appropriately and appended to `from_'.  If `time_' is
          specified, it should be a *note time.struct_time: 125c.
          instance, a tuple suitable for passing to *note
          time.strftime(): 7b1, or ‘True’ (to use *note time.gmtime():
          786.).

      -- Method: get_flags ()

          Return a string specifying the flags that are currently set.
          If the message complies with the conventional format, the
          result is the concatenation in the following order of zero or
          one occurrence of each of ‘'R'’, ‘'O'’, ‘'D'’, ‘'F'’, and
          ‘'A'’.

      -- Method: set_flags (flags)

          Set the flags specified by `flags' and unset all others.
          Parameter `flags' should be the concatenation in any order of
          zero or more occurrences of each of ‘'R'’, ‘'O'’, ‘'D'’,
          ‘'F'’, and ‘'A'’.

      -- Method: add_flag (flag)

          Set the flag(s) specified by `flag' without changing other
          flags.  To add more than one flag at a time, `flag' may be a
          string of more than one character.

      -- Method: remove_flag (flag)

          Unset the flag(s) specified by `flag' without changing other
          flags.  To remove more than one flag at a time, `flag' maybe a
          string of more than one character.

When an *note MMDFMessage: 2208. instance is created based upon a *note
MaildirMessage: 21d5. instance, a "From " line is generated based upon
the *note MaildirMessage: 21d5. instance’s delivery date, and the
following conversions take place:

Resulting state       *note MaildirMessage: 21d5. state
                      
----------------------------------------------------------
                      
R flag                S flag
                      
                      
O flag                "cur" subdirectory
                      
                      
D flag                T flag
                      
                      
F flag                F flag
                      
                      
A flag                R flag
                      

When an *note MMDFMessage: 2208. instance is created based upon an *note
MHMessage: 21ed. instance, the following conversions take place:

Resulting state         *note MHMessage: 21ed. state
                        
-------------------------------------------------------
                        
R flag and O flag       no "unseen" sequence
                        
                        
O flag                  "unseen" sequence
                        
                        
F flag                  "flagged" sequence
                        
                        
A flag                  "replied" sequence
                        

When an *note MMDFMessage: 2208. instance is created based upon a *note
BabylMessage: 2200. instance, the following conversions take place:

Resulting state         *note BabylMessage: 2200. state
                        
----------------------------------------------------------
                        
R flag and O flag       no "unseen" label
                        
                        
O flag                  "unseen" label
                        
                        
D flag                  "deleted" label
                        
                        
A flag                  "answered" label
                        

When an *note MMDFMessage: 2208. instance is created based upon an *note
mboxMessage: 21bc. instance, the "From " line is copied and all flags
directly correspond:

Resulting state       *note mboxMessage: 21bc. state
                      
-------------------------------------------------------
                      
R flag                R flag
                      
                      
O flag                O flag
                      
                      
D flag                D flag
                      
                      
F flag                F flag
                      
                      
A flag                A flag
                      


File: python.info,  Node: Exceptions<10>,  Next: Examples<12>,  Prev: Message objects,  Up: mailbox --- Manipulate mailboxes in various formats

5.19.4.13 Exceptions
....................

The following exception classes are defined in the *note mailbox: ad.
module:

 -- Exception: mailbox.Error

     The based class for all other module-specific exceptions.

 -- Exception: mailbox.NoSuchMailboxError

     Raised when a mailbox is expected but is not found, such as when
     instantiating a *note Mailbox: 841. subclass with a path that does
     not exist (and with the `create' parameter set to ‘False’), or when
     opening a folder that does not exist.

 -- Exception: mailbox.NotEmptyError

     Raised when a mailbox is not empty but is expected to be, such as
     when deleting a folder that contains messages.

 -- Exception: mailbox.ExternalClashError

     Raised when some mailbox-related condition beyond the control of
     the program causes it to be unable to proceed, such as when failing
     to acquire a lock that another program already holds a lock, or
     when a uniquely-generated file name already exists.

 -- Exception: mailbox.FormatError

     Raised when the data in a file cannot be parsed, such as when an
     *note MH: 21ec. instance attempts to read a corrupted
     ‘.mh_sequences’ file.


File: python.info,  Node: Examples<12>,  Prev: Exceptions<10>,  Up: mailbox --- Manipulate mailboxes in various formats

5.19.4.14 Examples
..................

A simple example of printing the subjects of all messages in a mailbox
that seem interesting:

     import mailbox
     for message in mailbox.mbox('~/mbox'):
         subject = message['subject']       # Could possibly be None.
         if subject and 'python' in subject.lower():
             print(subject)

To copy all mail from a Babyl mailbox to an MH mailbox, converting all
of the format-specific information that can be converted:

     import mailbox
     destination = mailbox.MH('~/Mail')
     destination.lock()
     for message in mailbox.Babyl('~/RMAIL'):
         destination.add(mailbox.MHMessage(message))
     destination.flush()
     destination.unlock()

This example sorts mail from several mailing lists into different
mailboxes, being careful to avoid mail corruption due to concurrent
modification by other programs, mail loss due to interruption of the
program, or premature termination due to malformed messages in the
mailbox:

     import mailbox
     import email.errors

     list_names = ('python-list', 'python-dev', 'python-bugs')

     boxes = {name: mailbox.mbox('~/email/%s' % name) for name in list_names}
     inbox = mailbox.Maildir('~/Maildir', factory=None)

     for key in inbox.iterkeys():
         try:
             message = inbox[key]
         except email.errors.MessageParseError:
             continue                # The message is malformed. Just leave it.

         for name in list_names:
             list_id = message['list-id']
             if list_id and name in list_id:
                 # Get mailbox to use
                 box = boxes[name]

                 # Write copy to disk before removing original.
                 # If there's a crash, you might duplicate a message, but
                 # that's better than losing a message completely.
                 box.lock()
                 box.add(message)
                 box.flush()
                 box.unlock()

                 # Remove original message
                 inbox.lock()
                 inbox.discard(key)
                 inbox.flush()
                 inbox.unlock()
                 break               # Found destination, so stop looking.

     for box in boxes.itervalues():
         box.close()


File: python.info,  Node: mimetypes --- Map filenames to MIME types,  Next: base64 --- Base16 Base32 Base64 Base85 Data Encodings,  Prev: mailbox --- Manipulate mailboxes in various formats,  Up: Internet Data Handling

5.19.5 ‘mimetypes’ — Map filenames to MIME types
------------------------------------------------

`Source code:' Lib/mimetypes.py(1)

__________________________________________________________________

The *note mimetypes: b1. module converts between a filename or URL and
the MIME type associated with the filename extension.  Conversions are
provided from filename to MIME type and from MIME type to filename
extension; encodings are not supported for the latter conversion.

The module provides one class and a number of convenience functions.
The functions are the normal interface to this module, but some
applications may be interested in the class as well.

The functions described below provide the primary interface for this
module.  If the module has not been initialized, they will call *note
init(): 2240. if they rely on the information *note init(): 2240. sets
up.

 -- Function: mimetypes.guess_type (url, strict=True)

     Guess the type of a file based on its filename or URL, given by
     `url'.  The return value is a tuple ‘(type, encoding)’ where `type'
     is ‘None’ if the type can’t be guessed (missing or unknown suffix)
     or a string of the form ‘'type/subtype'’, usable for a MIME
     ‘content-type’ header.

     `encoding' is ‘None’ for no encoding or the name of the program
     used to encode (e.g.  ‘compress’ or ‘gzip’).  The encoding is
     suitable for use as a ‘Content-Encoding’ header, `not' as a
     ‘Content-Transfer-Encoding’ header.  The mappings are table driven.
     Encoding suffixes are case sensitive; type suffixes are first tried
     case sensitively, then case insensitively.

     The optional `strict' argument is a flag specifying whether the
     list of known MIME types is limited to only the official types
     registered with IANA(2). When `strict' is ‘True’ (the default),
     only the IANA types are supported; when `strict' is ‘False’, some
     additional non-standard but commonly used MIME types are also
     recognized.

 -- Function: mimetypes.guess_all_extensions (type, strict=True)

     Guess the extensions for a file based on its MIME type, given by
     `type'.  The return value is a list of strings giving all possible
     filename extensions, including the leading dot (‘'.'’).  The
     extensions are not guaranteed to have been associated with any
     particular data stream, but would be mapped to the MIME type `type'
     by *note guess_type(): 2241.

     The optional `strict' argument has the same meaning as with the
     *note guess_type(): 2241. function.

 -- Function: mimetypes.guess_extension (type, strict=True)

     Guess the extension for a file based on its MIME type, given by
     `type'.  The return value is a string giving a filename extension,
     including the leading dot (‘'.'’).  The extension is not guaranteed
     to have been associated with any particular data stream, but would
     be mapped to the MIME type `type' by *note guess_type(): 2241.  If
     no extension can be guessed for `type', ‘None’ is returned.

     The optional `strict' argument has the same meaning as with the
     *note guess_type(): 2241. function.

Some additional functions and data items are available for controlling
the behavior of the module.

 -- Function: mimetypes.init (files=None)

     Initialize the internal data structures.  If given, `files' must be
     a sequence of file names which should be used to augment the
     default type map.  If omitted, the file names to use are taken from
     *note knownfiles: 2244.; on Windows, the current registry settings
     are loaded.  Each file named in `files' or *note knownfiles: 2244.
     takes precedence over those named before it.  Calling *note init():
     2240. repeatedly is allowed.

     Specifying an empty list for `files' will prevent the system
     defaults from being applied: only the well-known values will be
     present from a built-in list.

     Changed in version 3.2: Previously, Windows registry settings were
     ignored.

 -- Function: mimetypes.read_mime_types (filename)

     Load the type map given in the file `filename', if it exists.  The
     type map is returned as a dictionary mapping filename extensions,
     including the leading dot (‘'.'’), to strings of the form
     ‘'type/subtype'’.  If the file `filename' does not exist or cannot
     be read, ‘None’ is returned.

 -- Function: mimetypes.add_type (type, ext, strict=True)

     Add a mapping from the MIME type `type' to the extension `ext'.
     When the extension is already known, the new type will replace the
     old one.  When the type is already known the extension will be
     added to the list of known extensions.

     When `strict' is ‘True’ (the default), the mapping will be added to
     the official MIME types, otherwise to the non-standard ones.

 -- Data: mimetypes.inited

     Flag indicating whether or not the global data structures have been
     initialized.  This is set to ‘True’ by *note init(): 2240.

 -- Data: mimetypes.knownfiles

     List of type map file names commonly installed.  These files are
     typically named ‘mime.types’ and are installed in different
     locations by different packages.

 -- Data: mimetypes.suffix_map

     Dictionary mapping suffixes to suffixes.  This is used to allow
     recognition of encoded files for which the encoding and the type
     are indicated by the same extension.  For example, the ‘.tgz’
     extension is mapped to ‘.tar.gz’ to allow the encoding and type to
     be recognized separately.

 -- Data: mimetypes.encodings_map

     Dictionary mapping filename extensions to encoding types.

 -- Data: mimetypes.types_map

     Dictionary mapping filename extensions to MIME types.

 -- Data: mimetypes.common_types

     Dictionary mapping filename extensions to non-standard, but
     commonly found MIME types.

An example usage of the module:

     >>> import mimetypes
     >>> mimetypes.init()
     >>> mimetypes.knownfiles
     ['/etc/mime.types', '/etc/httpd/mime.types', ... ]
     >>> mimetypes.suffix_map['.tgz']
     '.tar.gz'
     >>> mimetypes.encodings_map['.gz']
     'gzip'
     >>> mimetypes.types_map['.tgz']
     'application/x-tar-gz'

* Menu:

* MimeTypes Objects:: 

   ---------- Footnotes ----------

   (1) https://hg.python.org/cpython/file/default/Lib/mimetypes.py

   (2) http://www.iana.org/assignments/media-types/media-types.xhtml


File: python.info,  Node: MimeTypes Objects,  Up: mimetypes --- Map filenames to MIME types

5.19.5.1 MimeTypes Objects
..........................

The *note MimeTypes: 224e. class may be useful for applications which
may want more than one MIME-type database; it provides an interface
similar to the one of the *note mimetypes: b1. module.

 -- Class: mimetypes.MimeTypes (filenames=(), strict=True)

     This class represents a MIME-types database.  By default, it
     provides access to the same database as the rest of this module.
     The initial database is a copy of that provided by the module, and
     may be extended by loading additional ‘mime.types’-style files into
     the database using the *note read(): 224f. or *note readfp(): 2250.
     methods.  The mapping dictionaries may also be cleared before
     loading additional data if the default data is not desired.

     The optional `filenames' parameter can be used to cause additional
     files to be loaded "on top" of the default database.

 -- Attribute: MimeTypes.suffix_map

     Dictionary mapping suffixes to suffixes.  This is used to allow
     recognition of encoded files for which the encoding and the type
     are indicated by the same extension.  For example, the ‘.tgz’
     extension is mapped to ‘.tar.gz’ to allow the encoding and type to
     be recognized separately.  This is initially a copy of the global
     *note suffix_map: 2248. defined in the module.

 -- Attribute: MimeTypes.encodings_map

     Dictionary mapping filename extensions to encoding types.  This is
     initially a copy of the global *note encodings_map: 2249. defined
     in the module.

 -- Attribute: MimeTypes.types_map

     Tuple containing two dictionaries, mapping filename extensions to
     MIME types: the first dictionary is for the non-standards types and
     the second one is for the standard types.  They are initialized by
     *note common_types: 224b. and *note types_map: 224a.

 -- Attribute: MimeTypes.types_map_inv

     Tuple containing two dictionaries, mapping MIME types to a list of
     filename extensions: the first dictionary is for the non-standards
     types and the second one is for the standard types.  They are
     initialized by *note common_types: 224b. and *note types_map: 224a.

 -- Method: MimeTypes.guess_extension (type, strict=True)

     Similar to the *note guess_extension(): 2243. function, using the
     tables stored as part of the object.

 -- Method: MimeTypes.guess_type (url, strict=True)

     Similar to the *note guess_type(): 2241. function, using the tables
     stored as part of the object.

 -- Method: MimeTypes.guess_all_extensions (type, strict=True)

     Similar to the *note guess_all_extensions(): 2242. function, using
     the tables stored as part of the object.

 -- Method: MimeTypes.read (filename, strict=True)

     Load MIME information from a file named `filename'.  This uses
     *note readfp(): 2250. to parse the file.

     If `strict' is ‘True’, information will be added to list of
     standard types, else to the list of non-standard types.

 -- Method: MimeTypes.readfp (fp, strict=True)

     Load MIME type information from an open file `fp'.  The file must
     have the format of the standard ‘mime.types’ files.

     If `strict' is ‘True’, information will be added to the list of
     standard types, else to the list of non-standard types.

 -- Method: MimeTypes.read_windows_registry (strict=True)

     Load MIME type information from the Windows registry.
     Availability: Windows.

     If `strict' is ‘True’, information will be added to the list of
     standard types, else to the list of non-standard types.

     New in version 3.2.


File: python.info,  Node: base64 --- Base16 Base32 Base64 Base85 Data Encodings,  Next: binhex --- Encode and decode binhex4 files,  Prev: mimetypes --- Map filenames to MIME types,  Up: Internet Data Handling

5.19.6 ‘base64’ — Base16, Base32, Base64, Base85 Data Encodings
---------------------------------------------------------------

This module provides functions for encoding binary data to printable
ASCII characters and decoding such encodings back to binary data.  It
provides encoding and decoding functions for the encodings specified in
RFC 3548(1), which defines the Base16, Base32, and Base64 algorithms,
and for the de-facto standard Ascii85 and Base85 encodings.

The RFC 3548(2) encodings are suitable for encoding binary data so that
it can safely sent by email, used as parts of URLs, or included as part
of an HTTP POST request.  The encoding algorithm is not the same as the
‘uuencode’ program.

There are two interfaces provided by this module.  The modern interface
supports encoding *note bytes-like objects: 36b. to ASCII *note bytes:
1db, and decoding *note bytes-like objects: 36b. or strings containing
ASCII to *note bytes: 1db.  Both base-64 alphabets defined in RFC
3548(3) (normal, and URL- and filesystem-safe) are supported.

The legacy interface does not support decoding from strings, but it does
provide functions for encoding and decoding to and from *note file
objects: 78b.  It only supports the Base64 standard alphabet, and it
adds newlines every 76 characters as per RFC 2045(4).  Note that if you
are looking for RFC 2045(5) support you probably want to be looking at
the *note email: 67. package instead.

Changed in version 3.3: ASCII-only Unicode strings are now accepted by
the decoding functions of the modern interface.

Changed in version 3.4: Any *note bytes-like object: 36b.s are now
accepted by all encoding and decoding functions in this module.
Ascii85/Base85 support added.

The modern interface provides:

 -- Function: base64.b64encode (s, altchars=None)

     Encode the *note bytes-like object: 36b. `s' using Base64 and
     return the encoded *note bytes: 1db.

     Optional `altchars' must be a *note bytes-like object: 36b. of at
     least length 2 (additional characters are ignored) which specifies
     an alternative alphabet for the ‘+’ and ‘/’ characters.  This
     allows an application to e.g.  generate URL or filesystem safe
     Base64 strings.  The default is ‘None’, for which the standard
     Base64 alphabet is used.

 -- Function: base64.b64decode (s, altchars=None, validate=False)

     Decode the Base64 encoded *note bytes-like object: 36b. or ASCII
     string `s' and return the decoded *note bytes: 1db.

     Optional `altchars' must be a *note bytes-like object: 36b. or
     ASCII string of at least length 2 (additional characters are
     ignored) which specifies the alternative alphabet used instead of
     the ‘+’ and ‘/’ characters.

     A *note binascii.Error: 576. exception is raised if `s' is
     incorrectly padded.

     If `validate' is ‘False’ (the default), characters that are neither
     in the normal base-64 alphabet nor the alternative alphabet are
     discarded prior to the padding check.  If `validate' is ‘True’,
     these non-alphabet characters in the input result in a *note
     binascii.Error: 576.

 -- Function: base64.standard_b64encode (s)

     Encode *note bytes-like object: 36b. `s' using the standard Base64
     alphabet and return the encoded *note bytes: 1db.

 -- Function: base64.standard_b64decode (s)

     Decode *note bytes-like object: 36b. or ASCII string `s' using the
     standard Base64 alphabet and return the decoded *note bytes: 1db.

 -- Function: base64.urlsafe_b64encode (s)

     Encode *note bytes-like object: 36b. `s' using the URL- and
     filesystem-safe alphabet, which substitutes ‘-’ instead of ‘+’ and
     ‘_’ instead of ‘/’ in the standard Base64 alphabet, and return the
     encoded *note bytes: 1db.  The result can still contain ‘=’.

 -- Function: base64.urlsafe_b64decode (s)

     Decode *note bytes-like object: 36b. or ASCII string `s' using the
     URL- and filesystem-safe alphabet, which substitutes ‘-’ instead of
     ‘+’ and ‘_’ instead of ‘/’ in the standard Base64 alphabet, and
     return the decoded *note bytes: 1db.

 -- Function: base64.b32encode (s)

     Encode the *note bytes-like object: 36b. `s' using Base32 and
     return the encoded *note bytes: 1db.

 -- Function: base64.b32decode (s, casefold=False, map01=None)

     Decode the Base32 encoded *note bytes-like object: 36b. or ASCII
     string `s' and return the decoded *note bytes: 1db.

     Optional `casefold' is a flag specifying whether a lowercase
     alphabet is acceptable as input.  For security purposes, the
     default is ‘False’.

     RFC 3548(6) allows for optional mapping of the digit 0 (zero) to
     the letter O (oh), and for optional mapping of the digit 1 (one) to
     either the letter I (eye) or letter L (el).  The optional argument
     `map01' when not ‘None’, specifies which letter the digit 1 should
     be mapped to (when `map01' is not ‘None’, the digit 0 is always
     mapped to the letter O). For security purposes the default is
     ‘None’, so that 0 and 1 are not allowed in the input.

     A *note binascii.Error: 576. is raised if `s' is incorrectly padded
     or if there are non-alphabet characters present in the input.

 -- Function: base64.b16encode (s)

     Encode the *note bytes-like object: 36b. `s' using Base16 and
     return the encoded *note bytes: 1db.

 -- Function: base64.b16decode (s, casefold=False)

     Decode the Base16 encoded *note bytes-like object: 36b. or ASCII
     string `s' and return the decoded *note bytes: 1db.

     Optional `casefold' is a flag specifying whether a lowercase
     alphabet is acceptable as input.  For security purposes, the
     default is ‘False’.

     A *note binascii.Error: 576. is raised if `s' is incorrectly padded
     or if there are non-alphabet characters present in the input.

 -- Function: base64.a85encode (b, *, foldspaces=False, wrapcol=0,
          pad=False, adobe=False)

     Encode the *note bytes-like object: 36b. `b' using Ascii85 and
     return the encoded *note bytes: 1db.

     `foldspaces' is an optional flag that uses the special short
     sequence ’y’ instead of 4 consecutive spaces (ASCII 0x20) as
     supported by ’btoa’.  This feature is not supported by the
     "standard" Ascii85 encoding.

     `wrapcol' controls whether the output should have newline (‘b'\n'’)
     characters added to it.  If this is non-zero, each output line will
     be at most this many characters long.

     `pad' controls whether the input is padded to a multiple of 4
     before encoding.  Note that the ‘btoa’ implementation always pads.

     `adobe' controls whether the encoded byte sequence is framed with
     ‘<~’ and ‘~>’, which is used by the Adobe implementation.

     New in version 3.4.

 -- Function: base64.a85decode (b, *, foldspaces=False, adobe=False,
          ignorechars=b' \t\n\r\v')

     Decode the Ascii85 encoded *note bytes-like object: 36b. or ASCII
     string `b' and return the decoded *note bytes: 1db.

     `foldspaces' is a flag that specifies whether the ’y’ short
     sequence should be accepted as shorthand for 4 consecutive spaces
     (ASCII 0x20).  This feature is not supported by the "standard"
     Ascii85 encoding.

     `adobe' controls whether the input sequence is in Adobe Ascii85
     format (i.e.  is framed with <~ and ~>).

     `ignorechars' should be a *note bytes-like object: 36b. or ASCII
     string containing characters to ignore from the input.  This should
     only contain whitespace characters, and by default contains all
     whitespace characters in ASCII.

     New in version 3.4.

 -- Function: base64.b85encode (b, pad=False)

     Encode the *note bytes-like object: 36b. `b' using base85 (as used
     in e.g.  git-style binary diffs) and return the encoded *note
     bytes: 1db.

     If `pad' is true, the input is padded with ‘b'\0'’ so its length is
     a multiple of 4 bytes before encoding.

     New in version 3.4.

 -- Function: base64.b85decode (b)

     Decode the base85-encoded *note bytes-like object: 36b. or ASCII
     string `b' and return the decoded *note bytes: 1db.  Padding is
     implicitly removed, if necessary.

     New in version 3.4.

     Note: Both Base85 and Ascii85 have an expansion factor of 5 to 4 (5
     Base85 or Ascii85 characters can encode 4 binary bytes), while the
     better-known Base64 has an expansion factor of 6 to 4.  They are
     therefore more efficient when space expensive.  They differ by
     details such as the character map used for encoding.

The legacy interface:

 -- Function: base64.decode (input, output)

     Decode the contents of the binary `input' file and write the
     resulting binary data to the `output' file.  `input' and `output'
     must be *note file objects: 78b.  `input' will be read until
     ‘input.readline()’ returns an empty bytes object.

 -- Function: base64.decodebytes (s)
 -- Function: base64.decodestring (s)

     Decode the *note bytes-like object: 36b. `s', which must contain
     one or more lines of base64 encoded data, and return the decoded
     *note bytes: 1db.  ‘decodestring’ is a deprecated alias.

     New in version 3.1.

 -- Function: base64.encode (input, output)

     Encode the contents of the binary `input' file and write the
     resulting base64 encoded data to the `output' file.  `input' and
     `output' must be *note file objects: 78b.  `input' will be read
     until ‘input.read()’ returns an empty bytes object.  *note
     encode(): 2266. inserts a newline character (‘b'\n'’) after every
     76 bytes of the output, as well as ensuring that the output always
     ends with a newline, as per RFC 2045(7) (MIME).

 -- Function: base64.encodebytes (s)
 -- Function: base64.encodestring (s)

     Encode the *note bytes-like object: 36b. `s', which can contain
     arbitrary binary data, and return *note bytes: 1db. containing the
     base64-encoded data, with newlines (‘b'\n'’) inserted after every
     76 bytes of output, and ensuring that there is a trailing newline,
     as per RFC 2045(8) (MIME).

     ‘encodestring’ is a deprecated alias.

An example usage of the module:

     >>> import base64
     >>> encoded = base64.b64encode(b'data to be encoded')
     >>> encoded
     b'ZGF0YSB0byBiZSBlbmNvZGVk'
     >>> data = base64.b64decode(encoded)
     >>> data
     b'data to be encoded'

See also
........

Module *note binascii: 10.

     Support module containing ASCII-to-binary and binary-to-ASCII
     conversions.

RFC 1521(9) - MIME (Multipurpose Internet Mail Extensions) Part One: Mechanisms for Specifying and Describing the Format of Internet Message Bodies

     Section 5.2, "Base64 Content-Transfer-Encoding," provides the
     definition of the base64 encoding.

   ---------- Footnotes ----------

   (1) https://tools.ietf.org/html/rfc3548.html

   (2) https://tools.ietf.org/html/rfc3548.html

   (3) https://tools.ietf.org/html/rfc3548.html

   (4) https://tools.ietf.org/html/rfc2045.html

   (5) https://tools.ietf.org/html/rfc2045.html

   (6) https://tools.ietf.org/html/rfc3548.html

   (7) https://tools.ietf.org/html/rfc2045.html

   (8) https://tools.ietf.org/html/rfc2045.html

   (9) https://tools.ietf.org/html/rfc1521.html


File: python.info,  Node: binhex --- Encode and decode binhex4 files,  Next: binascii --- Convert between binary and ASCII,  Prev: base64 --- Base16 Base32 Base64 Base85 Data Encodings,  Up: Internet Data Handling

5.19.7 ‘binhex’ — Encode and decode binhex4 files
-------------------------------------------------

This module encodes and decodes files in binhex4 format, a format
allowing representation of Macintosh files in ASCII. Only the data fork
is handled.

The *note binhex: 11. module defines the following functions:

 -- Function: binhex.binhex (input, output)

     Convert a binary file with filename `input' to binhex file
     `output'.  The `output' parameter can either be a filename or a
     file-like object (any object supporting a ‘write()’ and ‘close()’
     method).

 -- Function: binhex.hexbin (input, output)

     Decode a binhex file `input'.  `input' may be a filename or a
     file-like object supporting ‘read()’ and ‘close()’ methods.  The
     resulting file is written to a file named `output', unless the
     argument is ‘None’ in which case the output filename is read from
     the binhex file.

The following exception is also defined:

 -- Exception: binhex.Error

     Exception raised when something can’t be encoded using the binhex
     format (for example, a filename is too long to fit in the filename
     field), or when input is not properly encoded binhex data.

See also
........

Module *note binascii: 10.

     Support module containing ASCII-to-binary and binary-to-ASCII
     conversions.

* Menu:

* Notes: Notes<2>. 


File: python.info,  Node: Notes<2>,  Up: binhex --- Encode and decode binhex4 files

5.19.7.1 Notes
..............

There is an alternative, more powerful interface to the coder and
decoder, see the source for details.

If you code or decode textfiles on non-Macintosh platforms they will
still use the old Macintosh newline convention (carriage-return as end
of line).

As of this writing, *note hexbin(): 226b. appears to not work in all
cases.


File: python.info,  Node: binascii --- Convert between binary and ASCII,  Next: quopri --- Encode and decode MIME quoted-printable data,  Prev: binhex --- Encode and decode binhex4 files,  Up: Internet Data Handling

5.19.8 ‘binascii’ — Convert between binary and ASCII
----------------------------------------------------

The *note binascii: 10. module contains a number of methods to convert
between binary and various ASCII-encoded binary representations.
Normally, you will not use these functions directly but use wrapper
modules like *note uu: 120, *note base64: e, or *note binhex: 11.
instead.  The *note binascii: 10. module contains low-level functions
written in C for greater speed that are used by the higher-level
modules.

     Note: ‘a2b_*’ functions accept Unicode strings containing only
     ASCII characters.  Other functions only accept *note bytes-like
     object: 36b.s (such as *note bytes: 1db, *note bytearray: 1dc. and
     other objects that support the buffer protocol).

     Changed in version 3.3: ASCII-only unicode strings are now accepted
     by the ‘a2b_*’ functions.

The *note binascii: 10. module defines the following functions:

 -- Function: binascii.a2b_uu (string)

     Convert a single line of uuencoded data back to binary and return
     the binary data.  Lines normally contain 45 (binary) bytes, except
     for the last line.  Line data may be followed by whitespace.

 -- Function: binascii.b2a_uu (data)

     Convert binary data to a line of ASCII characters, the return value
     is the converted line, including a newline char.  The length of
     `data' should be at most 45.

 -- Function: binascii.a2b_base64 (string)

     Convert a block of base64 data back to binary and return the binary
     data.  More than one line may be passed at a time.

 -- Function: binascii.b2a_base64 (data, *, newline=True)

     Convert binary data to a line of ASCII characters in base64 coding.
     The return value is the converted line, including a newline char if
     `newline' is true.  The output of this function conforms to RFC
     3548(1).

     Changed in version 3.6: Added the `newline' parameter.

 -- Function: binascii.a2b_qp (data, header=False)

     Convert a block of quoted-printable data back to binary and return
     the binary data.  More than one line may be passed at a time.  If
     the optional argument `header' is present and true, underscores
     will be decoded as spaces.

 -- Function: binascii.b2a_qp (data, quotetabs=False, istext=True,
          header=False)

     Convert binary data to a line(s) of ASCII characters in
     quoted-printable encoding.  The return value is the converted
     line(s).  If the optional argument `quotetabs' is present and true,
     all tabs and spaces will be encoded.  If the optional argument
     `istext' is present and true, newlines are not encoded but trailing
     whitespace will be encoded.  If the optional argument `header' is
     present and true, spaces will be encoded as underscores per
     RFC1522.  If the optional argument `header' is present and false,
     newline characters will be encoded as well; otherwise linefeed
     conversion might corrupt the binary data stream.

 -- Function: binascii.a2b_hqx (string)

     Convert binhex4 formatted ASCII data to binary, without doing
     RLE-decompression.  The string should contain a complete number of
     binary bytes, or (in case of the last portion of the binhex4 data)
     have the remaining bits zero.

 -- Function: binascii.rledecode_hqx (data)

     Perform RLE-decompression on the data, as per the binhex4 standard.
     The algorithm uses ‘0x90’ after a byte as a repeat indicator,
     followed by a count.  A count of ‘0’ specifies a byte value of
     ‘0x90’.  The routine returns the decompressed data, unless data
     input data ends in an orphaned repeat indicator, in which case the
     *note Incomplete: 2279. exception is raised.

     Changed in version 3.2: Accept only bytestring or bytearray objects
     as input.

 -- Function: binascii.rlecode_hqx (data)

     Perform binhex4 style RLE-compression on `data' and return the
     result.

 -- Function: binascii.b2a_hqx (data)

     Perform hexbin4 binary-to-ASCII translation and return the
     resulting string.  The argument should already be RLE-coded, and
     have a length divisible by 3 (except possibly the last fragment).

 -- Function: binascii.crc_hqx (data, value)

     Compute the binhex4 crc value of `data', starting with `value' as
     the initial crc, and return the result.

 -- Function: binascii.crc32 (data[, value])

     Compute CRC-32, the 32-bit checksum of `data', starting with an
     initial CRC of `value'.  The default initial CRC is zero.  The
     algorithm is consistent with the ZIP file checksum.  Since the
     algorithm is designed for use as a checksum algorithm, it is not
     suitable for use as a general hash algorithm.  Use as follows:

          print(binascii.crc32(b"hello world"))
          # Or, in two pieces:
          crc = binascii.crc32(b"hello")
          crc = binascii.crc32(b" world", crc)
          print('crc32 = {:#010x}'.format(crc))

     Changed in version 3.0: The result is always unsigned.  To generate
     the same numeric value across all Python versions and platforms,
     use ‘crc32(data) & 0xffffffff’.

 -- Function: binascii.b2a_hex (data)
 -- Function: binascii.hexlify (data)

     Return the hexadecimal representation of the binary `data'.  Every
     byte of `data' is converted into the corresponding 2-digit hex
     representation.  The returned bytes object is therefore twice as
     long as the length of `data'.

 -- Function: binascii.a2b_hex (hexstr)
 -- Function: binascii.unhexlify (hexstr)

     Return the binary data represented by the hexadecimal string
     `hexstr'.  This function is the inverse of *note b2a_hex(): 1228.
     `hexstr' must contain an even number of hexadecimal digits (which
     can be upper or lower case), otherwise a *note TypeError: 562. is
     raised.

 -- Exception: binascii.Error

     Exception raised on errors.  These are usually programming errors.

 -- Exception: binascii.Incomplete

     Exception raised on incomplete data.  These are usually not
     programming errors, but may be handled by reading a little more
     data and trying again.

See also
........

Module *note base64: e.

     Support for RFC compliant base64-style encoding in base 16, 32, 64,
     and 85.

Module *note binhex: 11.

     Support for the binhex format used on the Macintosh.

Module *note uu: 120.

     Support for UU encoding used on Unix.

Module *note quopri: d9.

     Support for quoted-printable encoding used in MIME email messages.

   ---------- Footnotes ----------

   (1) https://tools.ietf.org/html/rfc3548.html


File: python.info,  Node: quopri --- Encode and decode MIME quoted-printable data,  Next: uu --- Encode and decode uuencode files,  Prev: binascii --- Convert between binary and ASCII,  Up: Internet Data Handling

5.19.9 ‘quopri’ — Encode and decode MIME quoted-printable data
--------------------------------------------------------------

`Source code:' Lib/quopri.py(1)

__________________________________________________________________

This module performs quoted-printable transport encoding and decoding,
as defined in RFC 1521(2): "MIME (Multipurpose Internet Mail Extensions)
Part One: Mechanisms for Specifying and Describing the Format of
Internet Message Bodies".  The quoted-printable encoding is designed for
data where there are relatively few nonprintable characters; the base64
encoding scheme available via the *note base64: e. module is more
compact if there are many such characters, as when sending a graphics
file.

 -- Function: quopri.decode (input, output, header=False)

     Decode the contents of the `input' file and write the resulting
     decoded binary data to the `output' file.  `input' and `output'
     must be *note binary file objects: 78b.  If the optional argument
     `header' is present and true, underscore will be decoded as space.
     This is used to decode "Q"-encoded headers as described in RFC
     1522(3): "MIME (Multipurpose Internet Mail Extensions) Part Two:
     Message Header Extensions for Non-ASCII Text".

 -- Function: quopri.encode (input, output, quotetabs, header=False)

     Encode the contents of the `input' file and write the resulting
     quoted- printable data to the `output' file.  `input' and `output'
     must be *note binary file objects: 78b.  `quotetabs', a flag which
     controls whether to encode embedded spaces and tabs must be
     provideda and when true it encodes such embedded whitespace, and
     when false it leaves them unencoded.  Note that spaces and tabs
     appearing at the end of lines are always encoded, as per RFC
     1521(4).  `header' is a flag which controls if spaces are encoded
     as underscores as per RFC 1522(5).

 -- Function: quopri.decodestring (s, header=False)

     Like *note decode(): 122b, except that it accepts a source *note
     bytes: 1db. and returns the corresponding decoded *note bytes: 1db.

 -- Function: quopri.encodestring (s, quotetabs=False, header=False)

     Like *note encode(): 122a, except that it accepts a source *note
     bytes: 1db. and returns the corresponding encoded *note bytes: 1db.
     By default, it sends a False value to `quotetabs' parameter of the
     *note encode(): 122a. function.

See also
........

Module *note base64: e.

     Encode and decode MIME base64 data

   ---------- Footnotes ----------

   (1) https://hg.python.org/cpython/file/default/Lib/quopri.py

   (2) https://tools.ietf.org/html/rfc1521.html

   (3) https://tools.ietf.org/html/rfc1522.html

   (4) https://tools.ietf.org/html/rfc1521.html

   (5) https://tools.ietf.org/html/rfc1522.html


File: python.info,  Node: uu --- Encode and decode uuencode files,  Prev: quopri --- Encode and decode MIME quoted-printable data,  Up: Internet Data Handling

5.19.10 ‘uu’ — Encode and decode uuencode files
-----------------------------------------------

`Source code:' Lib/uu.py(1)

__________________________________________________________________

This module encodes and decodes files in uuencode format, allowing
arbitrary binary data to be transferred over ASCII-only connections.
Wherever a file argument is expected, the methods accept a file-like
object.  For backwards compatibility, a string containing a pathname is
also accepted, and the corresponding file will be opened for reading and
writing; the pathname ‘'-'’ is understood to mean the standard input or
output.  However, this interface is deprecated; it’s better for the
caller to open the file itself, and be sure that, when required, the
mode is ‘'rb'’ or ‘'wb'’ on Windows.

This code was contributed by Lance Ellinghouse, and modified by Jack
Jansen.

The *note uu: 120. module defines the following functions:

 -- Function: uu.encode (in_file, out_file, name=None, mode=None)

     Uuencode file `in_file' into file `out_file'.  The uuencoded file
     will have the header specifying `name' and `mode' as the defaults
     for the results of decoding the file.  The default defaults are
     taken from `in_file', or ‘'-'’ and ‘0o666’ respectively.

 -- Function: uu.decode (in_file, out_file=None, mode=None, quiet=False)

     This call decodes uuencoded file `in_file' placing the result on
     file `out_file'.  If `out_file' is a pathname, `mode' is used to
     set the permission bits if the file must be created.  Defaults for
     `out_file' and `mode' are taken from the uuencode header.  However,
     if the file specified in the header already exists, a *note
     uu.Error: 2286. is raised.

     *note decode(): 122d. may print a warning to standard error if the
     input was produced by an incorrect uuencoder and Python could
     recover from that error.  Setting `quiet' to a true value silences
     this warning.

 -- Exception: uu.Error

     Subclass of *note Exception: 1a1, this can be raised by *note
     uu.decode(): 122d. under various situations, such as described
     above, but also including a badly formatted header, or truncated
     input file.

See also
........

Module *note binascii: 10.

     Support module containing ASCII-to-binary and binary-to-ASCII
     conversions.

   ---------- Footnotes ----------

   (1) https://hg.python.org/cpython/file/default/Lib/uu.py


File: python.info,  Node: Structured Markup Processing Tools,  Next: Internet Protocols and Support,  Prev: Internet Data Handling,  Up: The Python Standard Library

5.20 Structured Markup Processing Tools
=======================================

Python supports a variety of modules to work with various forms of
structured data markup.  This includes modules to work with the Standard
Generalized Markup Language (SGML) and the Hypertext Markup Language
(HTML), and several interfaces for working with the Extensible Markup
Language (XML).

* Menu:

* html: html --- HyperText Markup Language support. HyperText Markup Language support
* html.parser: html parser --- Simple HTML and XHTML parser. Simple HTML and XHTML parser
* html.entities: html entities --- Definitions of HTML general entities. Definitions of HTML general entities
* XML Processing Modules:: 
* xml.etree.ElementTree: xml etree ElementTree --- The ElementTree XML API. The ElementTree XML API
* xml.dom: xml dom --- The Document Object Model API. The Document Object Model API
* xml.dom.minidom: xml dom minidom --- Minimal DOM implementation. Minimal DOM implementation
* xml.dom.pulldom: xml dom pulldom --- Support for building partial DOM trees. Support for building partial DOM trees
* xml.sax: xml sax --- Support for SAX2 parsers. Support for SAX2 parsers
* xml.sax.handler: xml sax handler --- Base classes for SAX handlers. Base classes for SAX handlers
* xml.sax.saxutils: xml sax saxutils --- SAX Utilities. SAX Utilities
* xml.sax.xmlreader: xml sax xmlreader --- Interface for XML parsers. Interface for XML parsers
* xml.parsers.expat: xml parsers expat --- Fast XML parsing using Expat. Fast XML parsing using Expat


File: python.info,  Node: html --- HyperText Markup Language support,  Next: html parser --- Simple HTML and XHTML parser,  Up: Structured Markup Processing Tools

5.20.1 ‘html’ — HyperText Markup Language support
-------------------------------------------------

`Source code:' Lib/html/__init__.py(1)

__________________________________________________________________

This module defines utilities to manipulate HTML.

 -- Function: html.escape (s, quote=True)

     Convert the characters ‘&’, ‘<’ and ‘>’ in string `s' to HTML-safe
     sequences.  Use this if you need to display text that might contain
     such characters in HTML. If the optional flag `quote' is true, the
     characters (‘"’) and (‘'’) are also translated; this helps for
     inclusion in an HTML attribute value delimited by quotes, as in ‘<a
     href="...">’.

     New in version 3.2.

 -- Function: html.unescape (s)

     Convert all named and numeric character references (e.g.  ‘&gt;’,
     ‘&#62;’, ‘&x3e;’) in the string `s' to the corresponding unicode
     characters.  This function uses the rules defined by the HTML 5
     standard for both valid and invalid character references, and the
     *note list of HTML 5 named character references: 642.

     New in version 3.4.

__________________________________________________________________

Submodules in the ‘html’ package are:

   * *note html.parser: 91. – HTML/XHTML parser with lenient parsing
     mode

   * *note html.entities: 90. – HTML entity definitions

   ---------- Footnotes ----------

   (1) https://hg.python.org/cpython/file/default/Lib/html/__init__.py


File: python.info,  Node: html parser --- Simple HTML and XHTML parser,  Next: html entities --- Definitions of HTML general entities,  Prev: html --- HyperText Markup Language support,  Up: Structured Markup Processing Tools

5.20.2 ‘html.parser’ — Simple HTML and XHTML parser
---------------------------------------------------

`Source code:' Lib/html/parser.py(1)

__________________________________________________________________

This module defines a class *note HTMLParser: 3a9. which serves as the
basis for parsing text files formatted in HTML (HyperText Mark-up
Language) and XHTML.

 -- Class: html.parser.HTMLParser (*, convert_charrefs=True)

     Create a parser instance able to parse invalid markup.

     If `convert_charrefs' is ‘True’ (the default), all character
     references (except the ones in ‘script’/‘style’ elements) are
     automatically converted to the corresponding Unicode characters.

     An *note HTMLParser: 3a9. instance is fed HTML data and calls
     handler methods when start tags, end tags, text, comments, and
     other markup elements are encountered.  The user should subclass
     *note HTMLParser: 3a9. and override its methods to implement the
     desired behavior.

     This parser does not check that end tags match start tags or call
     the end-tag handler for elements which are closed implicitly by
     closing an outer element.

     Changed in version 3.4: `convert_charrefs' keyword argument added.

     Changed in version 3.5: The default value for argument
     `convert_charrefs' is now ‘True’.

* Menu:

* Example HTML Parser Application:: 
* HTMLParser Methods:: 
* Examples: Examples<13>. 

   ---------- Footnotes ----------

   (1) https://hg.python.org/cpython/file/default/Lib/html/parser.py


File: python.info,  Node: Example HTML Parser Application,  Next: HTMLParser Methods,  Up: html parser --- Simple HTML and XHTML parser

5.20.2.1 Example HTML Parser Application
........................................

As a basic example, below is a simple HTML parser that uses the *note
HTMLParser: 3a9. class to print out start tags, end tags, and data as
they are encountered:

     from html.parser import HTMLParser

     class MyHTMLParser(HTMLParser):
         def handle_starttag(self, tag, attrs):
             print("Encountered a start tag:", tag)
         def handle_endtag(self, tag):
             print("Encountered an end tag :", tag)
         def handle_data(self, data):
             print("Encountered some data  :", data)

     parser = MyHTMLParser()
     parser.feed('<html><head><title>Test</title></head>'
                 '<body><h1>Parse me!</h1></body></html>')

The output will then be:

     Encountered a start tag: html
     Encountered a start tag: head
     Encountered a start tag: title
     Encountered some data  : Test
     Encountered an end tag : title
     Encountered an end tag : head
     Encountered a start tag: body
     Encountered a start tag: h1
     Encountered some data  : Parse me!
     Encountered an end tag : h1
     Encountered an end tag : body
     Encountered an end tag : html


File: python.info,  Node: HTMLParser Methods,  Next: Examples<13>,  Prev: Example HTML Parser Application,  Up: html parser --- Simple HTML and XHTML parser

5.20.2.2 ‘HTMLParser’ Methods
.............................

*note HTMLParser: 3a9. instances have the following methods:

 -- Method: HTMLParser.feed (data)

     Feed some text to the parser.  It is processed insofar as it
     consists of complete elements; incomplete data is buffered until
     more data is fed or *note close(): 2291. is called.  `data' must be
     *note str: 25a.

 -- Method: HTMLParser.close ()

     Force processing of all buffered data as if it were followed by an
     end-of-file mark.  This method may be redefined by a derived class
     to define additional processing at the end of the input, but the
     redefined version should always call the *note HTMLParser: 3a9.
     base class method *note close(): 2291.

 -- Method: HTMLParser.reset ()

     Reset the instance.  Loses all unprocessed data.  This is called
     implicitly at instantiation time.

 -- Method: HTMLParser.getpos ()

     Return current line number and offset.

 -- Method: HTMLParser.get_starttag_text ()

     Return the text of the most recently opened start tag.  This should
     not normally be needed for structured processing, but may be useful
     in dealing with HTML "as deployed" or for re-generating input with
     minimal changes (whitespace between attributes can be preserved,
     etc.).

The following methods are called when data or markup elements are
encountered and they are meant to be overridden in a subclass.  The base
class implementations do nothing (except for *note handle_startendtag():
2295.):

 -- Method: HTMLParser.handle_starttag (tag, attrs)

     This method is called to handle the start of a tag (e.g.  ‘<div
     id="main">’).

     The `tag' argument is the name of the tag converted to lower case.
     The `attrs' argument is a list of ‘(name, value)’ pairs containing
     the attributes found inside the tag’s ‘<>’ brackets.  The `name'
     will be translated to lower case, and quotes in the `value' have
     been removed, and character and entity references have been
     replaced.

     For instance, for the tag ‘<A HREF="http://www.cwi.nl/">’, this
     method would be called as ‘handle_starttag('a', [('href',
     'http://www.cwi.nl/')])’.

     All entity references from *note html.entities: 90. are replaced in
     the attribute values.

 -- Method: HTMLParser.handle_endtag (tag)

     This method is called to handle the end tag of an element (e.g.
     ‘</div>’).

     The `tag' argument is the name of the tag converted to lower case.

 -- Method: HTMLParser.handle_startendtag (tag, attrs)

     Similar to *note handle_starttag(): 2296, but called when the
     parser encounters an XHTML-style empty tag (‘<img ... />’).  This
     method may be overridden by subclasses which require this
     particular lexical information; the default implementation simply
     calls *note handle_starttag(): 2296. and *note handle_endtag():
     2297.

 -- Method: HTMLParser.handle_data (data)

     This method is called to process arbitrary data (e.g.  text nodes
     and the content of ‘<script>...</script>’ and
     ‘<style>...</style>’).

 -- Method: HTMLParser.handle_entityref (name)

     This method is called to process a named character reference of the
     form ‘&name;’ (e.g.  ‘&gt;’), where `name' is a general entity
     reference (e.g.  ‘'gt'’).  This method is never called if
     `convert_charrefs' is ‘True’.

 -- Method: HTMLParser.handle_charref (name)

     This method is called to process decimal and hexadecimal numeric
     character references of the form ‘&#NNN;’ and ‘&#xNNN;’.  For
     example, the decimal equivalent for ‘&gt;’ is ‘&#62;’, whereas the
     hexadecimal is ‘&#x3E;’; in this case the method will receive
     ‘'62'’ or ‘'x3E'’.  This method is never called if
     `convert_charrefs' is ‘True’.

 -- Method: HTMLParser.handle_comment (data)

     This method is called when a comment is encountered (e.g.
     ‘<!--comment-->’).

     For example, the comment ‘<!-- comment -->’ will cause this method
     to be called with the argument ‘' comment '’.

     The content of Internet Explorer conditional comments (condcoms)
     will also be sent to this method, so, for ‘<!--[if IE
     9]>IE9-specific content<![endif]-->’, this method will receive
     ‘'[if IE 9]>IE9-specific content<![endif]'’.

 -- Method: HTMLParser.handle_decl (decl)

     This method is called to handle an HTML doctype declaration (e.g.
     ‘<!DOCTYPE html>’).

     The `decl' parameter will be the entire contents of the declaration
     inside the ‘<!...>’ markup (e.g.  ‘'DOCTYPE html'’).

 -- Method: HTMLParser.handle_pi (data)

     Method called when a processing instruction is encountered.  The
     `data' parameter will contain the entire processing instruction.
     For example, for the processing instruction ‘<?proc color='red'>’,
     this method would be called as ‘handle_pi("proc color='red'")’.  It
     is intended to be overridden by a derived class; the base class
     implementation does nothing.

          Note: The *note HTMLParser: 3a9. class uses the SGML syntactic
          rules for processing instructions.  An XHTML processing
          instruction using the trailing ‘'?'’ will cause the ‘'?'’ to
          be included in `data'.

 -- Method: HTMLParser.unknown_decl (data)

     This method is called when an unrecognized declaration is read by
     the parser.

     The `data' parameter will be the entire contents of the declaration
     inside the ‘<![...]>’ markup.  It is sometimes useful to be
     overridden by a derived class.  The base class implementation does
     nothing.


File: python.info,  Node: Examples<13>,  Prev: HTMLParser Methods,  Up: html parser --- Simple HTML and XHTML parser

5.20.2.3 Examples
.................

The following class implements a parser that will be used to illustrate
more examples:

     from html.parser import HTMLParser
     from html.entities import name2codepoint

     class MyHTMLParser(HTMLParser):
         def handle_starttag(self, tag, attrs):
             print("Start tag:", tag)
             for attr in attrs:
                 print("     attr:", attr)
         def handle_endtag(self, tag):
             print("End tag  :", tag)
         def handle_data(self, data):
             print("Data     :", data)
         def handle_comment(self, data):
             print("Comment  :", data)
         def handle_entityref(self, name):
             c = chr(name2codepoint[name])
             print("Named ent:", c)
         def handle_charref(self, name):
             if name.startswith('x'):
                 c = chr(int(name[1:], 16))
             else:
                 c = chr(int(name))
             print("Num ent  :", c)
         def handle_decl(self, data):
             print("Decl     :", data)

     parser = MyHTMLParser()

Parsing a doctype:

     >>> parser.feed('<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" '
     ...             '"http://www.w3.org/TR/html4/strict.dtd">')
     Decl     : DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd"

Parsing an element with a few attributes and a title:

     >>> parser.feed('<img src="python-logo.png" alt="The Python logo">')
     Start tag: img
          attr: ('src', 'python-logo.png')
          attr: ('alt', 'The Python logo')
     >>>
     >>> parser.feed('<h1>Python</h1>')
     Start tag: h1
     Data     : Python
     End tag  : h1

The content of ‘script’ and ‘style’ elements is returned as is, without
further parsing:

     >>> parser.feed('<style type="text/css">#python { color: green }</style>')
     Start tag: style
          attr: ('type', 'text/css')
     Data     : #python { color: green }
     End tag  : style
     >>>
     >>> parser.feed('<script type="text/javascript">'
     ...             'alert("<strong>hello!</strong>");</script>')
     Start tag: script
          attr: ('type', 'text/javascript')
     Data     : alert("<strong>hello!</strong>");
     End tag  : script

Parsing comments:

     >>> parser.feed('<!-- a comment -->'
     ...             '<!--[if IE 9]>IE-specific content<![endif]-->')
     Comment  :  a comment
     Comment  : [if IE 9]>IE-specific content<![endif]

Parsing named and numeric character references and converting them to
the correct char (note: these 3 references are all equivalent to ‘'>'’):

     >>> parser.feed('&gt;&#62;&#x3E;')
     Named ent: >
     Num ent  : >
     Num ent  : >

Feeding incomplete chunks to *note feed(): 2290. works, but *note
handle_data(): 2298. might be called more than once (unless
`convert_charrefs' is set to ‘True’):

     >>> for chunk in ['<sp', 'an>buff', 'ered ', 'text</s', 'pan>']:
     ...     parser.feed(chunk)
     ...
     Start tag: span
     Data     : buff
     Data     : ered
     Data     : text
     End tag  : span

Parsing invalid HTML (e.g.  unquoted attributes) also works:

     >>> parser.feed('<p><a class=link href=#main>tag soup</p ></a>')
     Start tag: p
     Start tag: a
          attr: ('class', 'link')
          attr: ('href', '#main')
     Data     : tag soup
     End tag  : p
     End tag  : a


File: python.info,  Node: html entities --- Definitions of HTML general entities,  Next: XML Processing Modules,  Prev: html parser --- Simple HTML and XHTML parser,  Up: Structured Markup Processing Tools

5.20.3 ‘html.entities’ — Definitions of HTML general entities
-------------------------------------------------------------

`Source code:' Lib/html/entities.py(1)

__________________________________________________________________

This module defines four dictionaries, *note html5: 642, *note
name2codepoint: 22a3, *note codepoint2name: 22a4, and *note entitydefs:
22a5.

 -- Data: html.entities.html5

     A dictionary that maps HTML5 named character references (2) to the
     equivalent Unicode character(s), e.g.  ‘html5['gt;'] == '>'’.  Note
     that the trailing semicolon is included in the name (e.g.
     ‘'gt;'’), however some of the names are accepted by the standard
     even without the semicolon: in this case the name is present with
     and without the ‘';'’.  See also *note html.unescape(): 44f.

     New in version 3.3.

 -- Data: html.entities.entitydefs

     A dictionary mapping XHTML 1.0 entity definitions to their
     replacement text in ISO Latin-1.

 -- Data: html.entities.name2codepoint

     A dictionary that maps HTML entity names to the Unicode code
     points.

 -- Data: html.entities.codepoint2name

     A dictionary that maps Unicode code points to HTML entity names.

   ---------- Footnotes ----------

   (1) https://hg.python.org/cpython/file/default/Lib/html/entities.py

   (2) See
‘http://www.w3.org/TR/html5/syntax.html#named-character-references’


File: python.info,  Node: XML Processing Modules,  Next: xml etree ElementTree --- The ElementTree XML API,  Prev: html entities --- Definitions of HTML general entities,  Up: Structured Markup Processing Tools

5.20.4 XML Processing Modules
-----------------------------

Python’s interfaces for processing XML are grouped in the ‘xml’ package.

     Warning: The XML modules are not secure against erroneous or
     maliciously constructed data.  If you need to parse untrusted or
     unauthenticated data see the *note XML vulnerabilities: 22a9. and
     *note The defusedxml and defusedexpat Packages: 22aa. sections.

It is important to note that modules in the *note xml: 130. package
require that there be at least one SAX-compliant XML parser available.
The Expat parser is included with Python, so the *note
xml.parsers.expat: 135. module will always be available.

The documentation for the *note xml.dom: 131. and *note xml.sax: 138.
packages are the definition of the Python bindings for the DOM and SAX
interfaces.

The XML handling submodules are:

   * *note xml.etree.ElementTree: 134.: the ElementTree API, a simple
     and lightweight XML processor

   * *note xml.dom: 131.: the DOM API definition

   * *note xml.dom.minidom: 132.: a minimal DOM implementation

   * *note xml.dom.pulldom: 133.: support for building partial DOM trees

   * *note xml.sax: 138.: SAX2 base classes and convenience functions

   * *note xml.parsers.expat: 135.: the Expat parser binding

* Menu:

* XML vulnerabilities:: 
* The defusedxml and defusedexpat Packages:: 


File: python.info,  Node: XML vulnerabilities,  Next: The defusedxml and defusedexpat Packages,  Up: XML Processing Modules

5.20.4.1 XML vulnerabilities
............................

The XML processing modules are not secure against maliciously
constructed data.  An attacker can abuse XML features to carry out
denial of service attacks, access local files, generate network
connections to other machines, or circumvent firewalls.

The following table gives an overview of the known attacks and whether
the various modules are vulnerable to them.

kind                          sax          etree         minidom       pulldom      xmlrpc
                                                                                    
--------------------------------------------------------------------------------------------------
                                                                                    
billion laughs                `Yes'        `Yes'         `Yes'         `Yes'        `Yes'
                                                                                    
                                                                                    
quadratic blowup              `Yes'        `Yes'         `Yes'         `Yes'        `Yes'
                                                                                    
                                                                                    
external entity expansion     `Yes'        No (1)        No (2)        `Yes'        No (3)
                                                                                    
                                                                                    
DTD(1) retrieval              `Yes'        No            No            `Yes'        No
                                                                                    
                                                                                    
decompression bomb            No           No            No            No           `Yes'
                                                                                    

  1. *note xml.etree.ElementTree: 134. doesn’t expand external entities
     and raises a ‘ParserError’ when an entity occurs.

  2. *note xml.dom.minidom: 132. doesn’t expand external entities and
     simply returns the unexpanded entity verbatim.

  3. ‘xmlrpclib’ doesn’t expand external entities and omits them.

billion laughs / exponential entity expansion

     The Billion Laughs(2) attack – also known as exponential entity
     expansion – uses multiple levels of nested entities.  Each entity
     refers to another entity several times, and the final entity
     definition contains a small string.  The exponential expansion
     results in several gigabytes of text and consumes lots of memory
     and CPU time.

quadratic blowup entity expansion

     A quadratic blowup attack is similar to a Billion Laughs(3) attack;
     it abuses entity expansion, too.  Instead of nested entities it
     repeats one large entity with a couple of thousand chars over and
     over again.  The attack isn’t as efficient as the exponential case
     but it avoids triggering parser countermeasures that forbid
     deeply-nested entities.

external entity expansion

     Entity declarations can contain more than just text for
     replacement.  They can also point to external resources or local
     files.  The XML parser accesses the resource and embeds the content
     into the XML document.

DTD(4) retrieval

     Some XML libraries like Python’s *note xml.dom.pulldom: 133.
     retrieve document type definitions from remote or local locations.
     The feature has similar implications as the external entity
     expansion issue.

decompression bomb

     Decompression bombs (aka ZIP bomb(5)) apply to all XML libraries
     that can parse compressed XML streams such as gzipped HTTP streams
     or LZMA-compressed files.  For an attacker it can reduce the amount
     of transmitted data by three magnitudes or more.

The documentation for defusedxml(6) on PyPI has further information
about all known attack vectors with examples and references.

   ---------- Footnotes ----------

   (1) https://en.wikipedia.org/wiki/Document_type_definition

   (2) https://en.wikipedia.org/wiki/Billion_laughs

   (3) https://en.wikipedia.org/wiki/Billion_laughs

   (4) https://en.wikipedia.org/wiki/Document_type_definition

   (5) https://en.wikipedia.org/wiki/Zip_bomb

   (6) https://pypi.python.org/pypi/defusedxml/


File: python.info,  Node: The defusedxml and defusedexpat Packages,  Prev: XML vulnerabilities,  Up: XML Processing Modules

5.20.4.2 The ‘defusedxml’ and ‘defusedexpat’ Packages
.....................................................

defusedxml(1) is a pure Python package with modified subclasses of all
stdlib XML parsers that prevent any potentially malicious operation.
Use of this package is recommended for any server code that parses
untrusted XML data.  The package also ships with example exploits and
extended documentation on more XML exploits such as XPath injection.

defusedexpat(2) provides a modified libexpat and a patched ‘pyexpat’
module that have countermeasures against entity expansion DoS attacks.
The ‘defusedexpat’ module still allows a sane and configurable amount of
entity expansions.  The modifications may be included in some future
release of Python, but will not be included in any bugfix releases of
Python because they break backward compatibility.

   ---------- Footnotes ----------

   (1) https://pypi.python.org/pypi/defusedxml/

   (2) https://pypi.python.org/pypi/defusedexpat/


File: python.info,  Node: xml etree ElementTree --- The ElementTree XML API,  Next: xml dom --- The Document Object Model API,  Prev: XML Processing Modules,  Up: Structured Markup Processing Tools

5.20.5 ‘xml.etree.ElementTree’ — The ElementTree XML API
--------------------------------------------------------

The *note xml.etree.ElementTree: 134. module implements a simple and
efficient API for parsing and creating XML data.

Changed in version 3.3: This module will use a fast implementation
whenever available.  The ‘xml.etree.cElementTree’ module is deprecated.

     Warning: The *note xml.etree.ElementTree: 134. module is not secure
     against maliciously constructed data.  If you need to parse
     untrusted or unauthenticated data see *note XML vulnerabilities:
     22a9.

* Menu:

* Tutorial:: 
* XPath support:: 
* Reference: Reference<2>. 


File: python.info,  Node: Tutorial,  Next: XPath support,  Up: xml etree ElementTree --- The ElementTree XML API

5.20.5.1 Tutorial
.................

This is a short tutorial for using *note xml.etree.ElementTree: 134.
(‘ET’ in short).  The goal is to demonstrate some of the building blocks
and basic concepts of the module.

* Menu:

* XML tree and elements:: 
* Parsing XML:: 
* Pull API for non-blocking parsing:: 
* Finding interesting elements:: 
* Modifying an XML File:: 
* Building XML documents:: 
* Parsing XML with Namespaces:: 
* Additional resources:: 


File: python.info,  Node: XML tree and elements,  Next: Parsing XML,  Up: Tutorial

5.20.5.2 XML tree and elements
..............................

XML is an inherently hierarchical data format, and the most natural way
to represent it is with a tree.  ‘ET’ has two classes for this purpose -
*note ElementTree: 51b. represents the whole XML document as a tree, and
*note Element: 700. represents a single node in this tree.  Interactions
with the whole document (reading and writing to/from files) are usually
done on the *note ElementTree: 51b. level.  Interactions with a single
XML element and its sub-elements are done on the *note Element: 700.
level.


File: python.info,  Node: Parsing XML,  Next: Pull API for non-blocking parsing,  Prev: XML tree and elements,  Up: Tutorial

5.20.5.3 Parsing XML
....................

We’ll be using the following XML document as the sample data for this
section:

     <?xml version="1.0"?>
     <data>
         <country name="Liechtenstein">
             <rank>1</rank>
             <year>2008</year>
             <gdppc>141100</gdppc>
             <neighbor name="Austria" direction="E"/>
             <neighbor name="Switzerland" direction="W"/>
         </country>
         <country name="Singapore">
             <rank>4</rank>
             <year>2011</year>
             <gdppc>59900</gdppc>
             <neighbor name="Malaysia" direction="N"/>
         </country>
         <country name="Panama">
             <rank>68</rank>
             <year>2011</year>
             <gdppc>13600</gdppc>
             <neighbor name="Costa Rica" direction="W"/>
             <neighbor name="Colombia" direction="E"/>
         </country>
     </data>

We can import this data by reading from a file:

     import xml.etree.ElementTree as ET
     tree = ET.parse('country_data.xml')
     root = tree.getroot()

Or directly from a string:

     root = ET.fromstring(country_data_as_string)

*note fromstring(): 22b4. parses XML from a string directly into an
*note Element: 700, which is the root element of the parsed tree.  Other
parsing functions may create an *note ElementTree: 51b.  Check the
documentation to be sure.

As an *note Element: 700, ‘root’ has a tag and a dictionary of
attributes:

     >>> root.tag
     'data'
     >>> root.attrib
     {}

It also has children nodes over which we can iterate:

     >>> for child in root:
     ...   print(child.tag, child.attrib)
     ...
     country {'name': 'Liechtenstein'}
     country {'name': 'Singapore'}
     country {'name': 'Panama'}

Children are nested, and we can access specific child nodes by index:

     >>> root[0][1].text
     '2008'

     Note: Not all elements of the XML input will end up as elements of
     the parsed tree.  Currently, this module skips over any XML
     comments, processing instructions, and document type declarations
     in the input.  Nevertheless, trees built using this module’s API
     rather than parsing from XML text can have comments and processing
     instructions in them; they will be included when generating XML
     output.  A document type declaration may be accessed by passing a
     custom *note TreeBuilder: 22b5. instance to the *note XMLParser:
     559. constructor.


File: python.info,  Node: Pull API for non-blocking parsing,  Next: Finding interesting elements,  Prev: Parsing XML,  Up: Tutorial

5.20.5.4 Pull API for non-blocking parsing
..........................................

Most parsing functions provided by this module require the whole
document to be read at once before returning any result.  It is possible
to use an *note XMLParser: 559. and feed data into it incrementally, but
it is a push API that calls methods on a callback target, which is too
low-level and inconvenient for most needs.  Sometimes what the user
really wants is to be able to parse XML incrementally, without blocking
operations, while enjoying the convenience of fully constructed *note
Element: 700. objects.

The most powerful tool for doing this is *note XMLPullParser: 517.  It
does not require a blocking read to obtain the XML data, and is instead
fed with data incrementally with *note XMLPullParser.feed(): 22b7.
calls.  To get the parsed XML elements, call *note
XMLPullParser.read_events(): 22b8.  Here is an example:

     >>> parser = ET.XMLPullParser(['start', 'end'])
     >>> parser.feed('<mytag>sometext')
     >>> list(parser.read_events())
     [('start', <Element 'mytag' at 0x7fa66db2be58>)]
     >>> parser.feed(' more text</mytag>')
     >>> for event, elem in parser.read_events():
     ...   print(event)
     ...   print(elem.tag, 'text=', elem.text)
     ...
     end

The obvious use case is applications that operate in a non-blocking
fashion where the XML data is being received from a socket or read
incrementally from some storage device.  In such cases, blocking reads
are unacceptable.

Because it’s so flexible, *note XMLPullParser: 517. can be inconvenient
to use for simpler use-cases.  If you don’t mind your application
blocking on reading XML data but would still like to have incremental
parsing capabilities, take a look at *note iterparse(): 558.  It can be
useful when you’re reading a large XML document and don’t want to hold
it wholly in memory.


File: python.info,  Node: Finding interesting elements,  Next: Modifying an XML File,  Prev: Pull API for non-blocking parsing,  Up: Tutorial

5.20.5.5 Finding interesting elements
.....................................

*note Element: 700. has some useful methods that help iterate
recursively over all the sub-tree below it (its children, their
children, and so on).  For example, *note Element.iter(): 95f.:

     >>> for neighbor in root.iter('neighbor'):
     ...   print(neighbor.attrib)
     ...
     {'name': 'Austria', 'direction': 'E'}
     {'name': 'Switzerland', 'direction': 'W'}
     {'name': 'Malaysia', 'direction': 'N'}
     {'name': 'Costa Rica', 'direction': 'W'}
     {'name': 'Colombia', 'direction': 'E'}

*note Element.findall(): 22ba. finds only elements with a tag which are
direct children of the current element.  *note Element.find(): 22bb.
finds the `first' child with a particular tag, and *note Element.text:
22bc. accesses the element’s text content.  *note Element.get(): 22bd.
accesses the element’s attributes:

     >>> for country in root.findall('country'):
     ...   rank = country.find('rank').text
     ...   name = country.get('name')
     ...   print(name, rank)
     ...
     Liechtenstein 1
     Singapore 4
     Panama 68

More sophisticated specification of which elements to look for is
possible by using *note XPath: 22be.


File: python.info,  Node: Modifying an XML File,  Next: Building XML documents,  Prev: Finding interesting elements,  Up: Tutorial

5.20.5.6 Modifying an XML File
..............................

*note ElementTree: 51b. provides a simple way to build XML documents and
write them to files.  The *note ElementTree.write(): 51c. method serves
this purpose.

Once created, an *note Element: 700. object may be manipulated by
directly changing its fields (such as *note Element.text: 22bc.), adding
and modifying attributes (*note Element.set(): 22c0. method), as well as
adding new children (for example with *note Element.append(): 22c1.).

Let’s say we want to add one to each country’s rank, and add an
‘updated’ attribute to the rank element:

     >>> for rank in root.iter('rank'):
     ...   new_rank = int(rank.text) + 1
     ...   rank.text = str(new_rank)
     ...   rank.set('updated', 'yes')
     ...
     >>> tree.write('output.xml')

Our XML now looks like this:

     <?xml version="1.0"?>
     <data>
         <country name="Liechtenstein">
             <rank updated="yes">2</rank>
             <year>2008</year>
             <gdppc>141100</gdppc>
             <neighbor name="Austria" direction="E"/>
             <neighbor name="Switzerland" direction="W"/>
         </country>
         <country name="Singapore">
             <rank updated="yes">5</rank>
             <year>2011</year>
             <gdppc>59900</gdppc>
             <neighbor name="Malaysia" direction="N"/>
         </country>
         <country name="Panama">
             <rank updated="yes">69</rank>
             <year>2011</year>
             <gdppc>13600</gdppc>
             <neighbor name="Costa Rica" direction="W"/>
             <neighbor name="Colombia" direction="E"/>
         </country>
     </data>

We can remove elements using *note Element.remove(): 22c2.  Let’s say we
want to remove all countries with a rank higher than 50:

     >>> for country in root.findall('country'):
     ...   rank = int(country.find('rank').text)
     ...   if rank > 50:
     ...     root.remove(country)
     ...
     >>> tree.write('output.xml')

Our XML now looks like this:

     <?xml version="1.0"?>
     <data>
         <country name="Liechtenstein">
             <rank updated="yes">2</rank>
             <year>2008</year>
             <gdppc>141100</gdppc>
             <neighbor name="Austria" direction="E"/>
             <neighbor name="Switzerland" direction="W"/>
         </country>
         <country name="Singapore">
             <rank updated="yes">5</rank>
             <year>2011</year>
             <gdppc>59900</gdppc>
             <neighbor name="Malaysia" direction="N"/>
         </country>
     </data>


File: python.info,  Node: Building XML documents,  Next: Parsing XML with Namespaces,  Prev: Modifying an XML File,  Up: Tutorial

5.20.5.7 Building XML documents
...............................

The *note SubElement(): 22c4. function also provides a convenient way to
create new sub-elements for a given element:

     >>> a = ET.Element('a')
     >>> b = ET.SubElement(a, 'b')
     >>> c = ET.SubElement(a, 'c')
     >>> d = ET.SubElement(c, 'd')
     >>> ET.dump(a)
     <a><b /><c><d /></c></a>


File: python.info,  Node: Parsing XML with Namespaces,  Next: Additional resources,  Prev: Building XML documents,  Up: Tutorial

5.20.5.8 Parsing XML with Namespaces
....................................

If the XML input has namespaces(1), tags and attributes with prefixes in
the form ‘prefix:sometag’ get expanded to ‘{uri}sometag’ where the
`prefix' is replaced by the full `URI'. Also, if there is a default
namespace(2), that full URI gets prepended to all of the non-prefixed
tags.

Here is an XML example that incorporates two namespaces, one with the
prefix "fictional" and the other serving as the default namespace:

     <?xml version="1.0"?>
     <actors xmlns:fictional="http://characters.example.com"
             xmlns="http://people.example.com">
         <actor>
             <name>John Cleese</name>
             <fictional:character>Lancelot</fictional:character>
             <fictional:character>Archie Leach</fictional:character>
         </actor>
         <actor>
             <name>Eric Idle</name>
             <fictional:character>Sir Robin</fictional:character>
             <fictional:character>Gunther</fictional:character>
             <fictional:character>Commander Clement</fictional:character>
         </actor>
     </actors>

One way to search and explore this XML example is to manually add the
URI to every tag or attribute in the xpath of a *note find(): 22bb. or
*note findall(): 22ba.:

     root = fromstring(xml_text)
     for actor in root.findall('{http://people.example.com}actor'):
         name = actor.find('{http://people.example.com}name')
         print(name.text)
         for char in actor.findall('{http://characters.example.com}character'):
             print(' |-->', char.text)

A better way to search the namespaced XML example is to create a
dictionary with your own prefixes and use those in the search functions:

     ns = {'real_person': 'http://people.example.com',
           'role': 'http://characters.example.com'}

     for actor in root.findall('real_person:actor', ns):
         name = actor.find('real_person:name', ns)
         print(name.text)
         for char in actor.findall('role:character', ns):
             print(' |-->', char.text)

These two approaches both output:

     John Cleese
      |--> Lancelot
      |--> Archie Leach
     Eric Idle
      |--> Sir Robin
      |--> Gunther
      |--> Commander Clement

   ---------- Footnotes ----------

   (1) https://en.wikipedia.org/wiki/XML_namespace

   (2) http://www.w3.org/TR/2006/REC-xml-names-20060816/#defaulting


File: python.info,  Node: Additional resources,  Prev: Parsing XML with Namespaces,  Up: Tutorial

5.20.5.9 Additional resources
.............................

See ‘http://effbot.org/zone/element-index.htm’ for tutorials and links
to other docs.


File: python.info,  Node: XPath support,  Next: Reference<2>,  Prev: Tutorial,  Up: xml etree ElementTree --- The ElementTree XML API

5.20.5.10 XPath support
.......................

This module provides limited support for XPath expressions(1) for
locating elements in a tree.  The goal is to support a small subset of
the abbreviated syntax; a full XPath engine is outside the scope of the
module.

* Menu:

* Example: Example<9>. 
* Supported XPath syntax:: 

   ---------- Footnotes ----------

   (1) http://www.w3.org/TR/xpath


File: python.info,  Node: Example<9>,  Next: Supported XPath syntax,  Up: XPath support

5.20.5.11 Example
.................

Here’s an example that demonstrates some of the XPath capabilities of
the module.  We’ll be using the ‘countrydata’ XML document from the
*note Parsing XML: 22b2. section:

     import xml.etree.ElementTree as ET

     root = ET.fromstring(countrydata)

     # Top-level elements
     root.findall(".")

     # All 'neighbor' grand-children of 'country' children of the top-level
     # elements
     root.findall("./country/neighbor")

     # Nodes with name='Singapore' that have a 'year' child
     root.findall(".//year/..[@name='Singapore']")

     # 'year' nodes that are children of nodes with name='Singapore'
     root.findall(".//*[@name='Singapore']/year")

     # All 'neighbor' nodes that are the second child of their parent
     root.findall(".//neighbor[2]")


File: python.info,  Node: Supported XPath syntax,  Prev: Example<9>,  Up: XPath support

5.20.5.12 Supported XPath syntax
................................

Syntax                      Meaning
                            
---------------------------------------------------------------------------------------
                            
‘tag’                       Selects all child elements with the given tag.  For
                            example, ‘spam’ selects all child elements named ‘spam’,
                            and ‘spam/egg’ selects all grandchildren named ‘egg’ in
                            all children named ‘spam’.
                            
                            
‘*’                         Selects all child elements.  For example, ‘*/egg’
                            selects all grandchildren named ‘egg’.
                            
                            
‘.’                         Selects the current node.  This is mostly useful at the
                            beginning of the path, to indicate that it’s a relative
                            path.
                            
                            
‘//’                        Selects all subelements, on all levels beneath the
                            current element.  For example, ‘.//egg’ selects all
                            ‘egg’ elements in the entire tree.
                            
                            
‘..’                        Selects the parent element.  Returns ‘None’ if the path
                            attempts to reach the ancestors of the start element
                            (the element ‘find’ was called on).
                            
                            
‘[@attrib]’                 Selects all elements that have the given attribute.
                            
                            
‘[@attrib='value']’         Selects all elements for which the given attribute has
                            the given value.  The value cannot contain quotes.
                            
                            
‘[tag]’                     Selects all elements that have a child named ‘tag’.
                            Only immediate children are supported.
                            
                            
‘[tag='text']’              Selects all elements that have a child named ‘tag’ whose
                            complete text content, including descendants, equals the
                            given ‘text’.
                            
                            
‘[position]’                Selects all elements that are located at the given
                            position.  The position can be either an integer (1 is
                            the first position), the expression ‘last()’ (for the
                            last position), or a position relative to the last
                            position (e.g.  ‘last()-1’).
                            

Predicates (expressions within square brackets) must be preceded by a
tag name, an asterisk, or another predicate.  ‘position’ predicates must
be preceded by a tag name.


File: python.info,  Node: Reference<2>,  Prev: XPath support,  Up: xml etree ElementTree --- The ElementTree XML API

5.20.5.13 Reference
...................

* Menu:

* Functions: Functions<5>. 
* Element Objects:: 
* ElementTree Objects:: 
* QName Objects:: 
* TreeBuilder Objects:: 
* XMLParser Objects:: 
* XMLPullParser Objects:: 
* Exceptions: Exceptions<11>. 


File: python.info,  Node: Functions<5>,  Next: Element Objects,  Up: Reference<2>

5.20.5.14 Functions
...................

 -- Function: xml.etree.ElementTree.Comment (text=None)

     Comment element factory.  This factory function creates a special
     element that will be serialized as an XML comment by the standard
     serializer.  The comment string can be either a bytestring or a
     Unicode string.  `text' is a string containing the comment string.
     Returns an element instance representing a comment.

     Note that *note XMLParser: 559. skips over comments in the input
     instead of creating comment objects for them.  An *note
     ElementTree: 51b. will only contain comment nodes if they have been
     inserted into to the tree using one of the *note Element: 700.
     methods.

 -- Function: xml.etree.ElementTree.dump (elem)

     Writes an element tree or element structure to sys.stdout.  This
     function should be used for debugging only.

     The exact output format is implementation dependent.  In this
     version, it’s written as an ordinary XML file.

     `elem' is an element tree or an individual element.

 -- Function: xml.etree.ElementTree.fromstring (text)

     Parses an XML section from a string constant.  Same as *note XML():
     22cf.  `text' is a string containing XML data.  Returns an *note
     Element: 700. instance.

 -- Function: xml.etree.ElementTree.fromstringlist (sequence,
          parser=None)

     Parses an XML document from a sequence of string fragments.
     `sequence' is a list or other sequence containing XML data
     fragments.  `parser' is an optional parser instance.  If not given,
     the standard *note XMLParser: 559. parser is used.  Returns an
     *note Element: 700. instance.

     New in version 3.2.

 -- Function: xml.etree.ElementTree.iselement (element)

     Checks if an object appears to be a valid element object.
     `element' is an element instance.  Returns a true value if this is
     an element object.

 -- Function: xml.etree.ElementTree.iterparse (source, events=None,
          parser=None)

     Parses an XML section into an element tree incrementally, and
     reports what’s going on to the user.  `source' is a filename or
     *note file object: 78b. containing XML data.  `events' is a
     sequence of events to report back.  The supported events are the
     strings ‘"start"’, ‘"end"’, ‘"start-ns"’ and ‘"end-ns"’ (the "ns"
     events are used to get detailed namespace information).  If
     `events' is omitted, only ‘"end"’ events are reported.  `parser' is
     an optional parser instance.  If not given, the standard *note
     XMLParser: 559. parser is used.  `parser' must be a subclass of
     *note XMLParser: 559. and can only use the default *note
     TreeBuilder: 22b5. as a target.  Returns an *note iterator: e4f.
     providing ‘(event, elem)’ pairs.

     Note that while *note iterparse(): 558. builds the tree
     incrementally, it issues blocking reads on `source' (or the file it
     names).  As such, it’s unsuitable for applications where blocking
     reads can’t be made.  For fully non-blocking parsing, see *note
     XMLPullParser: 517.

          Note: *note iterparse(): 558. only guarantees that it has seen
          the ">" character of a starting tag when it emits a "start"
          event, so the attributes are defined, but the contents of the
          text and tail attributes are undefined at that point.  The
          same applies to the element children; they may or may not be
          present.

          If you need a fully populated element, look for "end" events
          instead.

     Deprecated since version 3.4: The `parser' argument.

 -- Function: xml.etree.ElementTree.parse (source, parser=None)

     Parses an XML section into an element tree.  `source' is a filename
     or file object containing XML data.  `parser' is an optional parser
     instance.  If not given, the standard *note XMLParser: 559. parser
     is used.  Returns an *note ElementTree: 51b. instance.

 -- Function: xml.etree.ElementTree.ProcessingInstruction (target,
          text=None)

     PI element factory.  This factory function creates a special
     element that will be serialized as an XML processing instruction.
     `target' is a string containing the PI target.  `text' is a string
     containing the PI contents, if given.  Returns an element instance,
     representing a processing instruction.

     Note that *note XMLParser: 559. skips over processing instructions
     in the input instead of creating comment objects for them.  An
     *note ElementTree: 51b. will only contain processing instruction
     nodes if they have been inserted into to the tree using one of the
     *note Element: 700. methods.

 -- Function: xml.etree.ElementTree.register_namespace (prefix, uri)

     Registers a namespace prefix.  The registry is global, and any
     existing mapping for either the given prefix or the namespace URI
     will be removed.  `prefix' is a namespace prefix.  `uri' is a
     namespace uri.  Tags and attributes in this namespace will be
     serialized with the given prefix, if at all possible.

     New in version 3.2.

 -- Function: xml.etree.ElementTree.SubElement (parent, tag, attrib={},
          **extra)

     Subelement factory.  This function creates an element instance, and
     appends it to an existing element.

     The element name, attribute names, and attribute values can be
     either bytestrings or Unicode strings.  `parent' is the parent
     element.  `tag' is the subelement name.  `attrib' is an optional
     dictionary, containing element attributes.  `extra' contains
     additional attributes, given as keyword arguments.  Returns an
     element instance.

 -- Function: xml.etree.ElementTree.tostring (element,
          encoding="us-ascii", method="xml", *,
          short_empty_elements=True)

     Generates a string representation of an XML element, including all
     subelements.  `element' is an *note Element: 700. instance.
     `encoding' (1) is the output encoding (default is US-ASCII). Use
     ‘encoding="unicode"’ to generate a Unicode string (otherwise, a
     bytestring is generated).  `method' is either ‘"xml"’, ‘"html"’ or
     ‘"text"’ (default is ‘"xml"’).  `short_empty_elements' has the same
     meaning as in *note ElementTree.write(): 51c.  Returns an
     (optionally) encoded string containing the XML data.

     New in version 3.4: The `short_empty_elements' parameter.

 -- Function: xml.etree.ElementTree.tostringlist (element,
          encoding="us-ascii", method="xml", *,
          short_empty_elements=True)

     Generates a string representation of an XML element, including all
     subelements.  `element' is an *note Element: 700. instance.
     `encoding' (2) is the output encoding (default is US-ASCII). Use
     ‘encoding="unicode"’ to generate a Unicode string (otherwise, a
     bytestring is generated).  `method' is either ‘"xml"’, ‘"html"’ or
     ‘"text"’ (default is ‘"xml"’).  `short_empty_elements' has the same
     meaning as in *note ElementTree.write(): 51c.  Returns a list of
     (optionally) encoded strings containing the XML data.  It does not
     guarantee any specific sequence, except that
     ‘b"".join(tostringlist(element)) == tostring(element)’.

     New in version 3.2.

     New in version 3.4: The `short_empty_elements' parameter.

 -- Function: xml.etree.ElementTree.XML (text, parser=None)

     Parses an XML section from a string constant.  This function can be
     used to embed "XML literals" in Python code.  `text' is a string
     containing XML data.  `parser' is an optional parser instance.  If
     not given, the standard *note XMLParser: 559. parser is used.
     Returns an *note Element: 700. instance.

 -- Function: xml.etree.ElementTree.XMLID (text, parser=None)

     Parses an XML section from a string constant, and also returns a
     dictionary which maps from element id:s to elements.  `text' is a
     string containing XML data.  `parser' is an optional parser
     instance.  If not given, the standard *note XMLParser: 559. parser
     is used.  Returns a tuple containing an *note Element: 700.
     instance and a dictionary.

   ---------- Footnotes ----------

   (1) The encoding string included in XML output should conform to the
appropriate standards.  For example, "UTF-8" is valid, but "UTF8" is
not.  See
‘http://www.w3.org/TR/2006/REC-xml11-20060816/#NT-EncodingDecl’ and
‘http://www.iana.org/assignments/character-sets/character-sets.xhtml’.

   (2) The encoding string included in XML output should conform to the
appropriate standards.  For example, "UTF-8" is valid, but "UTF8" is
not.  See
‘http://www.w3.org/TR/2006/REC-xml11-20060816/#NT-EncodingDecl’ and
‘http://www.iana.org/assignments/character-sets/character-sets.xhtml’.


File: python.info,  Node: Element Objects,  Next: ElementTree Objects,  Prev: Functions<5>,  Up: Reference<2>

5.20.5.15 Element Objects
.........................

 -- Class: xml.etree.ElementTree.Element (tag, attrib={}, **extra)

     Element class.  This class defines the Element interface, and
     provides a reference implementation of this interface.

     The element name, attribute names, and attribute values can be
     either bytestrings or Unicode strings.  `tag' is the element name.
     `attrib' is an optional dictionary, containing element attributes.
     `extra' contains additional attributes, given as keyword arguments.

      -- Attribute: tag

          A string identifying what kind of data this element represents
          (the element type, in other words).

      -- Attribute: text
      -- Attribute: tail

          These attributes can be used to hold additional data
          associated with the element.  Their values are usually strings
          but may be any application-specific object.  If the element is
          created from an XML file, the `text' attribute holds either
          the text between the element’s start tag and its first child
          or end tag, or ‘None’, and the `tail' attribute holds either
          the text between the element’s end tag and the next tag, or
          ‘None’.  For the XML data

               <a><b>1<c>2<d/>3</c></b>4</a>

          the `a' element has ‘None’ for both `text' and `tail'
          attributes, the `b' element has `text' ‘"1"’ and `tail' ‘"4"’,
          the `c' element has `text' ‘"2"’ and `tail' ‘None’, and the
          `d' element has `text' ‘None’ and `tail' ‘"3"’.

          To collect the inner text of an element, see *note itertext():
          79c, for example ‘"".join(element.itertext())’.

          Applications may store arbitrary objects in these attributes.

      -- Attribute: attrib

          A dictionary containing the element’s attributes.  Note that
          while the `attrib' value is always a real mutable Python
          dictionary, an ElementTree implementation may choose to use
          another internal representation, and create the dictionary
          only if someone asks for it.  To take advantage of such
          implementations, use the dictionary methods below whenever
          possible.

     The following dictionary-like methods work on the element
     attributes.

      -- Method: clear ()

          Resets an element.  This function removes all subelements,
          clears all attributes, and sets the text and tail attributes
          to ‘None’.

      -- Method: get (key, default=None)

          Gets the element attribute named `key'.

          Returns the attribute value, or `default' if the attribute was
          not found.

      -- Method: items ()

          Returns the element attributes as a sequence of (name, value)
          pairs.  The attributes are returned in an arbitrary order.

      -- Method: keys ()

          Returns the elements attribute names as a list.  The names are
          returned in an arbitrary order.

      -- Method: set (key, value)

          Set the attribute `key' on the element to `value'.

     The following methods work on the element’s children (subelements).

      -- Method: append (subelement)

          Adds the element `subelement' to the end of this element’s
          internal list of subelements.  Raises *note TypeError: 562. if
          `subelement' is not an *note Element: 700.

      -- Method: extend (subelements)

          Appends `subelements' from a sequence object with zero or more
          elements.  Raises *note TypeError: 562. if a subelement is not
          an *note Element: 700.

          New in version 3.2.

      -- Method: find (match, namespaces=None)

          Finds the first subelement matching `match'.  `match' may be a
          tag name or a *note path: 22be.  Returns an element instance
          or ‘None’.  `namespaces' is an optional mapping from namespace
          prefix to full name.

      -- Method: findall (match, namespaces=None)

          Finds all matching subelements, by tag name or *note path:
          22be.  Returns a list containing all matching elements in
          document order.  `namespaces' is an optional mapping from
          namespace prefix to full name.

      -- Method: findtext (match, default=None, namespaces=None)

          Finds text for the first subelement matching `match'.  `match'
          may be a tag name or a *note path: 22be.  Returns the text
          content of the first matching element, or `default' if no
          element was found.  Note that if the matching element has no
          text content an empty string is returned.  `namespaces' is an
          optional mapping from namespace prefix to full name.

      -- Method: getchildren ()

          Deprecated since version 3.2: Use ‘list(elem)’ or iteration.

      -- Method: getiterator (tag=None)

          Deprecated since version 3.2: Use method *note Element.iter():
          95f. instead.

      -- Method: insert (index, subelement)

          Inserts `subelement' at the given position in this element.
          Raises *note TypeError: 562. if `subelement' is not an *note
          Element: 700.

      -- Method: iter (tag=None)

          Creates a tree *note iterator: e4f. with the current element
          as the root.  The iterator iterates over this element and all
          elements below it, in document (depth first) order.  If `tag'
          is not ‘None’ or ‘'*'’, only elements whose tag equals `tag'
          are returned from the iterator.  If the tree structure is
          modified during iteration, the result is undefined.

          New in version 3.2.

      -- Method: iterfind (match, namespaces=None)

          Finds all matching subelements, by tag name or *note path:
          22be.  Returns an iterable yielding all matching elements in
          document order.  `namespaces' is an optional mapping from
          namespace prefix to full name.

          New in version 3.2.

      -- Method: itertext ()

          Creates a text iterator.  The iterator loops over this element
          and all subelements, in document order, and returns all inner
          text.

          New in version 3.2.

      -- Method: makeelement (tag, attrib)

          Creates a new element object of the same type as this element.
          Do not call this method, use the *note SubElement(): 22c4.
          factory function instead.

      -- Method: remove (subelement)

          Removes `subelement' from the element.  Unlike the find*
          methods this method compares elements based on the instance
          identity, not on tag value or contents.

     *note Element: 700. objects also support the following sequence
     type methods for working with subelements: *note __delitem__():
     8ce, *note __getitem__(): a84, *note __setitem__(): 8cd, *note
     __len__(): a47.

     Caution: Elements with no subelements will test as ‘False’.  This
     behavior will change in future versions.  Use specific ‘len(elem)’
     or ‘elem is None’ test instead.

          element = root.find('foo')

          if not element:  # careful!
              print("element not found, or element has no subelements")

          if element is None:
              print("element not found")


File: python.info,  Node: ElementTree Objects,  Next: QName Objects,  Prev: Element Objects,  Up: Reference<2>

5.20.5.16 ElementTree Objects
.............................

 -- Class: xml.etree.ElementTree.ElementTree (element=None, file=None)

     ElementTree wrapper class.  This class represents an entire element
     hierarchy, and adds some extra support for serialization to and
     from standard XML.

     `element' is the root element.  The tree is initialized with the
     contents of the XML `file' if given.

      -- Method: _setroot (element)

          Replaces the root element for this tree.  This discards the
          current contents of the tree, and replaces it with the given
          element.  Use with care.  `element' is an element instance.

      -- Method: find (match, namespaces=None)

          Same as *note Element.find(): 22bb, starting at the root of
          the tree.

      -- Method: findall (match, namespaces=None)

          Same as *note Element.findall(): 22ba, starting at the root of
          the tree.

      -- Method: findtext (match, default=None, namespaces=None)

          Same as *note Element.findtext(): 22dc, starting at the root
          of the tree.

      -- Method: getiterator (tag=None)

          Deprecated since version 3.2: Use method *note
          ElementTree.iter(): 22e8. instead.

      -- Method: getroot ()

          Returns the root element for this tree.

      -- Method: iter (tag=None)

          Creates and returns a tree iterator for the root element.  The
          iterator loops over all elements in this tree, in section
          order.  `tag' is the tag to look for (default is to return all
          elements).

      -- Method: iterfind (match, namespaces=None)

          Same as *note Element.iterfind(): 79b, starting at the root of
          the tree.

          New in version 3.2.

      -- Method: parse (source, parser=None)

          Loads an external XML section into this element tree.
          `source' is a file name or *note file object: 78b.  `parser'
          is an optional parser instance.  If not given, the standard
          *note XMLParser: 559. parser is used.  Returns the section
          root element.

      -- Method: write (file, encoding="us-ascii", xml_declaration=None,
               default_namespace=None, method="xml", *,
               short_empty_elements=True)

          Writes the element tree to a file, as XML. `file' is a file
          name, or a *note file object: 78b. opened for writing.
          `encoding' (1) is the output encoding (default is US-ASCII).
          `xml_declaration' controls if an XML declaration should be
          added to the file.  Use ‘False’ for never, ‘True’ for always,
          ‘None’ for only if not US-ASCII or UTF-8 or Unicode (default
          is ‘None’).  `default_namespace' sets the default XML
          namespace (for "xmlns").  `method' is either ‘"xml"’, ‘"html"’
          or ‘"text"’ (default is ‘"xml"’).  The keyword-only
          `short_empty_elements' parameter controls the formatting of
          elements that contain no content.  If `True' (the default),
          they are emitted as a single self-closed tag, otherwise they
          are emitted as a pair of start/end tags.

          The output is either a string (*note str: 25a.) or binary
          (*note bytes: 1db.).  This is controlled by the `encoding'
          argument.  If `encoding' is ‘"unicode"’, the output is a
          string; otherwise, it’s binary.  Note that this may conflict
          with the type of `file' if it’s an open *note file object:
          78b.; make sure you do not try to write a string to a binary
          stream and vice versa.

          New in version 3.4: The `short_empty_elements' parameter.

This is the XML file that is going to be manipulated:

     <html>
         <head>
             <title>Example page</title>
         </head>
         <body>
             <p>Moved to <a href="http://example.org/">example.org</a>
             or <a href="http://example.com/">example.com</a>.</p>
         </body>
     </html>

Example of changing the attribute "target" of every link in first
paragraph:

     >>> from xml.etree.ElementTree import ElementTree
     >>> tree = ElementTree()
     >>> tree.parse("index.xhtml")
     <Element 'html' at 0xb77e6fac>
     >>> p = tree.find("body/p")     # Finds first occurrence of tag p in body
     >>> p
     <Element 'p' at 0xb77ec26c>
     >>> links = list(p.iter("a"))   # Returns list of all links
     >>> links
     [<Element 'a' at 0xb77ec2ac>, <Element 'a' at 0xb77ec1cc>]
     >>> for i in links:             # Iterates through all found links
     ...     i.attrib["target"] = "blank"
     >>> tree.write("output.xhtml")

   ---------- Footnotes ----------

   (1) The encoding string included in XML output should conform to the
appropriate standards.  For example, "UTF-8" is valid, but "UTF8" is
not.  See
‘http://www.w3.org/TR/2006/REC-xml11-20060816/#NT-EncodingDecl’ and
‘http://www.iana.org/assignments/character-sets/character-sets.xhtml’.


File: python.info,  Node: QName Objects,  Next: TreeBuilder Objects,  Prev: ElementTree Objects,  Up: Reference<2>

5.20.5.17 QName Objects
.......................

 -- Class: xml.etree.ElementTree.QName (text_or_uri, tag=None)

     QName wrapper.  This can be used to wrap a QName attribute value,
     in order to get proper namespace handling on output.  `text_or_uri'
     is a string containing the QName value, in the form {uri}local, or,
     if the tag argument is given, the URI part of a QName.  If `tag' is
     given, the first argument is interpreted as a URI, and this
     argument is interpreted as a local name.  *note QName: 22ee.
     instances are opaque.


File: python.info,  Node: TreeBuilder Objects,  Next: XMLParser Objects,  Prev: QName Objects,  Up: Reference<2>

5.20.5.18 TreeBuilder Objects
.............................

 -- Class: xml.etree.ElementTree.TreeBuilder (element_factory=None)

     Generic element structure builder.  This builder converts a
     sequence of start, data, and end method calls to a well-formed
     element structure.  You can use this class to build an element
     structure using a custom XML parser, or a parser for some other
     XML-like format.  `element_factory', when given, must be a callable
     accepting two positional arguments: a tag and a dict of attributes.
     It is expected to return a new element instance.

      -- Method: close ()

          Flushes the builder buffers, and returns the toplevel document
          element.  Returns an *note Element: 700. instance.

      -- Method: data (data)

          Adds text to the current element.  `data' is a string.  This
          should be either a bytestring, or a Unicode string.

      -- Method: end (tag)

          Closes the current element.  `tag' is the element name.
          Returns the closed element.

      -- Method: start (tag, attrs)

          Opens a new element.  `tag' is the element name.  `attrs' is a
          dictionary containing element attributes.  Returns the opened
          element.

     In addition, a custom *note TreeBuilder: 22b5. object can provide
     the following method:

      -- Method: doctype (name, pubid, system)

          Handles a doctype declaration.  `name' is the doctype name.
          `pubid' is the public identifier.  `system' is the system
          identifier.  This method does not exist on the default *note
          TreeBuilder: 22b5. class.

          New in version 3.2.


File: python.info,  Node: XMLParser Objects,  Next: XMLPullParser Objects,  Prev: TreeBuilder Objects,  Up: Reference<2>

5.20.5.19 XMLParser Objects
...........................

 -- Class: xml.etree.ElementTree.XMLParser (html=0, target=None,
          encoding=None)

     This class is the low-level building block of the module.  It uses
     *note xml.parsers.expat: 135. for efficient, event-based parsing of
     XML. It can be fed XML data incrementally with the *note feed():
     22f6. method, and parsing events are translated to a push API - by
     invoking callbacks on the `target' object.  If `target' is omitted,
     the standard *note TreeBuilder: 22b5. is used.  The `html' argument
     was historically used for backwards compatibility and is now
     deprecated.  If `encoding' (1) is given, the value overrides the
     encoding specified in the XML file.

     Deprecated since version 3.4: The `html' argument.  The remaining
     arguments should be passed via keyword to prepare for the removal
     of the `html' argument.

      -- Method: close ()

          Finishes feeding data to the parser.  Returns the result of
          calling the ‘close()’ method of the `target' passed during
          construction; by default, this is the toplevel document
          element.

      -- Method: doctype (name, pubid, system)

          Deprecated since version 3.2: Define the *note
          TreeBuilder.doctype(): 79e. method on a custom TreeBuilder
          target.

      -- Method: feed (data)

          Feeds data to the parser.  `data' is encoded data.

     *note XMLParser.feed(): 22f6. calls `target'’s ‘start(tag,
     attrs_dict)’ method for each opening tag, its ‘end(tag)’ method for
     each closing tag, and data is processed by method ‘data(data)’.
     *note XMLParser.close(): 22f7. calls `target'’s method ‘close()’.
     *note XMLParser: 559. can be used not only for building a tree
     structure.  This is an example of counting the maximum depth of an
     XML file:

          >>> from xml.etree.ElementTree import XMLParser
          >>> class MaxDepth:                     # The target object of the parser
          ...     maxDepth = 0
          ...     depth = 0
          ...     def start(self, tag, attrib):   # Called for each opening tag.
          ...         self.depth += 1
          ...         if self.depth > self.maxDepth:
          ...             self.maxDepth = self.depth
          ...     def end(self, tag):             # Called for each closing tag.
          ...         self.depth -= 1
          ...     def data(self, data):
          ...         pass            # We do not need to do anything with data.
          ...     def close(self):    # Called when all data has been parsed.
          ...         return self.maxDepth
          ...
          >>> target = MaxDepth()
          >>> parser = XMLParser(target=target)
          >>> exampleXml = """
          ... <a>
          ...   <b>
          ...   </b>
          ...   <b>
          ...     <c>
          ...       <d>
          ...       </d>
          ...     </c>
          ...   </b>
          ... </a>"""
          >>> parser.feed(exampleXml)
          >>> parser.close()
          4

   ---------- Footnotes ----------

   (1) The encoding string included in XML output should conform to the
appropriate standards.  For example, "UTF-8" is valid, but "UTF8" is
not.  See
‘http://www.w3.org/TR/2006/REC-xml11-20060816/#NT-EncodingDecl’ and
‘http://www.iana.org/assignments/character-sets/character-sets.xhtml’.


File: python.info,  Node: XMLPullParser Objects,  Next: Exceptions<11>,  Prev: XMLParser Objects,  Up: Reference<2>

5.20.5.20 XMLPullParser Objects
...............................

 -- Class: xml.etree.ElementTree.XMLPullParser (events=None)

     A pull parser suitable for non-blocking applications.  Its
     input-side API is similar to that of *note XMLParser: 559, but
     instead of pushing calls to a callback target, *note XMLPullParser:
     517. collects an internal list of parsing events and lets the user
     read from it.  `events' is a sequence of events to report back.
     The supported events are the strings ‘"start"’, ‘"end"’,
     ‘"start-ns"’ and ‘"end-ns"’ (the "ns" events are used to get
     detailed namespace information).  If `events' is omitted, only
     ‘"end"’ events are reported.

      -- Method: feed (data)

          Feed the given bytes data to the parser.

      -- Method: close ()

          Signal the parser that the data stream is terminated.  Unlike
          *note XMLParser.close(): 22f7, this method always returns
          *note None: 19d.  Any events not yet retrieved when the parser
          is closed can still be read with *note read_events(): 22b8.

      -- Method: read_events ()

          Return an iterator over the events which have been encountered
          in the data fed to the parser.  The iterator yields ‘(event,
          elem)’ pairs, where `event' is a string representing the type
          of event (e.g.  ‘"end"’) and `elem' is the encountered *note
          Element: 700. object.

          Events provided in a previous call to *note read_events():
          22b8. will not be yielded again.  Events are consumed from the
          internal queue only when they are retrieved from the iterator,
          so multiple readers iterating in parallel over iterators
          obtained from *note read_events(): 22b8. will have
          unpredictable results.

          Note: *note XMLPullParser: 517. only guarantees that it has
          seen the ">" character of a starting tag when it emits a
          "start" event, so the attributes are defined, but the contents
          of the text and tail attributes are undefined at that point.
          The same applies to the element children; they may or may not
          be present.

          If you need a fully populated element, look for "end" events
          instead.

     New in version 3.4.


File: python.info,  Node: Exceptions<11>,  Prev: XMLPullParser Objects,  Up: Reference<2>

5.20.5.21 Exceptions
....................

 -- Class: xml.etree.ElementTree.ParseError

     XML parse error, raised by the various parsing methods in this
     module when parsing fails.  The string representation of an
     instance of this exception will contain a user-friendly error
     message.  In addition, it will have the following attributes
     available:

      -- Attribute: code

          A numeric error code from the expat parser.  See the
          documentation of *note xml.parsers.expat: 135. for the list of
          error codes and their meanings.

      -- Attribute: position

          A tuple of `line', `column' numbers, specifying where the
          error occurred.


File: python.info,  Node: xml dom --- The Document Object Model API,  Next: xml dom minidom --- Minimal DOM implementation,  Prev: xml etree ElementTree --- The ElementTree XML API,  Up: Structured Markup Processing Tools

5.20.6 ‘xml.dom’ — The Document Object Model API
------------------------------------------------

The Document Object Model, or "DOM," is a cross-language API from the
World Wide Web Consortium (W3C) for accessing and modifying XML
documents.  A DOM implementation presents an XML document as a tree
structure, or allows client code to build such a structure from scratch.
It then gives access to the structure through a set of objects which
provided well-known interfaces.

The DOM is extremely useful for random-access applications.  SAX only
allows you a view of one bit of the document at a time.  If you are
looking at one SAX element, you have no access to another.  If you are
looking at a text node, you have no access to a containing element.
When you write a SAX application, you need to keep track of your
program’s position in the document somewhere in your own code.  SAX does
not do it for you.  Also, if you need to look ahead in the XML document,
you are just out of luck.

Some applications are simply impossible in an event driven model with no
access to a tree.  Of course you could build some sort of tree yourself
in SAX events, but the DOM allows you to avoid writing that code.  The
DOM is a standard tree representation for XML data.

The Document Object Model is being defined by the W3C in stages, or
"levels" in their terminology.  The Python mapping of the API is
substantially based on the DOM Level 2 recommendation.

DOM applications typically start by parsing some XML into a DOM. How
this is accomplished is not covered at all by DOM Level 1, and Level 2
provides only limited improvements: There is a ‘DOMImplementation’
object class which provides access to ‘Document’ creation methods, but
no way to access an XML reader/parser/Document builder in an
implementation-independent way.  There is also no well-defined way to
access these methods without an existing ‘Document’ object.  In Python,
each DOM implementation will provide a function *note
getDOMImplementation(): 2301.  DOM Level 3 adds a Load/Store
specification, which defines an interface to the reader, but this is not
yet available in the Python standard library.

Once you have a DOM document object, you can access the parts of your
XML document through its properties and methods.  These properties are
defined in the DOM specification; this portion of the reference manual
describes the interpretation of the specification in Python.

The specification provided by the W3C defines the DOM API for Java,
ECMAScript, and OMG IDL. The Python mapping defined here is based in
large part on the IDL version of the specification, but strict
compliance is not required (though implementations are free to support
the strict mapping from IDL). See section *note Conformance: 2302. for a
detailed discussion of mapping requirements.

See also
........

Document Object Model (DOM) Level 2 Specification(1)

     The W3C recommendation upon which the Python DOM API is based.

Document Object Model (DOM) Level 1 Specification(2)

     The W3C recommendation for the DOM supported by *note
     xml.dom.minidom: 132.

Python Language Mapping Specification(3)

     This specifies the mapping from OMG IDL to Python.

* Menu:

* Module Contents: Module Contents<4>. 
* Objects in the DOM:: 
* Conformance:: 

   ---------- Footnotes ----------

   (1) http://www.w3.org/TR/DOM-Level-2-Core/

   (2) http://www.w3.org/TR/REC-DOM-Level-1/

   (3) http://www.omg.org/spec/PYTH/1.2/PDF


File: python.info,  Node: Module Contents<4>,  Next: Objects in the DOM,  Up: xml dom --- The Document Object Model API

5.20.6.1 Module Contents
........................

The *note xml.dom: 131. contains the following functions:

 -- Function: xml.dom.registerDOMImplementation (name, factory)

     Register the `factory' function with the name `name'.  The factory
     function should return an object which implements the
     ‘DOMImplementation’ interface.  The factory function can return the
     same object every time, or a new one for each call, as appropriate
     for the specific implementation (e.g.  if that implementation
     supports some customization).

 -- Function: xml.dom.getDOMImplementation (name=None, features=())

     Return a suitable DOM implementation.  The `name' is either
     well-known, the module name of a DOM implementation, or ‘None’.  If
     it is not ‘None’, imports the corresponding module and returns a
     ‘DOMImplementation’ object if the import succeeds.  If no name is
     given, and if the environment variable ‘PYTHON_DOM’ is set, this
     variable is used to find the implementation.

     If name is not given, this examines the available implementations
     to find one with the required feature set.  If no implementation
     can be found, raise an *note ImportError: 19f.  The features list
     must be a sequence of ‘(feature, version)’ pairs which are passed
     to the ‘hasFeature()’ method on available ‘DOMImplementation’
     objects.

Some convenience constants are also provided:

 -- Data: xml.dom.EMPTY_NAMESPACE

     The value used to indicate that no namespace is associated with a
     node in the DOM. This is typically found as the ‘namespaceURI’ of a
     node, or used as the `namespaceURI' parameter to a
     namespaces-specific method.

 -- Data: xml.dom.XML_NAMESPACE

     The namespace URI associated with the reserved prefix ‘xml’, as
     defined by Namespaces in XML(1) (section 4).

 -- Data: xml.dom.XMLNS_NAMESPACE

     The namespace URI for namespace declarations, as defined by
     Document Object Model (DOM) Level 2 Core Specification(2) (section
     1.1.8).

 -- Data: xml.dom.XHTML_NAMESPACE

     The URI of the XHTML namespace as defined by XHTML 1.0: The
     Extensible HyperText Markup Language(3) (section 3.1.1).

In addition, *note xml.dom: 131. contains a base ‘Node’ class and the
DOM exception classes.  The ‘Node’ class provided by this module does
not implement any of the methods or attributes defined by the DOM
specification; concrete DOM implementations must provide those.  The
‘Node’ class provided as part of this module does provide the constants
used for the ‘nodeType’ attribute on concrete ‘Node’ objects; they are
located within the class rather than at the module level to conform with
the DOM specifications.

   ---------- Footnotes ----------

   (1) http://www.w3.org/TR/REC-xml-names/

   (2) http://www.w3.org/TR/DOM-Level-2-Core/core.html

   (3) http://www.w3.org/TR/xhtml1/


File: python.info,  Node: Objects in the DOM,  Next: Conformance,  Prev: Module Contents<4>,  Up: xml dom --- The Document Object Model API

5.20.6.2 Objects in the DOM
...........................

The definitive documentation for the DOM is the DOM specification from
the W3C.

Note that DOM attributes may also be manipulated as nodes instead of as
simple strings.  It is fairly rare that you must do this, however, so
this usage is not yet documented.

Interface                            Section                                 Purpose
                                                                             
-------------------------------------------------------------------------------------------------------------------
                                                                             
‘DOMImplementation’                  *note DOMImplementation Objects: 230b.  Interface to the underlying
                                                                             implementation.
                                                                             
                                                                             
‘Node’                               *note Node Objects: 230c.               Base interface for most objects in
                                                                             a document.
                                                                             
                                                                             
‘NodeList’                           *note NodeList Objects: 230d.           Interface for a sequence of nodes.
                                                                             
                                                                             
‘DocumentType’                       *note DocumentType Objects: 230e.       Information about the declarations
                                                                             needed to process a document.
                                                                             
                                                                             
‘Document’                           *note Document Objects: 230f.           Object which represents an entire
                                                                             document.
                                                                             
                                                                             
‘Element’                            *note Element Objects: 2310.            Element nodes in the document
                                                                             hierarchy.
                                                                             
                                                                             
‘Attr’                               *note Attr Objects: 2311.               Attribute value nodes on element
                                                                             nodes.
                                                                             
                                                                             
‘Comment’                            *note Comment Objects: 2312.            Representation of comments in the
                                                                             source document.
                                                                             
                                                                             
‘Text’                               *note Text and CDATASection Objects: 2313.Nodes containing textual content
                                                                             from the document.
                                                                             
                                                                             
‘ProcessingInstruction’              *note ProcessingInstruction Objects: 2314.Processing instruction
                                                                             representation.
                                                                             

An additional section describes the exceptions defined for working with
the DOM in Python.

* Menu:

* DOMImplementation Objects:: 
* Node Objects:: 
* NodeList Objects:: 
* DocumentType Objects:: 
* Document Objects:: 
* Element Objects: Element Objects<2>. 
* Attr Objects:: 
* NamedNodeMap Objects:: 
* Comment Objects:: 
* Text and CDATASection Objects:: 
* ProcessingInstruction Objects:: 
* Exceptions: Exceptions<12>. 


File: python.info,  Node: DOMImplementation Objects,  Next: Node Objects,  Up: Objects in the DOM

5.20.6.3 DOMImplementation Objects
..................................

The ‘DOMImplementation’ interface provides a way for applications to
determine the availability of particular features in the DOM they are
using.  DOM Level 2 added the ability to create new ‘Document’ and
‘DocumentType’ objects using the ‘DOMImplementation’ as well.

 -- Method: DOMImplementation.hasFeature (feature, version)

     Return true if the feature identified by the pair of strings
     `feature' and `version' is implemented.

 -- Method: DOMImplementation.createDocument (namespaceUri,
          qualifiedName, doctype)

     Return a new ‘Document’ object (the root of the DOM), with a child
     ‘Element’ object having the given `namespaceUri' and
     `qualifiedName'.  The `doctype' must be a ‘DocumentType’ object
     created by *note createDocumentType(): 2318, or ‘None’.  In the
     Python DOM API, the first two arguments can also be ‘None’ in order
     to indicate that no ‘Element’ child is to be created.

 -- Method: DOMImplementation.createDocumentType (qualifiedName,
          publicId, systemId)

     Return a new ‘DocumentType’ object that encapsulates the given
     `qualifiedName', `publicId', and `systemId' strings, representing
     the information contained in an XML document type declaration.


File: python.info,  Node: Node Objects,  Next: NodeList Objects,  Prev: DOMImplementation Objects,  Up: Objects in the DOM

5.20.6.4 Node Objects
.....................

All of the components of an XML document are subclasses of ‘Node’.

 -- Attribute: Node.nodeType

     An integer representing the node type.  Symbolic constants for the
     types are on the ‘Node’ object: ‘ELEMENT_NODE’, ‘ATTRIBUTE_NODE’,
     ‘TEXT_NODE’, ‘CDATA_SECTION_NODE’, ‘ENTITY_NODE’,
     ‘PROCESSING_INSTRUCTION_NODE’, ‘COMMENT_NODE’, ‘DOCUMENT_NODE’,
     ‘DOCUMENT_TYPE_NODE’, ‘NOTATION_NODE’.  This is a read-only
     attribute.

 -- Attribute: Node.parentNode

     The parent of the current node, or ‘None’ for the document node.
     The value is always a ‘Node’ object or ‘None’.  For ‘Element’
     nodes, this will be the parent element, except for the root
     element, in which case it will be the ‘Document’ object.  For
     ‘Attr’ nodes, this is always ‘None’.  This is a read-only
     attribute.

 -- Attribute: Node.attributes

     A ‘NamedNodeMap’ of attribute objects.  Only elements have actual
     values for this; others provide ‘None’ for this attribute.  This is
     a read-only attribute.

 -- Attribute: Node.previousSibling

     The node that immediately precedes this one with the same parent.
     For instance the element with an end-tag that comes just before the
     `self' element’s start-tag.  Of course, XML documents are made up
     of more than just elements so the previous sibling could be text, a
     comment, or something else.  If this node is the first child of the
     parent, this attribute will be ‘None’.  This is a read-only
     attribute.

 -- Attribute: Node.nextSibling

     The node that immediately follows this one with the same parent.
     See also *note previousSibling: 231d.  If this is the last child of
     the parent, this attribute will be ‘None’.  This is a read-only
     attribute.

 -- Attribute: Node.childNodes

     A list of nodes contained within this node.  This is a read-only
     attribute.

 -- Attribute: Node.firstChild

     The first child of the node, if there are any, or ‘None’.  This is
     a read-only attribute.

 -- Attribute: Node.lastChild

     The last child of the node, if there are any, or ‘None’.  This is a
     read-only attribute.

 -- Attribute: Node.localName

     The part of the ‘tagName’ following the colon if there is one, else
     the entire ‘tagName’.  The value is a string.

 -- Attribute: Node.prefix

     The part of the ‘tagName’ preceding the colon if there is one, else
     the empty string.  The value is a string, or ‘None’.

 -- Attribute: Node.namespaceURI

     The namespace associated with the element name.  This will be a
     string or ‘None’.  This is a read-only attribute.

 -- Attribute: Node.nodeName

     This has a different meaning for each node type; see the DOM
     specification for details.  You can always get the information you
     would get here from another property such as the ‘tagName’ property
     for elements or the ‘name’ property for attributes.  For all node
     types, the value of this attribute will be either a string or
     ‘None’.  This is a read-only attribute.

 -- Attribute: Node.nodeValue

     This has a different meaning for each node type; see the DOM
     specification for details.  The situation is similar to that with
     *note nodeName: 2325.  The value is a string or ‘None’.

 -- Method: Node.hasAttributes ()

     Returns true if the node has any attributes.

 -- Method: Node.hasChildNodes ()

     Returns true if the node has any child nodes.

 -- Method: Node.isSameNode (other)

     Returns true if `other' refers to the same node as this node.  This
     is especially useful for DOM implementations which use any sort of
     proxy architecture (because more than one object can refer to the
     same node).

          Note: This is based on a proposed DOM Level 3 API which is
          still in the "working draft" stage, but this particular
          interface appears uncontroversial.  Changes from the W3C will
          not necessarily affect this method in the Python DOM interface
          (though any new W3C API for this would also be supported).

 -- Method: Node.appendChild (newChild)

     Add a new child node to this node at the end of the list of
     children, returning `newChild'.  If the node was already in the
     tree, it is removed first.

 -- Method: Node.insertBefore (newChild, refChild)

     Insert a new child node before an existing child.  It must be the
     case that `refChild' is a child of this node; if not, *note
     ValueError: 19c. is raised.  `newChild' is returned.  If `refChild'
     is ‘None’, it inserts `newChild' at the end of the children’s list.

 -- Method: Node.removeChild (oldChild)

     Remove a child node.  `oldChild' must be a child of this node; if
     not, *note ValueError: 19c. is raised.  `oldChild' is returned on
     success.  If `oldChild' will not be used further, its ‘unlink()’
     method should be called.

 -- Method: Node.replaceChild (newChild, oldChild)

     Replace an existing node with a new node.  It must be the case that
     `oldChild' is a child of this node; if not, *note ValueError: 19c.
     is raised.

 -- Method: Node.normalize ()

     Join adjacent text nodes so that all stretches of text are stored
     as single ‘Text’ instances.  This simplifies processing text from a
     DOM tree for many applications.

 -- Method: Node.cloneNode (deep)

     Clone this node.  Setting `deep' means to clone all child nodes as
     well.  This returns the clone.


File: python.info,  Node: NodeList Objects,  Next: DocumentType Objects,  Prev: Node Objects,  Up: Objects in the DOM

5.20.6.5 NodeList Objects
.........................

A ‘NodeList’ represents a sequence of nodes.  These objects are used in
two ways in the DOM Core recommendation: the ‘Element’ objects provides
one as its list of child nodes, and the ‘getElementsByTagName()’ and
‘getElementsByTagNameNS()’ methods of ‘Node’ return objects with this
interface to represent query results.

The DOM Level 2 recommendation defines one method and one attribute for
these objects:

 -- Method: NodeList.item (i)

     Return the `i'’th item from the sequence, if there is one, or
     ‘None’.  The index `i' is not allowed to be less than zero or
     greater than or equal to the length of the sequence.

 -- Attribute: NodeList.length

     The number of nodes in the sequence.

In addition, the Python DOM interface requires that some additional
support is provided to allow ‘NodeList’ objects to be used as Python
sequences.  All ‘NodeList’ implementations must include support for
*note __len__(): a47. and *note __getitem__(): a84.; this allows
iteration over the ‘NodeList’ in *note for: 895. statements and proper
support for the *note len(): 5a8. built-in function.

If a DOM implementation supports modification of the document, the
‘NodeList’ implementation must also support the *note __setitem__():
8cd. and *note __delitem__(): 8ce. methods.


File: python.info,  Node: DocumentType Objects,  Next: Document Objects,  Prev: NodeList Objects,  Up: Objects in the DOM

5.20.6.6 DocumentType Objects
.............................

Information about the notations and entities declared by a document
(including the external subset if the parser uses it and can provide the
information) is available from a ‘DocumentType’ object.  The
‘DocumentType’ for a document is available from the ‘Document’ object’s
‘doctype’ attribute; if there is no ‘DOCTYPE’ declaration for the
document, the document’s ‘doctype’ attribute will be set to ‘None’
instead of an instance of this interface.

‘DocumentType’ is a specialization of ‘Node’, and adds the following
attributes:

 -- Attribute: DocumentType.publicId

     The public identifier for the external subset of the document type
     definition.  This will be a string or ‘None’.

 -- Attribute: DocumentType.systemId

     The system identifier for the external subset of the document type
     definition.  This will be a URI as a string, or ‘None’.

 -- Attribute: DocumentType.internalSubset

     A string giving the complete internal subset from the document.
     This does not include the brackets which enclose the subset.  If
     the document has no internal subset, this should be ‘None’.

 -- Attribute: DocumentType.name

     The name of the root element as given in the ‘DOCTYPE’ declaration,
     if present.

 -- Attribute: DocumentType.entities

     This is a ‘NamedNodeMap’ giving the definitions of external
     entities.  For entity names defined more than once, only the first
     definition is provided (others are ignored as required by the XML
     recommendation).  This may be ‘None’ if the information is not
     provided by the parser, or if no entities are defined.

 -- Attribute: DocumentType.notations

     This is a ‘NamedNodeMap’ giving the definitions of notations.  For
     notation names defined more than once, only the first definition is
     provided (others are ignored as required by the XML
     recommendation).  This may be ‘None’ if the information is not
     provided by the parser, or if no notations are defined.


File: python.info,  Node: Document Objects,  Next: Element Objects<2>,  Prev: DocumentType Objects,  Up: Objects in the DOM

5.20.6.7 Document Objects
.........................

A ‘Document’ represents an entire XML document, including its
constituent elements, attributes, processing instructions, comments etc.
Remember that it inherits properties from ‘Node’.

 -- Attribute: Document.documentElement

     The one and only root element of the document.

 -- Method: Document.createElement (tagName)

     Create and return a new element node.  The element is not inserted
     into the document when it is created.  You need to explicitly
     insert it with one of the other methods such as ‘insertBefore()’ or
     ‘appendChild()’.

 -- Method: Document.createElementNS (namespaceURI, tagName)

     Create and return a new element with a namespace.  The `tagName'
     may have a prefix.  The element is not inserted into the document
     when it is created.  You need to explicitly insert it with one of
     the other methods such as ‘insertBefore()’ or ‘appendChild()’.

 -- Method: Document.createTextNode (data)

     Create and return a text node containing the data passed as a
     parameter.  As with the other creation methods, this one does not
     insert the node into the tree.

 -- Method: Document.createComment (data)

     Create and return a comment node containing the data passed as a
     parameter.  As with the other creation methods, this one does not
     insert the node into the tree.

 -- Method: Document.createProcessingInstruction (target, data)

     Create and return a processing instruction node containing the
     `target' and `data' passed as parameters.  As with the other
     creation methods, this one does not insert the node into the tree.

 -- Method: Document.createAttribute (name)

     Create and return an attribute node.  This method does not
     associate the attribute node with any particular element.  You must
     use ‘setAttributeNode()’ on the appropriate ‘Element’ object to use
     the newly created attribute instance.

 -- Method: Document.createAttributeNS (namespaceURI, qualifiedName)

     Create and return an attribute node with a namespace.  The
     `tagName' may have a prefix.  This method does not associate the
     attribute node with any particular element.  You must use
     ‘setAttributeNode()’ on the appropriate ‘Element’ object to use the
     newly created attribute instance.

 -- Method: Document.getElementsByTagName (tagName)

     Search for all descendants (direct children, children’s children,
     etc.)  with a particular element type name.

 -- Method: Document.getElementsByTagNameNS (namespaceURI, localName)

     Search for all descendants (direct children, children’s children,
     etc.)  with a particular namespace URI and localname.  The
     localname is the part of the namespace after the prefix.


File: python.info,  Node: Element Objects<2>,  Next: Attr Objects,  Prev: Document Objects,  Up: Objects in the DOM

5.20.6.8 Element Objects
........................

‘Element’ is a subclass of ‘Node’, so inherits all the attributes of
that class.

 -- Attribute: Element.tagName

     The element type name.  In a namespace-using document it may have
     colons in it.  The value is a string.

 -- Method: Element.getElementsByTagName (tagName)

     Same as equivalent method in the ‘Document’ class.

 -- Method: Element.getElementsByTagNameNS (namespaceURI, localName)

     Same as equivalent method in the ‘Document’ class.

 -- Method: Element.hasAttribute (name)

     Returns true if the element has an attribute named by `name'.

 -- Method: Element.hasAttributeNS (namespaceURI, localName)

     Returns true if the element has an attribute named by
     `namespaceURI' and `localName'.

 -- Method: Element.getAttribute (name)

     Return the value of the attribute named by `name' as a string.  If
     no such attribute exists, an empty string is returned, as if the
     attribute had no value.

 -- Method: Element.getAttributeNode (attrname)

     Return the ‘Attr’ node for the attribute named by `attrname'.

 -- Method: Element.getAttributeNS (namespaceURI, localName)

     Return the value of the attribute named by `namespaceURI' and
     `localName' as a string.  If no such attribute exists, an empty
     string is returned, as if the attribute had no value.

 -- Method: Element.getAttributeNodeNS (namespaceURI, localName)

     Return an attribute value as a node, given a `namespaceURI' and
     `localName'.

 -- Method: Element.removeAttribute (name)

     Remove an attribute by name.  If there is no matching attribute, a
     *note NotFoundErr: 2350. is raised.

 -- Method: Element.removeAttributeNode (oldAttr)

     Remove and return `oldAttr' from the attribute list, if present.
     If `oldAttr' is not present, *note NotFoundErr: 2350. is raised.

 -- Method: Element.removeAttributeNS (namespaceURI, localName)

     Remove an attribute by name.  Note that it uses a localName, not a
     qname.  No exception is raised if there is no matching attribute.

 -- Method: Element.setAttribute (name, value)

     Set an attribute value from a string.

 -- Method: Element.setAttributeNode (newAttr)

     Add a new attribute node to the element, replacing an existing
     attribute if necessary if the ‘name’ attribute matches.  If a
     replacement occurs, the old attribute node will be returned.  If
     `newAttr' is already in use, *note InuseAttributeErr: 2355. will be
     raised.

 -- Method: Element.setAttributeNodeNS (newAttr)

     Add a new attribute node to the element, replacing an existing
     attribute if necessary if the ‘namespaceURI’ and ‘localName’
     attributes match.  If a replacement occurs, the old attribute node
     will be returned.  If `newAttr' is already in use, *note
     InuseAttributeErr: 2355. will be raised.

 -- Method: Element.setAttributeNS (namespaceURI, qname, value)

     Set an attribute value from a string, given a `namespaceURI' and a
     `qname'.  Note that a qname is the whole attribute name.  This is
     different than above.


File: python.info,  Node: Attr Objects,  Next: NamedNodeMap Objects,  Prev: Element Objects<2>,  Up: Objects in the DOM

5.20.6.9 Attr Objects
.....................

‘Attr’ inherits from ‘Node’, so inherits all its attributes.

 -- Attribute: Attr.name

     The attribute name.  In a namespace-using document it may include a
     colon.

 -- Attribute: Attr.localName

     The part of the name following the colon if there is one, else the
     entire name.  This is a read-only attribute.

 -- Attribute: Attr.prefix

     The part of the name preceding the colon if there is one, else the
     empty string.

 -- Attribute: Attr.value

     The text value of the attribute.  This is a synonym for the
     ‘nodeValue’ attribute.


File: python.info,  Node: NamedNodeMap Objects,  Next: Comment Objects,  Prev: Attr Objects,  Up: Objects in the DOM

5.20.6.10 NamedNodeMap Objects
..............................

‘NamedNodeMap’ does `not' inherit from ‘Node’.

 -- Attribute: NamedNodeMap.length

     The length of the attribute list.

 -- Method: NamedNodeMap.item (index)

     Return an attribute with a particular index.  The order you get the
     attributes in is arbitrary but will be consistent for the life of a
     DOM. Each item is an attribute node.  Get its value with the
     ‘value’ attribute.

There are also experimental methods that give this class more mapping
behavior.  You can use them or you can use the standardized
‘getAttribute*()’ family of methods on the ‘Element’ objects.


File: python.info,  Node: Comment Objects,  Next: Text and CDATASection Objects,  Prev: NamedNodeMap Objects,  Up: Objects in the DOM

5.20.6.11 Comment Objects
.........................

‘Comment’ represents a comment in the XML document.  It is a subclass of
‘Node’, but cannot have child nodes.

 -- Attribute: Comment.data

     The content of the comment as a string.  The attribute contains all
     characters between the leading ‘<!-’‘-’ and trailing ‘-’‘->’, but
     does not include them.


File: python.info,  Node: Text and CDATASection Objects,  Next: ProcessingInstruction Objects,  Prev: Comment Objects,  Up: Objects in the DOM

5.20.6.12 Text and CDATASection Objects
.......................................

The ‘Text’ interface represents text in the XML document.  If the parser
and DOM implementation support the DOM’s XML extension, portions of the
text enclosed in CDATA marked sections are stored in ‘CDATASection’
objects.  These two interfaces are identical, but provide different
values for the ‘nodeType’ attribute.

These interfaces extend the ‘Node’ interface.  They cannot have child
nodes.

 -- Attribute: Text.data

     The content of the text node as a string.

     Note: The use of a ‘CDATASection’ node does not indicate that the
     node represents a complete CDATA marked section, only that the
     content of the node was part of a CDATA section.  A single CDATA
     section may be represented by more than one node in the document
     tree.  There is no way to determine whether two adjacent
     ‘CDATASection’ nodes represent different CDATA marked sections.


File: python.info,  Node: ProcessingInstruction Objects,  Next: Exceptions<12>,  Prev: Text and CDATASection Objects,  Up: Objects in the DOM

5.20.6.13 ProcessingInstruction Objects
.......................................

Represents a processing instruction in the XML document; this inherits
from the ‘Node’ interface and cannot have child nodes.

 -- Attribute: ProcessingInstruction.target

     The content of the processing instruction up to the first
     whitespace character.  This is a read-only attribute.

 -- Attribute: ProcessingInstruction.data

     The content of the processing instruction following the first
     whitespace character.


File: python.info,  Node: Exceptions<12>,  Prev: ProcessingInstruction Objects,  Up: Objects in the DOM

5.20.6.14 Exceptions
....................

The DOM Level 2 recommendation defines a single exception, *note
DOMException: 236a, and a number of constants that allow applications to
determine what sort of error occurred.  *note DOMException: 236a.
instances carry a *note code: 1b. attribute that provides the
appropriate value for the specific exception.

The Python DOM interface provides the constants, but also expands the
set of exceptions so that a specific exception exists for each of the
exception codes defined by the DOM. The implementations must raise the
appropriate specific exception, each of which carries the appropriate
value for the *note code: 1b. attribute.

 -- Exception: xml.dom.DOMException

     Base exception class used for all specific DOM exceptions.  This
     exception class cannot be directly instantiated.

 -- Exception: xml.dom.DomstringSizeErr

     Raised when a specified range of text does not fit into a string.
     This is not known to be used in the Python DOM implementations, but
     may be received from DOM implementations not written in Python.

 -- Exception: xml.dom.HierarchyRequestErr

     Raised when an attempt is made to insert a node where the node type
     is not allowed.

 -- Exception: xml.dom.IndexSizeErr

     Raised when an index or size parameter to a method is negative or
     exceeds the allowed values.

 -- Exception: xml.dom.InuseAttributeErr

     Raised when an attempt is made to insert an ‘Attr’ node that is
     already present elsewhere in the document.

 -- Exception: xml.dom.InvalidAccessErr

     Raised if a parameter or an operation is not supported on the
     underlying object.

 -- Exception: xml.dom.InvalidCharacterErr

     This exception is raised when a string parameter contains a
     character that is not permitted in the context it’s being used in
     by the XML 1.0 recommendation.  For example, attempting to create
     an ‘Element’ node with a space in the element type name will cause
     this error to be raised.

 -- Exception: xml.dom.InvalidModificationErr

     Raised when an attempt is made to modify the type of a node.

 -- Exception: xml.dom.InvalidStateErr

     Raised when an attempt is made to use an object that is not defined
     or is no longer usable.

 -- Exception: xml.dom.NamespaceErr

     If an attempt is made to change any object in a way that is not
     permitted with regard to the Namespaces in XML(1) recommendation,
     this exception is raised.

 -- Exception: xml.dom.NotFoundErr

     Exception when a node does not exist in the referenced context.
     For example, ‘NamedNodeMap.removeNamedItem()’ will raise this if
     the node passed in does not exist in the map.

 -- Exception: xml.dom.NotSupportedErr

     Raised when the implementation does not support the requested type
     of object or operation.

 -- Exception: xml.dom.NoDataAllowedErr

     This is raised if data is specified for a node which does not
     support data.

 -- Exception: xml.dom.NoModificationAllowedErr

     Raised on attempts to modify an object where modifications are not
     allowed (such as for read-only nodes).

 -- Exception: xml.dom.SyntaxErr

     Raised when an invalid or illegal string is specified.

 -- Exception: xml.dom.WrongDocumentErr

     Raised when a node is inserted in a different document than it
     currently belongs to, and the implementation does not support
     migrating the node from one document to the other.

The exception codes defined in the DOM recommendation map to the
exceptions described above according to this table:

Constant                                   Exception
                                           
---------------------------------------------------------------------------------
                                           
‘DOMSTRING_SIZE_ERR’                       *note DomstringSizeErr: 236b.
                                           
                                           
‘HIERARCHY_REQUEST_ERR’                    *note HierarchyRequestErr: 236c.
                                           
                                           
‘INDEX_SIZE_ERR’                           *note IndexSizeErr: 236d.
                                           
                                           
‘INUSE_ATTRIBUTE_ERR’                      *note InuseAttributeErr: 2355.
                                           
                                           
‘INVALID_ACCESS_ERR’                       *note InvalidAccessErr: 236e.
                                           
                                           
‘INVALID_CHARACTER_ERR’                    *note InvalidCharacterErr: 236f.
                                           
                                           
‘INVALID_MODIFICATION_ERR’                 *note InvalidModificationErr: 2370.
                                           
                                           
‘INVALID_STATE_ERR’                        *note InvalidStateErr: 2371.
                                           
                                           
‘NAMESPACE_ERR’                            *note NamespaceErr: 2372.
                                           
                                           
‘NOT_FOUND_ERR’                            *note NotFoundErr: 2350.
                                           
                                           
‘NOT_SUPPORTED_ERR’                        *note NotSupportedErr: 2373.
                                           
                                           
‘NO_DATA_ALLOWED_ERR’                      *note NoDataAllowedErr: 2374.
                                           
                                           
‘NO_MODIFICATION_ALLOWED_ERR’              *note NoModificationAllowedErr: 2375.
                                           
                                           
‘SYNTAX_ERR’                               *note SyntaxErr: 2376.
                                           
                                           
‘WRONG_DOCUMENT_ERR’                       *note WrongDocumentErr: 2377.
                                           

   ---------- Footnotes ----------

   (1) http://www.w3.org/TR/REC-xml-names/


File: python.info,  Node: Conformance,  Prev: Objects in the DOM,  Up: xml dom --- The Document Object Model API

5.20.6.15 Conformance
.....................

This section describes the conformance requirements and relationships
between the Python DOM API, the W3C DOM recommendations, and the OMG IDL
mapping for Python.

* Menu:

* Type Mapping:: 
* Accessor Methods:: 


File: python.info,  Node: Type Mapping,  Next: Accessor Methods,  Up: Conformance

5.20.6.16 Type Mapping
......................

The IDL types used in the DOM specification are mapped to Python types
according to the following table.

IDL Type               Python Type
                       
-----------------------------------------------------------------------
                       
‘boolean’              ‘bool’ or ‘int’
                       
                       
‘int’                  ‘int’
                       
                       
‘long int’             ‘int’
                       
                       
‘unsigned int’         ‘int’
                       
                       
‘DOMString’            ‘str’ or ‘bytes’
                       
                       
‘null’                 ‘None’
                       


File: python.info,  Node: Accessor Methods,  Prev: Type Mapping,  Up: Conformance

5.20.6.17 Accessor Methods
..........................

The mapping from OMG IDL to Python defines accessor functions for IDL
‘attribute’ declarations in much the way the Java mapping does.  Mapping
the IDL declarations

     readonly attribute string someValue;
              attribute string anotherValue;

yields three accessor functions: a "get" method for ‘someValue’
(‘_get_someValue()’), and "get" and "set" methods for ‘anotherValue’
(‘_get_anotherValue()’ and ‘_set_anotherValue()’).  The mapping, in
particular, does not require that the IDL attributes are accessible as
normal Python attributes: ‘object.someValue’ is `not' required to work,
and may raise an *note AttributeError: 356.

The Python DOM API, however, `does' require that normal attribute access
work.  This means that the typical surrogates generated by Python IDL
compilers are not likely to work, and wrapper objects may be needed on
the client if the DOM objects are accessed via CORBA. While this does
require some additional consideration for CORBA DOM clients, the
implementers with experience using DOM over CORBA from Python do not
consider this a problem.  Attributes that are declared ‘readonly’ may
not restrict write access in all DOM implementations.

In the Python DOM API, accessor functions are not required.  If
provided, they should take the form defined by the Python IDL mapping,
but these methods are considered unnecessary since the attributes are
accessible directly from Python.  "Set" accessors should never be
provided for ‘readonly’ attributes.

The IDL definitions do not fully embody the requirements of the W3C DOM
API, such as the notion of certain objects, such as the return value of
‘getElementsByTagName()’, being "live".  The Python DOM API does not
require implementations to enforce such requirements.


File: python.info,  Node: xml dom minidom --- Minimal DOM implementation,  Next: xml dom pulldom --- Support for building partial DOM trees,  Prev: xml dom --- The Document Object Model API,  Up: Structured Markup Processing Tools

5.20.7 ‘xml.dom.minidom’ — Minimal DOM implementation
-----------------------------------------------------

`Source code:' Lib/xml/dom/minidom.py(1)

__________________________________________________________________

*note xml.dom.minidom: 132. is a minimal implementation of the Document
Object Model interface, with an API similar to that in other languages.
It is intended to be simpler than the full DOM and also significantly
smaller.  Users who are not already proficient with the DOM should
consider using the *note xml.etree.ElementTree: 134. module for their
XML processing instead.

     Warning: The *note xml.dom.minidom: 132. module is not secure
     against maliciously constructed data.  If you need to parse
     untrusted or unauthenticated data see *note XML vulnerabilities:
     22a9.

DOM applications typically start by parsing some XML into a DOM. With
*note xml.dom.minidom: 132, this is done through the parse functions:

     from xml.dom.minidom import parse, parseString

     dom1 = parse('c:\\temp\\mydata.xml') # parse an XML file by name

     datasource = open('c:\\temp\\mydata.xml')
     dom2 = parse(datasource)   # parse an open file

     dom3 = parseString('<myxml>Some data<empty/> some more data</myxml>')

The *note parse(): 237f. function can take either a filename or an open
file object.

 -- Function: xml.dom.minidom.parse (filename_or_file, parser=None,
          bufsize=None)

     Return a ‘Document’ from the given input.  `filename_or_file' may
     be either a file name, or a file-like object.  `parser', if given,
     must be a SAX2 parser object.  This function will change the
     document handler of the parser and activate namespace support;
     other parser configuration (like setting an entity resolver) must
     have been done in advance.

If you have XML in a string, you can use the *note parseString(): 2380.
function instead:

 -- Function: xml.dom.minidom.parseString (string, parser=None)

     Return a ‘Document’ that represents the `string'.  This method
     creates an *note io.StringIO: 41e. object for the string and passes
     that on to *note parse(): 237f.

Both functions return a ‘Document’ object representing the content of
the document.

What the *note parse(): 237f. and *note parseString(): 2380. functions
do is connect an XML parser with a "DOM builder" that can accept parse
events from any SAX parser and convert them into a DOM tree.  The name
of the functions are perhaps misleading, but are easy to grasp when
learning the interfaces.  The parsing of the document will be completed
before these functions return; it’s simply that these functions do not
provide a parser implementation themselves.

You can also create a ‘Document’ by calling a method on a "DOM
Implementation" object.  You can get this object either by calling the
‘getDOMImplementation()’ function in the *note xml.dom: 131. package or
the *note xml.dom.minidom: 132. module.  Once you have a ‘Document’, you
can add child nodes to it to populate the DOM:

     from xml.dom.minidom import getDOMImplementation

     impl = getDOMImplementation()

     newdoc = impl.createDocument(None, "some_tag", None)
     top_element = newdoc.documentElement
     text = newdoc.createTextNode('Some textual content.')
     top_element.appendChild(text)

Once you have a DOM document object, you can access the parts of your
XML document through its properties and methods.  These properties are
defined in the DOM specification.  The main property of the document
object is the ‘documentElement’ property.  It gives you the main element
in the XML document: the one that holds all others.  Here is an example
program:

     dom3 = parseString("<myxml>Some data</myxml>")
     assert dom3.documentElement.tagName == "myxml"

When you are finished with a DOM tree, you may optionally call the
‘unlink()’ method to encourage early cleanup of the now-unneeded
objects.  ‘unlink()’ is a *note xml.dom.minidom: 132.-specific extension
to the DOM API that renders the node and its descendants are essentially
useless.  Otherwise, Python’s garbage collector will eventually take
care of the objects in the tree.

See also
........

Document Object Model (DOM) Level 1 Specification(2)

     The W3C recommendation for the DOM supported by *note
     xml.dom.minidom: 132.

* Menu:

* DOM Objects:: 
* DOM Example:: 
* minidom and the DOM standard:: 

   ---------- Footnotes ----------

   (1) https://hg.python.org/cpython/file/default/Lib/xml/dom/minidom.py

   (2) http://www.w3.org/TR/REC-DOM-Level-1/


File: python.info,  Node: DOM Objects,  Next: DOM Example,  Up: xml dom minidom --- Minimal DOM implementation

5.20.7.1 DOM Objects
....................

The definition of the DOM API for Python is given as part of the *note
xml.dom: 131. module documentation.  This section lists the differences
between the API and *note xml.dom.minidom: 132.

 -- Method: Node.unlink ()

     Break internal references within the DOM so that it will be garbage
     collected on versions of Python without cyclic GC. Even when cyclic
     GC is available, using this can make large amounts of memory
     available sooner, so calling this on DOM objects as soon as they
     are no longer needed is good practice.  This only needs to be
     called on the ‘Document’ object, but may be called on child nodes
     to discard children of that node.

     You can avoid calling this method explicitly by using the *note
     with: 29d. statement.  The following code will automatically unlink
     `dom' when the *note with: 29d. block is exited:

          with xml.dom.minidom.parse(datasource) as dom:
              ... # Work with dom.

 -- Method: Node.writexml (writer, indent="", addindent="", newl="")

     Write XML to the writer object.  The writer should have a ‘write()’
     method which matches that of the file object interface.  The
     `indent' parameter is the indentation of the current node.  The
     `addindent' parameter is the incremental indentation to use for
     subnodes of the current one.  The `newl' parameter specifies the
     string to use to terminate newlines.

     For the ‘Document’ node, an additional keyword argument `encoding'
     can be used to specify the encoding field of the XML header.

 -- Method: Node.toxml (encoding=None)

     Return a string or byte string containing the XML represented by
     the DOM node.

     With an explicit `encoding' (1) argument, the result is a byte
     string in the specified encoding.  With no `encoding' argument, the
     result is a Unicode string, and the XML declaration in the
     resulting string does not specify an encoding.  Encoding this
     string in an encoding other than UTF-8 is likely incorrect, since
     UTF-8 is the default encoding of XML.

 -- Method: Node.toprettyxml (indent="", newl="", encoding="")

     Return a pretty-printed version of the document.  `indent'
     specifies the indentation string and defaults to a tabulator;
     `newl' specifies the string emitted at the end of each line and
     defaults to ‘\n’.

     The `encoding' argument behaves like the corresponding argument of
     *note toxml(): 2385.

   ---------- Footnotes ----------

   (1) The encoding name included in the XML output should conform to
the appropriate standards.  For example, "UTF-8" is valid, but "UTF8" is
not valid in an XML document’s declaration, even though Python accepts
it as an encoding name.  See
‘http://www.w3.org/TR/2006/REC-xml11-20060816/#NT-EncodingDecl’ and
‘http://www.iana.org/assignments/character-sets/character-sets.xhtml’.


File: python.info,  Node: DOM Example,  Next: minidom and the DOM standard,  Prev: DOM Objects,  Up: xml dom minidom --- Minimal DOM implementation

5.20.7.2 DOM Example
....................

This example program is a fairly realistic example of a simple program.
In this particular case, we do not take much advantage of the
flexibility of the DOM.

     import xml.dom.minidom

     document = """\
     <slideshow>
     <title>Demo slideshow</title>
     <slide><title>Slide title</title>
     <point>This is a demo</point>
     <point>Of a program for processing slides</point>
     </slide>

     <slide><title>Another demo slide</title>
     <point>It is important</point>
     <point>To have more than</point>
     <point>one slide</point>
     </slide>
     </slideshow>
     """

     dom = xml.dom.minidom.parseString(document)

     def getText(nodelist):
         rc = []
         for node in nodelist:
             if node.nodeType == node.TEXT_NODE:
                 rc.append(node.data)
         return ''.join(rc)

     def handleSlideshow(slideshow):
         print("<html>")
         handleSlideshowTitle(slideshow.getElementsByTagName("title")[0])
         slides = slideshow.getElementsByTagName("slide")
         handleToc(slides)
         handleSlides(slides)
         print("</html>")

     def handleSlides(slides):
         for slide in slides:
             handleSlide(slide)

     def handleSlide(slide):
         handleSlideTitle(slide.getElementsByTagName("title")[0])
         handlePoints(slide.getElementsByTagName("point"))

     def handleSlideshowTitle(title):
         print("<title>%s</title>" % getText(title.childNodes))

     def handleSlideTitle(title):
         print("<h2>%s</h2>" % getText(title.childNodes))

     def handlePoints(points):
         print("<ul>")
         for point in points:
             handlePoint(point)
         print("</ul>")

     def handlePoint(point):
         print("<li>%s</li>" % getText(point.childNodes))

     def handleToc(slides):
         for slide in slides:
             title = slide.getElementsByTagName("title")[0]
             print("<p>%s</p>" % getText(title.childNodes))

     handleSlideshow(dom)


File: python.info,  Node: minidom and the DOM standard,  Prev: DOM Example,  Up: xml dom minidom --- Minimal DOM implementation

5.20.7.3 minidom and the DOM standard
.....................................

The *note xml.dom.minidom: 132. module is essentially a DOM
1.0-compatible DOM with some DOM 2 features (primarily namespace
features).

Usage of the DOM interface in Python is straight-forward.  The following
mapping rules apply:

   * Interfaces are accessed through instance objects.  Applications
     should not instantiate the classes themselves; they should use the
     creator functions available on the ‘Document’ object.  Derived
     interfaces support all operations (and attributes) from the base
     interfaces, plus any new operations.

   * Operations are used as methods.  Since the DOM uses only *note in:
     37d. parameters, the arguments are passed in normal order (from
     left to right).  There are no optional arguments.  ‘void’
     operations return ‘None’.

   * IDL attributes map to instance attributes.  For compatibility with
     the OMG IDL language mapping for Python, an attribute ‘foo’ can
     also be accessed through accessor methods ‘_get_foo()’ and
     ‘_set_foo()’.  ‘readonly’ attributes must not be changed; this is
     not enforced at runtime.

   * The types ‘short int’, ‘unsigned int’, ‘unsigned long long’, and
     ‘boolean’ all map to Python integer objects.

   * The type ‘DOMString’ maps to Python strings.  *note
     xml.dom.minidom: 132. supports either bytes or strings, but will
     normally produce strings.  Values of type ‘DOMString’ may also be
     ‘None’ where allowed to have the IDL ‘null’ value by the DOM
     specification from the W3C.

   * ‘const’ declarations map to variables in their respective scope
     (e.g.  ‘xml.dom.minidom.Node.PROCESSING_INSTRUCTION_NODE’); they
     must not be changed.

   * ‘DOMException’ is currently not supported in *note xml.dom.minidom:
     132.  Instead, *note xml.dom.minidom: 132. uses standard Python
     exceptions such as *note TypeError: 562. and *note AttributeError:
     356.

   * ‘NodeList’ objects are implemented using Python’s built-in list
     type.  These objects provide the interface defined in the DOM
     specification, but with earlier versions of Python they do not
     support the official API. They are, however, much more "Pythonic"
     than the interface defined in the W3C recommendations.

The following interfaces have no implementation in *note
xml.dom.minidom: 132.:

   * ‘DOMTimeStamp’

   * ‘DocumentType’

   * ‘DOMImplementation’

   * ‘CharacterData’

   * ‘CDATASection’

   * ‘Notation’

   * ‘Entity’

   * ‘EntityReference’

   * ‘DocumentFragment’

Most of these reflect information in the XML document that is not of
general utility to most DOM users.


File: python.info,  Node: xml dom pulldom --- Support for building partial DOM trees,  Next: xml sax --- Support for SAX2 parsers,  Prev: xml dom minidom --- Minimal DOM implementation,  Up: Structured Markup Processing Tools

5.20.8 ‘xml.dom.pulldom’ — Support for building partial DOM trees
-----------------------------------------------------------------

`Source code:' Lib/xml/dom/pulldom.py(1)

__________________________________________________________________

The *note xml.dom.pulldom: 133. module provides a "pull parser" which
can also be asked to produce DOM-accessible fragments of the document
where necessary.  The basic concept involves pulling "events" from a
stream of incoming XML and processing them.  In contrast to SAX which
also employs an event-driven processing model together with callbacks,
the user of a pull parser is responsible for explicitly pulling events
from the stream, looping over those events until either processing is
finished or an error condition occurs.

     Warning: The *note xml.dom.pulldom: 133. module is not secure
     against maliciously constructed data.  If you need to parse
     untrusted or unauthenticated data see *note XML vulnerabilities:
     22a9.

Example:

     from xml.dom import pulldom

     doc = pulldom.parse('sales_items.xml')
     for event, node in doc:
         if event == pulldom.START_ELEMENT and node.tagName == 'item':
             if int(node.getAttribute('price')) > 50:
                 doc.expandNode(node)
                 print(node.toxml())

‘event’ is a constant and can be one of:

   * ‘START_ELEMENT’

   * ‘END_ELEMENT’

   * ‘COMMENT’

   * ‘START_DOCUMENT’

   * ‘END_DOCUMENT’

   * ‘CHARACTERS’

   * ‘PROCESSING_INSTRUCTION’

   * ‘IGNORABLE_WHITESPACE’

‘node’ is an object of type ‘xml.dom.minidom.Document’,
‘xml.dom.minidom.Element’ or ‘xml.dom.minidom.Text’.

Since the document is treated as a "flat" stream of events, the document
"tree" is implicitly traversed and the desired elements are found
regardless of their depth in the tree.  In other words, one does not
need to consider hierarchical issues such as recursive searching of the
document nodes, although if the context of elements were important, one
would either need to maintain some context-related state (i.e.
remembering where one is in the document at any given point) or to make
use of the *note DOMEventStream.expandNode(): 238d. method and switch to
DOM-related processing.

 -- Class: xml.dom.pulldom.PullDom (documentFactory=None)

     Subclass of *note xml.sax.handler.ContentHandler: 238f.

 -- Class: xml.dom.pulldom.SAX2DOM (documentFactory=None)

     Subclass of *note xml.sax.handler.ContentHandler: 238f.

 -- Function: xml.dom.pulldom.parse (stream_or_string, parser=None,
          bufsize=None)

     Return a *note DOMEventStream: 2392. from the given input.
     `stream_or_string' may be either a file name, or a file-like
     object.  `parser', if given, must be a *note XMLReader: 2393.
     object.  This function will change the document handler of the
     parser and activate namespace support; other parser configuration
     (like setting an entity resolver) must have been done in advance.

If you have XML in a string, you can use the *note parseString(): 2394.
function instead:

 -- Function: xml.dom.pulldom.parseString (string, parser=None)

     Return a *note DOMEventStream: 2392. that represents the (Unicode)
     `string'.

 -- Data: xml.dom.pulldom.default_bufsize

     Default value for the `bufsize' parameter to *note parse(): 2391.

     The value of this variable can be changed before calling *note
     parse(): 2391. and the new value will take effect.

* Menu:

* DOMEventStream Objects:: 

   ---------- Footnotes ----------

   (1) https://hg.python.org/cpython/file/default/Lib/xml/dom/pulldom.py


File: python.info,  Node: DOMEventStream Objects,  Up: xml dom pulldom --- Support for building partial DOM trees

5.20.8.1 DOMEventStream Objects
...............................

 -- Class: xml.dom.pulldom.DOMEventStream (stream, parser, bufsize)

      -- Method: getEvent ()

          Return a tuple containing `event' and the current `node' as
          ‘xml.dom.minidom.Document’ if event equals ‘START_DOCUMENT’,
          ‘xml.dom.minidom.Element’ if event equals ‘START_ELEMENT’ or
          ‘END_ELEMENT’ or ‘xml.dom.minidom.Text’ if event equals
          ‘CHARACTERS’.  The current node does not contain informations
          about its children, unless *note expandNode(): 238d. is
          called.

      -- Method: expandNode (node)

          Expands all children of `node' into `node'.  Example:

               from xml.dom import pulldom

               xml = '<html><title>Foo</title> <p>Some text <div>and more</div></p> </html>'
               doc = pulldom.parseString(xml)
               for event, node in doc:
                   if event == pulldom.START_ELEMENT and node.tagName == 'p':
                       # Following statement only prints '<p/>'
                       print(node.toxml())
                       doc.expandNode(node)
                       # Following statement prints node with all its children '<p>Some text <div>and more</div></p>'
                       print(node.toxml())

      -- Method: reset ()


File: python.info,  Node: xml sax --- Support for SAX2 parsers,  Next: xml sax handler --- Base classes for SAX handlers,  Prev: xml dom pulldom --- Support for building partial DOM trees,  Up: Structured Markup Processing Tools

5.20.9 ‘xml.sax’ — Support for SAX2 parsers
-------------------------------------------

The *note xml.sax: 138. package provides a number of modules which
implement the Simple API for XML (SAX) interface for Python.  The
package itself provides the SAX exceptions and the convenience functions
which will be most used by users of the SAX API.

     Warning: The *note xml.sax: 138. module is not secure against
     maliciously constructed data.  If you need to parse untrusted or
     unauthenticated data see *note XML vulnerabilities: 22a9.

The convenience functions are:

 -- Function: xml.sax.make_parser (parser_list=[])

     Create and return a SAX *note XMLReader: 2393. object.  The first
     parser found will be used.  If `parser_list' is provided, it must
     be a sequence of strings which name modules that have a function
     named ‘create_parser()’.  Modules listed in `parser_list' will be
     used before modules in the default list of parsers.

 -- Function: xml.sax.parse (filename_or_stream, handler,
          error_handler=handler.ErrorHandler())

     Create a SAX parser and use it to parse a document.  The document,
     passed in as `filename_or_stream', can be a filename or a file
     object.  The `handler' parameter needs to be a SAX *note
     ContentHandler: 238f. instance.  If `error_handler' is given, it
     must be a SAX *note ErrorHandler: 239e. instance; if omitted, *note
     SAXParseException: 239f. will be raised on all errors.  There is no
     return value; all work must be done by the `handler' passed in.

 -- Function: xml.sax.parseString (string, handler,
          error_handler=handler.ErrorHandler())

     Similar to *note parse(): 239d, but parses from a buffer `string'
     received as a parameter.  `string' must be a *note str: 25a.
     instance or a *note bytes-like object: 36b.

     Changed in version 3.5: Added support of *note str: 25a. instances.

A typical SAX application uses three kinds of objects: readers, handlers
and input sources.  "Reader" in this context is another term for parser,
i.e.  some piece of code that reads the bytes or characters from the
input source, and produces a sequence of events.  The events then get
distributed to the handler objects, i.e.  the reader invokes a method on
the handler.  A SAX application must therefore obtain a reader object,
create or open the input sources, create the handlers, and connect these
objects all together.  As the final step of preparation, the reader is
called to parse the input.  During parsing, methods on the handler
objects are called based on structural and syntactic events from the
input data.

For these objects, only the interfaces are relevant; they are normally
not instantiated by the application itself.  Since Python does not have
an explicit notion of interface, they are formally introduced as
classes, but applications may use implementations which do not inherit
from the provided classes.  The *note InputSource: 366, *note Locator:
23a0, ‘Attributes’, ‘AttributesNS’, and *note XMLReader: 2393.
interfaces are defined in the module *note xml.sax.xmlreader: 13b.  The
handler interfaces are defined in *note xml.sax.handler: 139.  For
convenience, *note InputSource: 366. (which is often instantiated
directly) and the handler classes are also available from *note xml.sax:
138.  These interfaces are described below.

In addition to these classes, *note xml.sax: 138. provides the following
exception classes.

 -- Exception: xml.sax.SAXException (msg, exception=None)

     Encapsulate an XML error or warning.  This class can contain basic
     error or warning information from either the XML parser or the
     application: it can be subclassed to provide additional
     functionality or to add localization.  Note that although the
     handlers defined in the *note ErrorHandler: 239e. interface receive
     instances of this exception, it is not required to actually raise
     the exception — it is also useful as a container for information.

     When instantiated, `msg' should be a human-readable description of
     the error.  The optional `exception' parameter, if given, should be
     ‘None’ or an exception that was caught by the parsing code and is
     being passed along as information.

     This is the base class for the other SAX exception classes.

 -- Exception: xml.sax.SAXParseException (msg, exception, locator)

     Subclass of *note SAXException: 23a1. raised on parse errors.
     Instances of this class are passed to the methods of the SAX *note
     ErrorHandler: 239e. interface to provide information about the
     parse error.  This class supports the SAX *note Locator: 23a0.
     interface as well as the *note SAXException: 23a1. interface.

 -- Exception: xml.sax.SAXNotRecognizedException (msg, exception=None)

     Subclass of *note SAXException: 23a1. raised when a SAX *note
     XMLReader: 2393. is confronted with an unrecognized feature or
     property.  SAX applications and extensions may use this class for
     similar purposes.

 -- Exception: xml.sax.SAXNotSupportedException (msg, exception=None)

     Subclass of *note SAXException: 23a1. raised when a SAX *note
     XMLReader: 2393. is asked to enable a feature that is not
     supported, or to set a property to a value that the implementation
     does not support.  SAX applications and extensions may use this
     class for similar purposes.

See also
........

SAX: The Simple API for XML(1)

     This site is the focal point for the definition of the SAX API. It
     provides a Java implementation and online documentation.  Links to
     implementations and historical information are also available.

Module *note xml.sax.handler: 139.

     Definitions of the interfaces for application-provided objects.

Module *note xml.sax.saxutils: 13a.

     Convenience functions for use in SAX applications.

Module *note xml.sax.xmlreader: 13b.

     Definitions of the interfaces for parser-provided objects.

* Menu:

* SAXException Objects:: 

   ---------- Footnotes ----------

   (1) http://www.saxproject.org/


File: python.info,  Node: SAXException Objects,  Up: xml sax --- Support for SAX2 parsers

5.20.9.1 SAXException Objects
.............................

The *note SAXException: 23a1. exception class supports the following
methods:

 -- Method: SAXException.getMessage ()

     Return a human-readable message describing the error condition.

 -- Method: SAXException.getException ()

     Return an encapsulated exception object, or ‘None’.


File: python.info,  Node: xml sax handler --- Base classes for SAX handlers,  Next: xml sax saxutils --- SAX Utilities,  Prev: xml sax --- Support for SAX2 parsers,  Up: Structured Markup Processing Tools

5.20.10 ‘xml.sax.handler’ — Base classes for SAX handlers
---------------------------------------------------------

The SAX API defines four kinds of handlers: content handlers, DTD
handlers, error handlers, and entity resolvers.  Applications normally
only need to implement those interfaces whose events they are interested
in; they can implement the interfaces in a single object or in multiple
objects.  Handler implementations should inherit from the base classes
provided in the module *note xml.sax.handler: 139, so that all methods
get default implementations.

 -- Class: xml.sax.handler.ContentHandler

     This is the main callback interface in SAX, and the one most
     important to applications.  The order of events in this interface
     mirrors the order of the information in the document.

 -- Class: xml.sax.handler.DTDHandler

     Handle DTD events.

     This interface specifies only those DTD events required for basic
     parsing (unparsed entities and attributes).

 -- Class: xml.sax.handler.EntityResolver

     Basic interface for resolving entities.  If you create an object
     implementing this interface, then register the object with your
     Parser, the parser will call the method in your object to resolve
     all external entities.

 -- Class: xml.sax.handler.ErrorHandler

     Interface used by the parser to present error and warning messages
     to the application.  The methods of this object control whether
     errors are immediately converted to exceptions or are handled in
     some other way.

In addition to these classes, *note xml.sax.handler: 139. provides
symbolic constants for the feature and property names.

 -- Data: xml.sax.handler.feature_namespaces

          value: ‘"http://xml.org/sax/features/namespaces"’ 
          true: Perform Namespace processing. 
          false: Optionally do not perform Namespace processing (implies namespace-prefixes; default). 
          access: (parsing) read-only; (not parsing) read/write 

 -- Data: xml.sax.handler.feature_namespace_prefixes

          value: ‘"http://xml.org/sax/features/namespace-prefixes"’ 
          true: Report the original prefixed names and attributes used for Namespace declarations. 
          false: Do not report attributes used for Namespace declarations, and optionally do not report original prefixed names (default). 
          access: (parsing) read-only; (not parsing) read/write 

 -- Data: xml.sax.handler.feature_string_interning

          value: ‘"http://xml.org/sax/features/string-interning"’ 
          true: All element names, prefixes, attribute names, Namespace URIs, and local names are interned using the built-in intern function. 
          false: Names are not necessarily interned, although they may be (default). 
          access: (parsing) read-only; (not parsing) read/write 

 -- Data: xml.sax.handler.feature_validation

          value: ‘"http://xml.org/sax/features/validation"’ 
          true: Report all validation errors (implies external-general-entities and external-parameter-entities). 
          false: Do not report validation errors. 
          access: (parsing) read-only; (not parsing) read/write 

 -- Data: xml.sax.handler.feature_external_ges

          value: ‘"http://xml.org/sax/features/external-general-entities"’ 
          true: Include all external general (text) entities. 
          false: Do not include external general entities. 
          access: (parsing) read-only; (not parsing) read/write 

 -- Data: xml.sax.handler.feature_external_pes

          value: ‘"http://xml.org/sax/features/external-parameter-entities"’ 
          true: Include all external parameter entities, including the external DTD subset. 
          false: Do not include any external parameter entities, even the external DTD subset. 
          access: (parsing) read-only; (not parsing) read/write 

 -- Data: xml.sax.handler.all_features

     List of all features.

 -- Data: xml.sax.handler.property_lexical_handler

          value: ‘"http://xml.org/sax/properties/lexical-handler"’ 
          data type: xml.sax.sax2lib.LexicalHandler (not supported in Python 2) 
          description: An optional extension handler for lexical events like comments. 
          access: read/write 

 -- Data: xml.sax.handler.property_declaration_handler

          value: ‘"http://xml.org/sax/properties/declaration-handler"’ 
          data type: xml.sax.sax2lib.DeclHandler (not supported in Python 2) 
          description: An optional extension handler for DTD-related events other than notations and unparsed entities. 
          access: read/write 

 -- Data: xml.sax.handler.property_dom_node

          value: ‘"http://xml.org/sax/properties/dom-node"’ 
          data type: org.w3c.dom.Node (not supported in Python 2) 
          description: When parsing, the current DOM node being visited if this is a DOM iterator; when not parsing, the root DOM node for iteration. 
          access: (parsing) read-only; (not parsing) read/write 

 -- Data: xml.sax.handler.property_xml_string

          value: ‘"http://xml.org/sax/properties/xml-string"’ 
          data type: String 
          description: The literal string of characters that was the source for the current event. 
          access: read-only 

 -- Data: xml.sax.handler.all_properties

     List of all known property names.

* Menu:

* ContentHandler Objects:: 
* DTDHandler Objects:: 
* EntityResolver Objects:: 
* ErrorHandler Objects:: 


File: python.info,  Node: ContentHandler Objects,  Next: DTDHandler Objects,  Up: xml sax handler --- Base classes for SAX handlers

5.20.10.1 ContentHandler Objects
................................

Users are expected to subclass *note ContentHandler: 238f. to support
their application.  The following methods are called by the parser on
the appropriate events in the input document:

 -- Method: ContentHandler.setDocumentLocator (locator)

     Called by the parser to give the application a locator for locating
     the origin of document events.

     SAX parsers are strongly encouraged (though not absolutely
     required) to supply a locator: if it does so, it must supply the
     locator to the application by invoking this method before invoking
     any of the other methods in the DocumentHandler interface.

     The locator allows the application to determine the end position of
     any document-related event, even if the parser is not reporting an
     error.  Typically, the application will use this information for
     reporting its own errors (such as character content that does not
     match an application’s business rules).  The information returned
     by the locator is probably not sufficient for use with a search
     engine.

     Note that the locator will return correct information only during
     the invocation of the events in this interface.  The application
     should not attempt to use it at any other time.

 -- Method: ContentHandler.startDocument ()

     Receive notification of the beginning of a document.

     The SAX parser will invoke this method only once, before any other
     methods in this interface or in DTDHandler (except for *note
     setDocumentLocator(): 23ba.).

 -- Method: ContentHandler.endDocument ()

     Receive notification of the end of a document.

     The SAX parser will invoke this method only once, and it will be
     the last method invoked during the parse.  The parser shall not
     invoke this method until it has either abandoned parsing (because
     of an unrecoverable error) or reached the end of input.

 -- Method: ContentHandler.startPrefixMapping (prefix, uri)

     Begin the scope of a prefix-URI Namespace mapping.

     The information from this event is not necessary for normal
     Namespace processing: the SAX XML reader will automatically replace
     prefixes for element and attribute names when the
     ‘feature_namespaces’ feature is enabled (the default).

     There are cases, however, when applications need to use prefixes in
     character data or in attribute values, where they cannot safely be
     expanded automatically; the *note startPrefixMapping(): 23bd. and
     *note endPrefixMapping(): 23be. events supply the information to
     the application to expand prefixes in those contexts itself, if
     necessary.

     Note that *note startPrefixMapping(): 23bd. and *note
     endPrefixMapping(): 23be. events are not guaranteed to be properly
     nested relative to each-other: all *note startPrefixMapping():
     23bd. events will occur before the corresponding *note
     startElement(): 23bf. event, and all *note endPrefixMapping():
     23be. events will occur after the corresponding *note endElement():
     23c0. event, but their order is not guaranteed.

 -- Method: ContentHandler.endPrefixMapping (prefix)

     End the scope of a prefix-URI mapping.

     See *note startPrefixMapping(): 23bd. for details.  This event will
     always occur after the corresponding *note endElement(): 23c0.
     event, but the order of *note endPrefixMapping(): 23be. events is
     not otherwise guaranteed.

 -- Method: ContentHandler.startElement (name, attrs)

     Signals the start of an element in non-namespace mode.

     The `name' parameter contains the raw XML 1.0 name of the element
     type as a string and the `attrs' parameter holds an object of the
     ‘Attributes’ interface (see *note The Attributes Interface: 23c1.)
     containing the attributes of the element.  The object passed as
     `attrs' may be re-used by the parser; holding on to a reference to
     it is not a reliable way to keep a copy of the attributes.  To keep
     a copy of the attributes, use the *note copy(): 25. method of the
     `attrs' object.

 -- Method: ContentHandler.endElement (name)

     Signals the end of an element in non-namespace mode.

     The `name' parameter contains the name of the element type, just as
     with the *note startElement(): 23bf. event.

 -- Method: ContentHandler.startElementNS (name, qname, attrs)

     Signals the start of an element in namespace mode.

     The `name' parameter contains the name of the element type as a
     ‘(uri, localname)’ tuple, the `qname' parameter contains the raw
     XML 1.0 name used in the source document, and the `attrs' parameter
     holds an instance of the ‘AttributesNS’ interface (see *note The
     AttributesNS Interface: 23c3.) containing the attributes of the
     element.  If no namespace is associated with the element, the `uri'
     component of `name' will be ‘None’.  The object passed as `attrs'
     may be re-used by the parser; holding on to a reference to it is
     not a reliable way to keep a copy of the attributes.  To keep a
     copy of the attributes, use the *note copy(): 25. method of the
     `attrs' object.

     Parsers may set the `qname' parameter to ‘None’, unless the
     ‘feature_namespace_prefixes’ feature is activated.

 -- Method: ContentHandler.endElementNS (name, qname)

     Signals the end of an element in namespace mode.

     The `name' parameter contains the name of the element type, just as
     with the *note startElementNS(): 23c2. method, likewise the `qname'
     parameter.

 -- Method: ContentHandler.characters (content)

     Receive notification of character data.

     The Parser will call this method to report each chunk of character
     data.  SAX parsers may return all contiguous character data in a
     single chunk, or they may split it into several chunks; however,
     all of the characters in any single event must come from the same
     external entity so that the Locator provides useful information.

     `content' may be a string or bytes instance; the ‘expat’ reader
     module always produces strings.

          Note: The earlier SAX 1 interface provided by the Python XML
          Special Interest Group used a more Java-like interface for
          this method.  Since most parsers used from Python did not take
          advantage of the older interface, the simpler signature was
          chosen to replace it.  To convert old code to the new
          interface, use `content' instead of slicing content with the
          old `offset' and `length' parameters.

 -- Method: ContentHandler.ignorableWhitespace (whitespace)

     Receive notification of ignorable whitespace in element content.

     Validating Parsers must use this method to report each chunk of
     ignorable whitespace (see the W3C XML 1.0 recommendation, section
     2.10): non-validating parsers may also use this method if they are
     capable of parsing and using content models.

     SAX parsers may return all contiguous whitespace in a single chunk,
     or they may split it into several chunks; however, all of the
     characters in any single event must come from the same external
     entity, so that the Locator provides useful information.

 -- Method: ContentHandler.processingInstruction (target, data)

     Receive notification of a processing instruction.

     The Parser will invoke this method once for each processing
     instruction found: note that processing instructions may occur
     before or after the main document element.

     A SAX parser should never report an XML declaration (XML 1.0,
     section 2.8) or a text declaration (XML 1.0, section 4.3.1) using
     this method.

 -- Method: ContentHandler.skippedEntity (name)

     Receive notification of a skipped entity.

     The Parser will invoke this method once for each entity skipped.
     Non-validating processors may skip entities if they have not seen
     the declarations (because, for example, the entity was declared in
     an external DTD subset).  All processors may skip external
     entities, depending on the values of the ‘feature_external_ges’ and
     the ‘feature_external_pes’ properties.


File: python.info,  Node: DTDHandler Objects,  Next: EntityResolver Objects,  Prev: ContentHandler Objects,  Up: xml sax handler --- Base classes for SAX handlers

5.20.10.2 DTDHandler Objects
............................

*note DTDHandler: 23aa. instances provide the following methods:

 -- Method: DTDHandler.notationDecl (name, publicId, systemId)

     Handle a notation declaration event.

 -- Method: DTDHandler.unparsedEntityDecl (name, publicId, systemId,
          ndata)

     Handle an unparsed entity declaration event.


File: python.info,  Node: EntityResolver Objects,  Next: ErrorHandler Objects,  Prev: DTDHandler Objects,  Up: xml sax handler --- Base classes for SAX handlers

5.20.10.3 EntityResolver Objects
................................

 -- Method: EntityResolver.resolveEntity (publicId, systemId)

     Resolve the system identifier of an entity and return either the
     system identifier to read from as a string, or an InputSource to
     read from.  The default implementation returns `systemId'.


File: python.info,  Node: ErrorHandler Objects,  Prev: EntityResolver Objects,  Up: xml sax handler --- Base classes for SAX handlers

5.20.10.4 ErrorHandler Objects
..............................

Objects with this interface are used to receive error and warning
information from the *note XMLReader: 2393.  If you create an object
that implements this interface, then register the object with your *note
XMLReader: 2393, the parser will call the methods in your object to
report all warnings and errors.  There are three levels of errors
available: warnings, (possibly) recoverable errors, and unrecoverable
errors.  All methods take a ‘SAXParseException’ as the only parameter.
Errors and warnings may be converted to an exception by raising the
passed-in exception object.

 -- Method: ErrorHandler.error (exception)

     Called when the parser encounters a recoverable error.  If this
     method does not raise an exception, parsing may continue, but
     further document information should not be expected by the
     application.  Allowing the parser to continue may allow additional
     errors to be discovered in the input document.

 -- Method: ErrorHandler.fatalError (exception)

     Called when the parser encounters an error it cannot recover from;
     parsing is expected to terminate when this method returns.

 -- Method: ErrorHandler.warning (exception)

     Called when the parser presents minor warning information to the
     application.  Parsing is expected to continue when this method
     returns, and document information will continue to be passed to the
     application.  Raising an exception in this method will cause
     parsing to end.


File: python.info,  Node: xml sax saxutils --- SAX Utilities,  Next: xml sax xmlreader --- Interface for XML parsers,  Prev: xml sax handler --- Base classes for SAX handlers,  Up: Structured Markup Processing Tools

5.20.11 ‘xml.sax.saxutils’ — SAX Utilities
------------------------------------------

The module *note xml.sax.saxutils: 13a. contains a number of classes and
functions that are commonly useful when creating SAX applications,
either in direct use, or as base classes.

 -- Function: xml.sax.saxutils.escape (data, entities={})

     Escape ‘'&'’, ‘'<'’, and ‘'>'’ in a string of data.

     You can escape other strings of data by passing a dictionary as the
     optional `entities' parameter.  The keys and values must all be
     strings; each key will be replaced with its corresponding value.
     The characters ‘'&'’, ‘'<'’ and ‘'>'’ are always escaped, even if
     `entities' is provided.

 -- Function: xml.sax.saxutils.unescape (data, entities={})

     Unescape ‘'&amp;'’, ‘'&lt;'’, and ‘'&gt;'’ in a string of data.

     You can unescape other strings of data by passing a dictionary as
     the optional `entities' parameter.  The keys and values must all be
     strings; each key will be replaced with its corresponding value.
     ‘'&amp'’, ‘'&lt;'’, and ‘'&gt;'’ are always unescaped, even if
     `entities' is provided.

 -- Function: xml.sax.saxutils.quoteattr (data, entities={})

     Similar to *note escape(): 23d7, but also prepares `data' to be
     used as an attribute value.  The return value is a quoted version
     of `data' with any additional required replacements.  *note
     quoteattr(): 23d9. will select a quote character based on the
     content of `data', attempting to avoid encoding any quote
     characters in the string.  If both single- and double-quote
     characters are already in `data', the double-quote characters will
     be encoded and `data' will be wrapped in double-quotes.  The
     resulting string can be used directly as an attribute value:

          >>> print("<element attr=%s>" % quoteattr("ab ' cd \" ef"))
          <element attr="ab ' cd &quot; ef">

     This function is useful when generating attribute values for HTML
     or any SGML using the reference concrete syntax.

 -- Class: xml.sax.saxutils.XMLGenerator (out=None,
          encoding='iso-8859-1', short_empty_elements=False)

     This class implements the *note ContentHandler: 238f. interface by
     writing SAX events back into an XML document.  In other words,
     using an *note XMLGenerator: 23da. as the content handler will
     reproduce the original document being parsed.  `out' should be a
     file-like object which will default to `sys.stdout'.  `encoding' is
     the encoding of the output stream which defaults to ‘'iso-8859-1'’.
     `short_empty_elements' controls the formatting of elements that
     contain no content: if `False' (the default) they are emitted as a
     pair of start/end tags, if set to `True' they are emitted as a
     single self-closed tag.

     New in version 3.2: The `short_empty_elements' parameter.

 -- Class: xml.sax.saxutils.XMLFilterBase (base)

     This class is designed to sit between an *note XMLReader: 2393. and
     the client application’s event handlers.  By default, it does
     nothing but pass requests up to the reader and events on to the
     handlers unmodified, but subclasses can override specific methods
     to modify the event stream or the configuration requests as they
     pass through.

 -- Function: xml.sax.saxutils.prepare_input_source (source, base='')

     This function takes an input source and an optional base URL and
     returns a fully resolved *note InputSource: 366. object ready for
     reading.  The input source can be given as a string, a file-like
     object, or an *note InputSource: 366. object; parsers will use this
     function to implement the polymorphic `source' argument to their
     ‘parse()’ method.


File: python.info,  Node: xml sax xmlreader --- Interface for XML parsers,  Next: xml parsers expat --- Fast XML parsing using Expat,  Prev: xml sax saxutils --- SAX Utilities,  Up: Structured Markup Processing Tools

5.20.12 ‘xml.sax.xmlreader’ — Interface for XML parsers
-------------------------------------------------------

SAX parsers implement the *note XMLReader: 2393. interface.  They are
implemented in a Python module, which must provide a function
‘create_parser()’.  This function is invoked by *note
xml.sax.make_parser(): 239c. with no arguments to create a new parser
object.

 -- Class: xml.sax.xmlreader.XMLReader

     Base class which can be inherited by SAX parsers.

 -- Class: xml.sax.xmlreader.IncrementalParser

     In some cases, it is desirable not to parse an input source at
     once, but to feed chunks of the document as they get available.
     Note that the reader will normally not read the entire file, but
     read it in chunks as well; still ‘parse()’ won’t return until the
     entire document is processed.  So these interfaces should be used
     if the blocking behaviour of ‘parse()’ is not desirable.

     When the parser is instantiated it is ready to begin accepting data
     from the feed method immediately.  After parsing has been finished
     with a call to close the reset method must be called to make the
     parser ready to accept new data, either from feed or using the
     parse method.

     Note that these methods must `not' be called during parsing, that
     is, after parse has been called and before it returns.

     By default, the class also implements the parse method of the
     XMLReader interface using the feed, close and reset methods of the
     IncrementalParser interface as a convenience to SAX 2.0 driver
     writers.

 -- Class: xml.sax.xmlreader.Locator

     Interface for associating a SAX event with a document location.  A
     locator object will return valid results only during calls to
     DocumentHandler methods; at any other time, the results are
     unpredictable.  If information is not available, methods may return
     ‘None’.

 -- Class: xml.sax.xmlreader.InputSource (system_id=None)

     Encapsulation of the information needed by the *note XMLReader:
     2393. to read entities.

     This class may include information about the public identifier,
     system identifier, byte stream (possibly with character encoding
     information) and/or the character stream of an entity.

     Applications will create objects of this class for use in the *note
     XMLReader.parse(): 23e0. method and for returning from
     EntityResolver.resolveEntity.

     An *note InputSource: 366. belongs to the application, the *note
     XMLReader: 2393. is not allowed to modify *note InputSource: 366.
     objects passed to it from the application, although it may make
     copies and modify those.

 -- Class: xml.sax.xmlreader.AttributesImpl (attrs)

     This is an implementation of the ‘Attributes’ interface (see
     section *note The Attributes Interface: 23c1.).  This is a
     dictionary-like object which represents the element attributes in a
     ‘startElement()’ call.  In addition to the most useful dictionary
     operations, it supports a number of other methods as described by
     the interface.  Objects of this class should be instantiated by
     readers; `attrs' must be a dictionary-like object containing a
     mapping from attribute names to attribute values.

 -- Class: xml.sax.xmlreader.AttributesNSImpl (attrs, qnames)

     Namespace-aware variant of *note AttributesImpl: 23e1, which will
     be passed to ‘startElementNS()’.  It is derived from *note
     AttributesImpl: 23e1, but understands attribute names as two-tuples
     of `namespaceURI' and `localname'.  In addition, it provides a
     number of methods expecting qualified names as they appear in the
     original document.  This class implements the ‘AttributesNS’
     interface (see section *note The AttributesNS Interface: 23c3.).

* Menu:

* XMLReader Objects:: 
* IncrementalParser Objects:: 
* Locator Objects:: 
* InputSource Objects:: 
* The Attributes Interface:: 
* The AttributesNS Interface:: 


File: python.info,  Node: XMLReader Objects,  Next: IncrementalParser Objects,  Up: xml sax xmlreader --- Interface for XML parsers

5.20.12.1 XMLReader Objects
...........................

The *note XMLReader: 2393. interface supports the following methods:

 -- Method: XMLReader.parse (source)

     Process an input source, producing SAX events.  The `source' object
     can be a system identifier (a string identifying the input source –
     typically a file name or a URL), a file-like object, or an *note
     InputSource: 366. object.  When *note parse(): 23e0. returns, the
     input is completely processed, and the parser object can be
     discarded or reset.

     Changed in version 3.5: Added support of character streams.

 -- Method: XMLReader.getContentHandler ()

     Return the current *note ContentHandler: 238f.

 -- Method: XMLReader.setContentHandler (handler)

     Set the current *note ContentHandler: 238f.  If no *note
     ContentHandler: 238f. is set, content events will be discarded.

 -- Method: XMLReader.getDTDHandler ()

     Return the current *note DTDHandler: 23aa.

 -- Method: XMLReader.setDTDHandler (handler)

     Set the current *note DTDHandler: 23aa.  If no *note DTDHandler:
     23aa. is set, DTD events will be discarded.

 -- Method: XMLReader.getEntityResolver ()

     Return the current *note EntityResolver: 23ab.

 -- Method: XMLReader.setEntityResolver (handler)

     Set the current *note EntityResolver: 23ab.  If no *note
     EntityResolver: 23ab. is set, attempts to resolve an external
     entity will result in opening the system identifier for the entity,
     and fail if it is not available.

 -- Method: XMLReader.getErrorHandler ()

     Return the current *note ErrorHandler: 239e.

 -- Method: XMLReader.setErrorHandler (handler)

     Set the current error handler.  If no *note ErrorHandler: 239e. is
     set, errors will be raised as exceptions, and warnings will be
     printed.

 -- Method: XMLReader.setLocale (locale)

     Allow an application to set the locale for errors and warnings.

     SAX parsers are not required to provide localization for errors and
     warnings; if they cannot support the requested locale, however,
     they must raise a SAX exception.  Applications may request a locale
     change in the middle of a parse.

 -- Method: XMLReader.getFeature (featurename)

     Return the current setting for feature `featurename'.  If the
     feature is not recognized, ‘SAXNotRecognizedException’ is raised.
     The well-known featurenames are listed in the module *note
     xml.sax.handler: 139.

 -- Method: XMLReader.setFeature (featurename, value)

     Set the `featurename' to `value'.  If the feature is not
     recognized, ‘SAXNotRecognizedException’ is raised.  If the feature
     or its setting is not supported by the parser,
     `SAXNotSupportedException' is raised.

 -- Method: XMLReader.getProperty (propertyname)

     Return the current setting for property `propertyname'.  If the
     property is not recognized, a ‘SAXNotRecognizedException’ is
     raised.  The well-known propertynames are listed in the module
     *note xml.sax.handler: 139.

 -- Method: XMLReader.setProperty (propertyname, value)

     Set the `propertyname' to `value'.  If the property is not
     recognized, ‘SAXNotRecognizedException’ is raised.  If the property
     or its setting is not supported by the parser,
     `SAXNotSupportedException' is raised.


File: python.info,  Node: IncrementalParser Objects,  Next: Locator Objects,  Prev: XMLReader Objects,  Up: xml sax xmlreader --- Interface for XML parsers

5.20.12.2 IncrementalParser Objects
...................................

Instances of *note IncrementalParser: 23df. offer the following
additional methods:

 -- Method: IncrementalParser.feed (data)

     Process a chunk of `data'.

 -- Method: IncrementalParser.close ()

     Assume the end of the document.  That will check well-formedness
     conditions that can be checked only at the end, invoke handlers,
     and may clean up resources allocated during parsing.

 -- Method: IncrementalParser.reset ()

     This method is called after close has been called to reset the
     parser so that it is ready to parse new documents.  The results of
     calling parse or feed after close without calling reset are
     undefined.


File: python.info,  Node: Locator Objects,  Next: InputSource Objects,  Prev: IncrementalParser Objects,  Up: xml sax xmlreader --- Interface for XML parsers

5.20.12.3 Locator Objects
.........................

Instances of *note Locator: 23a0. provide these methods:

 -- Method: Locator.getColumnNumber ()

     Return the column number where the current event ends.

 -- Method: Locator.getLineNumber ()

     Return the line number where the current event ends.

 -- Method: Locator.getPublicId ()

     Return the public identifier for the current event.

 -- Method: Locator.getSystemId ()

     Return the system identifier for the current event.


File: python.info,  Node: InputSource Objects,  Next: The Attributes Interface,  Prev: Locator Objects,  Up: xml sax xmlreader --- Interface for XML parsers

5.20.12.4 InputSource Objects
.............................

 -- Method: InputSource.setPublicId (id)

     Sets the public identifier of this *note InputSource: 366.

 -- Method: InputSource.getPublicId ()

     Returns the public identifier of this *note InputSource: 366.

 -- Method: InputSource.setSystemId (id)

     Sets the system identifier of this *note InputSource: 366.

 -- Method: InputSource.getSystemId ()

     Returns the system identifier of this *note InputSource: 366.

 -- Method: InputSource.setEncoding (encoding)

     Sets the character encoding of this *note InputSource: 366.

     The encoding must be a string acceptable for an XML encoding
     declaration (see section 4.3.3 of the XML recommendation).

     The encoding attribute of the *note InputSource: 366. is ignored if
     the *note InputSource: 366. also contains a character stream.

 -- Method: InputSource.getEncoding ()

     Get the character encoding of this InputSource.

 -- Method: InputSource.setByteStream (bytefile)

     Set the byte stream (a *note binary file: 164a.) for this input
     source.

     The SAX parser will ignore this if there is also a character stream
     specified, but it will use a byte stream in preference to opening a
     URI connection itself.

     If the application knows the character encoding of the byte stream,
     it should set it with the setEncoding method.

 -- Method: InputSource.getByteStream ()

     Get the byte stream for this input source.

     The getEncoding method will return the character encoding for this
     byte stream, or None if unknown.

 -- Method: InputSource.setCharacterStream (charfile)

     Set the character stream (a *note text file: c62.) for this input
     source.

     If there is a character stream specified, the SAX parser will
     ignore any byte stream and will not attempt to open a URI
     connection to the system identifier.

 -- Method: InputSource.getCharacterStream ()

     Get the character stream for this input source.


File: python.info,  Node: The Attributes Interface,  Next: The AttributesNS Interface,  Prev: InputSource Objects,  Up: xml sax xmlreader --- Interface for XML parsers

5.20.12.5 The ‘Attributes’ Interface
....................................

‘Attributes’ objects implement a portion of the *note mapping protocol:
77c, including the methods ‘copy()’, ‘get()’, *note __contains__(): 99c,
‘items()’, ‘keys()’, and ‘values()’.  The following methods are also
provided:

 -- Method: Attributes.getLength ()

     Return the number of attributes.

 -- Method: Attributes.getNames ()

     Return the names of the attributes.

 -- Method: Attributes.getType (name)

     Returns the type of the attribute `name', which is normally
     ‘'CDATA'’.

 -- Method: Attributes.getValue (name)

     Return the value of attribute `name'.


File: python.info,  Node: The AttributesNS Interface,  Prev: The Attributes Interface,  Up: xml sax xmlreader --- Interface for XML parsers

5.20.12.6 The ‘AttributesNS’ Interface
......................................

This interface is a subtype of the ‘Attributes’ interface (see section
*note The Attributes Interface: 23c1.).  All methods supported by that
interface are also available on ‘AttributesNS’ objects.

The following methods are also available:

 -- Method: AttributesNS.getValueByQName (name)

     Return the value for a qualified name.

 -- Method: AttributesNS.getNameByQName (name)

     Return the ‘(namespace, localname)’ pair for a qualified `name'.

 -- Method: AttributesNS.getQNameByName (name)

     Return the qualified name for a ‘(namespace, localname)’ pair.

 -- Method: AttributesNS.getQNames ()

     Return the qualified names of all attributes.


File: python.info,  Node: xml parsers expat --- Fast XML parsing using Expat,  Prev: xml sax xmlreader --- Interface for XML parsers,  Up: Structured Markup Processing Tools

5.20.13 ‘xml.parsers.expat’ — Fast XML parsing using Expat
----------------------------------------------------------

     Warning: The ‘pyexpat’ module is not secure against maliciously
     constructed data.  If you need to parse untrusted or
     unauthenticated data see *note XML vulnerabilities: 22a9.

The *note xml.parsers.expat: 135. module is a Python interface to the
Expat non-validating XML parser.  The module provides a single extension
type, ‘xmlparser’, that represents the current state of an XML parser.
After an ‘xmlparser’ object has been created, various attributes of the
object can be set to handler functions.  When an XML document is then
fed to the parser, the handler functions are called for the character
data and markup in the XML document.

This module uses the ‘pyexpat’ module to provide access to the Expat
parser.  Direct use of the ‘pyexpat’ module is deprecated.

This module provides one exception and one type object:

 -- Exception: xml.parsers.expat.ExpatError

     The exception raised when Expat reports an error.  See section
     *note ExpatError Exceptions: 2415. for more information on
     interpreting Expat errors.

 -- Exception: xml.parsers.expat.error

     Alias for *note ExpatError: 86e.

 -- Data: xml.parsers.expat.XMLParserType

     The type of the return values from the *note ParserCreate(): 2418.
     function.

The *note xml.parsers.expat: 135. module contains two functions:

 -- Function: xml.parsers.expat.ErrorString (errno)

     Returns an explanatory string for a given error number `errno'.

 -- Function: xml.parsers.expat.ParserCreate (encoding=None,
          namespace_separator=None)

     Creates and returns a new ‘xmlparser’ object.  `encoding', if
     specified, must be a string naming the encoding used by the XML
     data.  Expat doesn’t support as many encodings as Python does, and
     its repertoire of encodings can’t be extended; it supports UTF-8,
     UTF-16, ISO-8859-1 (Latin1), and ASCII. If `encoding' (1) is given
     it will override the implicit or explicit encoding of the document.

     Expat can optionally do XML namespace processing for you, enabled
     by providing a value for `namespace_separator'.  The value must be
     a one-character string; a *note ValueError: 19c. will be raised if
     the string has an illegal length (‘None’ is considered the same as
     omission).  When namespace processing is enabled, element type
     names and attribute names that belong to a namespace will be
     expanded.  The element name passed to the element handlers
     ‘StartElementHandler’ and ‘EndElementHandler’ will be the
     concatenation of the namespace URI, the namespace separator
     character, and the local part of the name.  If the namespace
     separator is a zero byte (‘chr(0)’) then the namespace URI and the
     local part will be concatenated without any separator.

     For example, if `namespace_separator' is set to a space character
     (‘' '’) and the following document is parsed:

          <?xml version="1.0"?>
          <root xmlns    = "http://default-namespace.org/"
                xmlns:py = "http://www.python.org/ns/">
            <py:elem1 />
            <elem2 xmlns="" />
          </root>

     ‘StartElementHandler’ will receive the following strings for each
     element:

          http://default-namespace.org/ root
          http://www.python.org/ns/ elem1
          elem2

     Due to limitations in the ‘Expat’ library used by ‘pyexpat’, the
     ‘xmlparser’ instance returned can only be used to parse a single
     XML document.  Call ‘ParserCreate’ for each document to provide
     unique parser instances.

See also
........

The Expat XML Parser(2)

     Home page of the Expat project.

* Menu:

* XMLParser Objects: XMLParser Objects<2>. 
* ExpatError Exceptions:: 
* Example: Example<10>. 
* Content Model Descriptions:: 
* Expat error constants:: 

   ---------- Footnotes ----------

   (1) The encoding string included in XML output should conform to the
appropriate standards.  For example, "UTF-8" is valid, but "UTF8" is
not.  See
‘http://www.w3.org/TR/2006/REC-xml11-20060816/#NT-EncodingDecl’ and
‘http://www.iana.org/assignments/character-sets/character-sets.xhtml’.

   (2) http://www.libexpat.org/


File: python.info,  Node: XMLParser Objects<2>,  Next: ExpatError Exceptions,  Up: xml parsers expat --- Fast XML parsing using Expat

5.20.13.1 XMLParser Objects
...........................

‘xmlparser’ objects have the following methods:

 -- Method: xmlparser.Parse (data[, isfinal])

     Parses the contents of the string `data', calling the appropriate
     handler functions to process the parsed data.  `isfinal' must be
     true on the final call to this method; it allows the parsing of a
     single file in fragments, not the submission of multiple files.
     `data' can be the empty string at any time.

 -- Method: xmlparser.ParseFile (file)

     Parse XML data reading from the object `file'.  `file' only needs
     to provide the ‘read(nbytes)’ method, returning the empty string
     when there’s no more data.

 -- Method: xmlparser.SetBase (base)

     Sets the base to be used for resolving relative URIs in system
     identifiers in declarations.  Resolving relative identifiers is
     left to the application: this value will be passed through as the
     `base' argument to the *note ExternalEntityRefHandler(): 241f,
     *note NotationDeclHandler(): 2420, and *note
     UnparsedEntityDeclHandler(): 2421. functions.

 -- Method: xmlparser.GetBase ()

     Returns a string containing the base set by a previous call to
     *note SetBase(): 241e, or ‘None’ if *note SetBase(): 241e. hasn’t
     been called.

 -- Method: xmlparser.GetInputContext ()

     Returns the input data that generated the current event as a
     string.  The data is in the encoding of the entity which contains
     the text.  When called while an event handler is not active, the
     return value is ‘None’.

 -- Method: xmlparser.ExternalEntityParserCreate (context[, encoding])

     Create a "child" parser which can be used to parse an external
     parsed entity referred to by content parsed by the parent parser.
     The `context' parameter should be the string passed to the *note
     ExternalEntityRefHandler(): 241f. handler function, described
     below.  The child parser is created with the *note
     ordered_attributes: 2425. and *note specified_attributes: 2426. set
     to the values of this parser.

 -- Method: xmlparser.SetParamEntityParsing (flag)

     Control parsing of parameter entities (including the external DTD
     subset).  Possible `flag' values are
     ‘XML_PARAM_ENTITY_PARSING_NEVER’,
     ‘XML_PARAM_ENTITY_PARSING_UNLESS_STANDALONE’ and
     ‘XML_PARAM_ENTITY_PARSING_ALWAYS’.  Return true if setting the flag
     was successful.

 -- Method: xmlparser.UseForeignDTD ([flag])

     Calling this with a true value for `flag' (the default) will cause
     Expat to call the *note ExternalEntityRefHandler: 241f. with *note
     None: 19d. for all arguments to allow an alternate DTD to be
     loaded.  If the document does not contain a document type
     declaration, the *note ExternalEntityRefHandler: 241f. will still
     be called, but the *note StartDoctypeDeclHandler: 2429. and *note
     EndDoctypeDeclHandler: 242a. will not be called.

     Passing a false value for `flag' will cancel a previous call that
     passed a true value, but otherwise has no effect.

     This method can only be called before the *note Parse(): 241c. or
     *note ParseFile(): 241d. methods are called; calling it after
     either of those have been called causes *note ExpatError: 86e. to
     be raised with the *note code: 1b. attribute set to
     ‘errors.codes[errors.XML_ERROR_CANT_CHANGE_FEATURE_ONCE_PARSING]’.

‘xmlparser’ objects have the following attributes:

 -- Attribute: xmlparser.buffer_size

     The size of the buffer used when *note buffer_text: 242c. is true.
     A new buffer size can be set by assigning a new integer value to
     this attribute.  When the size is changed, the buffer will be
     flushed.

 -- Attribute: xmlparser.buffer_text

     Setting this to true causes the ‘xmlparser’ object to buffer
     textual content returned by Expat to avoid multiple calls to the
     *note CharacterDataHandler(): 242d. callback whenever possible.
     This can improve performance substantially since Expat normally
     breaks character data into chunks at every line ending.  This
     attribute is false by default, and may be changed at any time.

 -- Attribute: xmlparser.buffer_used

     If *note buffer_text: 242c. is enabled, the number of bytes stored
     in the buffer.  These bytes represent UTF-8 encoded text.  This
     attribute has no meaningful interpretation when *note buffer_text:
     242c. is false.

 -- Attribute: xmlparser.ordered_attributes

     Setting this attribute to a non-zero integer causes the attributes
     to be reported as a list rather than a dictionary.  The attributes
     are presented in the order found in the document text.  For each
     attribute, two list entries are presented: the attribute name and
     the attribute value.  (Older versions of this module also used this
     format.)  By default, this attribute is false; it may be changed at
     any time.

 -- Attribute: xmlparser.specified_attributes

     If set to a non-zero integer, the parser will report only those
     attributes which were specified in the document instance and not
     those which were derived from attribute declarations.  Applications
     which set this need to be especially careful to use what additional
     information is available from the declarations as needed to comply
     with the standards for the behavior of XML processors.  By default,
     this attribute is false; it may be changed at any time.

The following attributes contain values relating to the most recent
error encountered by an ‘xmlparser’ object, and will only have correct
values once a call to ‘Parse()’ or ‘ParseFile()’ has raised a *note
xml.parsers.expat.ExpatError: 86e. exception.

 -- Attribute: xmlparser.ErrorByteIndex

     Byte index at which an error occurred.

 -- Attribute: xmlparser.ErrorCode

     Numeric code specifying the problem.  This value can be passed to
     the *note ErrorString(): 2419. function, or compared to one of the
     constants defined in the ‘errors’ object.

 -- Attribute: xmlparser.ErrorColumnNumber

     Column number at which an error occurred.

 -- Attribute: xmlparser.ErrorLineNumber

     Line number at which an error occurred.

The following attributes contain values relating to the current parse
location in an ‘xmlparser’ object.  During a callback reporting a parse
event they indicate the location of the first of the sequence of
characters that generated the event.  When called outside of a callback,
the position indicated will be just past the last parse event
(regardless of whether there was an associated callback).

 -- Attribute: xmlparser.CurrentByteIndex

     Current byte index in the parser input.

 -- Attribute: xmlparser.CurrentColumnNumber

     Current column number in the parser input.

 -- Attribute: xmlparser.CurrentLineNumber

     Current line number in the parser input.

Here is the list of handlers that can be set.  To set a handler on an
‘xmlparser’ object `o', use ‘o.handlername = func’.  `handlername' must
be taken from the following list, and `func' must be a callable object
accepting the correct number of arguments.  The arguments are all
strings, unless otherwise stated.

 -- Method: xmlparser.XmlDeclHandler (version, encoding, standalone)

     Called when the XML declaration is parsed.  The XML declaration is
     the (optional) declaration of the applicable version of the XML
     recommendation, the encoding of the document text, and an optional
     "standalone" declaration.  `version' and `encoding' will be
     strings, and `standalone' will be ‘1’ if the document is declared
     standalone, ‘0’ if it is declared not to be standalone, or ‘-1’ if
     the standalone clause was omitted.  This is only available with
     Expat version 1.95.0 or newer.

 -- Method: xmlparser.StartDoctypeDeclHandler (doctypeName, systemId,
          publicId, has_internal_subset)

     Called when Expat begins parsing the document type declaration
     (‘<!DOCTYPE ...’).  The `doctypeName' is provided exactly as
     presented.  The `systemId' and `publicId' parameters give the
     system and public identifiers if specified, or ‘None’ if omitted.
     `has_internal_subset' will be true if the document contains and
     internal document declaration subset.  This requires Expat version
     1.2 or newer.

 -- Method: xmlparser.EndDoctypeDeclHandler ()

     Called when Expat is done parsing the document type declaration.
     This requires Expat version 1.2 or newer.

 -- Method: xmlparser.ElementDeclHandler (name, model)

     Called once for each element type declaration.  `name' is the name
     of the element type, and `model' is a representation of the content
     model.

 -- Method: xmlparser.AttlistDeclHandler (elname, attname, type,
          default, required)

     Called for each declared attribute for an element type.  If an
     attribute list declaration declares three attributes, this handler
     is called three times, once for each attribute.  `elname' is the
     name of the element to which the declaration applies and `attname'
     is the name of the attribute declared.  The attribute type is a
     string passed as `type'; the possible values are ‘'CDATA'’, ‘'ID'’,
     ‘'IDREF'’, ...  `default' gives the default value for the attribute
     used when the attribute is not specified by the document instance,
     or ‘None’ if there is no default value (‘#IMPLIED’ values).  If the
     attribute is required to be given in the document instance,
     `required' will be true.  This requires Expat version 1.95.0 or
     newer.

 -- Method: xmlparser.StartElementHandler (name, attributes)

     Called for the start of every element.  `name' is a string
     containing the element name, and `attributes' is the element
     attributes.  If *note ordered_attributes: 2425. is true, this is a
     list (see *note ordered_attributes: 2425. for a full description).
     Otherwise it’s a dictionary mapping names to values.

 -- Method: xmlparser.EndElementHandler (name)

     Called for the end of every element.

 -- Method: xmlparser.ProcessingInstructionHandler (target, data)

     Called for every processing instruction.

 -- Method: xmlparser.CharacterDataHandler (data)

     Called for character data.  This will be called for normal
     character data, CDATA marked content, and ignorable whitespace.
     Applications which must distinguish these cases can use the *note
     StartCdataSectionHandler: 243c, *note EndCdataSectionHandler: 243d,
     and *note ElementDeclHandler: 2437. callbacks to collect the
     required information.

 -- Method: xmlparser.UnparsedEntityDeclHandler (entityName, base,
          systemId, publicId, notationName)

     Called for unparsed (NDATA) entity declarations.  This is only
     present for version 1.2 of the Expat library; for more recent
     versions, use *note EntityDeclHandler: 243e. instead.  (The
     underlying function in the Expat library has been declared
     obsolete.)

 -- Method: xmlparser.EntityDeclHandler (entityName,
          is_parameter_entity, value, base, systemId, publicId,
          notationName)

     Called for all entity declarations.  For parameter and internal
     entities, `value' will be a string giving the declared contents of
     the entity; this will be ‘None’ for external entities.  The
     `notationName' parameter will be ‘None’ for parsed entities, and
     the name of the notation for unparsed entities.
     `is_parameter_entity' will be true if the entity is a parameter
     entity or false for general entities (most applications only need
     to be concerned with general entities).  This is only available
     starting with version 1.95.0 of the Expat library.

 -- Method: xmlparser.NotationDeclHandler (notationName, base, systemId,
          publicId)

     Called for notation declarations.  `notationName', `base', and
     `systemId', and `publicId' are strings if given.  If the public
     identifier is omitted, `publicId' will be ‘None’.

 -- Method: xmlparser.StartNamespaceDeclHandler (prefix, uri)

     Called when an element contains a namespace declaration.  Namespace
     declarations are processed before the *note StartElementHandler:
     2439. is called for the element on which declarations are placed.

 -- Method: xmlparser.EndNamespaceDeclHandler (prefix)

     Called when the closing tag is reached for an element that
     contained a namespace declaration.  This is called once for each
     namespace declaration on the element in the reverse of the order
     for which the *note StartNamespaceDeclHandler: 243f. was called to
     indicate the start of each namespace declaration’s scope.  Calls to
     this handler are made after the corresponding *note
     EndElementHandler: 243a. for the end of the element.

 -- Method: xmlparser.CommentHandler (data)

     Called for comments.  `data' is the text of the comment, excluding
     the leading ‘'<!-’‘-'’ and trailing ‘'-’‘->'’.

 -- Method: xmlparser.StartCdataSectionHandler ()

     Called at the start of a CDATA section.  This and *note
     EndCdataSectionHandler: 243d. are needed to be able to identify the
     syntactical start and end for CDATA sections.

 -- Method: xmlparser.EndCdataSectionHandler ()

     Called at the end of a CDATA section.

 -- Method: xmlparser.DefaultHandler (data)

     Called for any characters in the XML document for which no
     applicable handler has been specified.  This means characters that
     are part of a construct which could be reported, but for which no
     handler has been supplied.

 -- Method: xmlparser.DefaultHandlerExpand (data)

     This is the same as the *note DefaultHandler(): 2442, but doesn’t
     inhibit expansion of internal entities.  The entity reference will
     not be passed to the default handler.

 -- Method: xmlparser.NotStandaloneHandler ()

     Called if the XML document hasn’t been declared as being a
     standalone document.  This happens when there is an external subset
     or a reference to a parameter entity, but the XML declaration does
     not set standalone to ‘yes’ in an XML declaration.  If this handler
     returns ‘0’, then the parser will raise an
     ‘XML_ERROR_NOT_STANDALONE’ error.  If this handler is not set, no
     exception is raised by the parser for this condition.

 -- Method: xmlparser.ExternalEntityRefHandler (context, base, systemId,
          publicId)

     Called for references to external entities.  `base' is the current
     base, as set by a previous call to *note SetBase(): 241e.  The
     public and system identifiers, `systemId' and `publicId', are
     strings if given; if the public identifier is not given, `publicId'
     will be ‘None’.  The `context' value is opaque and should only be
     used as described below.

     For external entities to be parsed, this handler must be
     implemented.  It is responsible for creating the sub-parser using
     ‘ExternalEntityParserCreate(context)’, initializing it with the
     appropriate callbacks, and parsing the entity.  This handler should
     return an integer; if it returns ‘0’, the parser will raise an
     ‘XML_ERROR_EXTERNAL_ENTITY_HANDLING’ error, otherwise parsing will
     continue.

     If this handler is not provided, external entities are reported by
     the *note DefaultHandler: 2442. callback, if provided.


File: python.info,  Node: ExpatError Exceptions,  Next: Example<10>,  Prev: XMLParser Objects<2>,  Up: xml parsers expat --- Fast XML parsing using Expat

5.20.13.2 ExpatError Exceptions
...............................

*note ExpatError: 86e. exceptions have a number of interesting
attributes:

 -- Attribute: ExpatError.code

     Expat’s internal error number for the specific error.  The *note
     errors.messages: 2447. dictionary maps these error numbers to
     Expat’s error messages.  For example:

          from xml.parsers.expat import ParserCreate, ExpatError, errors

          p = ParserCreate()
          try:
              p.Parse(some_xml_document)
          except ExpatError as err:
              print("Error:", errors.messages[err.code])

     The *note errors: 136. module also provides error message constants
     and a dictionary *note codes: 2448. mapping these messages back to
     the error codes, see below.

 -- Attribute: ExpatError.lineno

     Line number on which the error was detected.  The first line is
     numbered ‘1’.

 -- Attribute: ExpatError.offset

     Character offset into the line where the error occurred.  The first
     column is numbered ‘0’.


File: python.info,  Node: Example<10>,  Next: Content Model Descriptions,  Prev: ExpatError Exceptions,  Up: xml parsers expat --- Fast XML parsing using Expat

5.20.13.3 Example
.................

The following program defines three handlers that just print out their
arguments.

     import xml.parsers.expat

     # 3 handler functions
     def start_element(name, attrs):
         print('Start element:', name, attrs)
     def end_element(name):
         print('End element:', name)
     def char_data(data):
         print('Character data:', repr(data))

     p = xml.parsers.expat.ParserCreate()

     p.StartElementHandler = start_element
     p.EndElementHandler = end_element
     p.CharacterDataHandler = char_data

     p.Parse("""<?xml version="1.0"?>
     <parent id="top"><child1 name="paul">Text goes here</child1>
     <child2 name="fred">More text</child2>
     </parent>""", 1)

The output from this program is:

     Start element: parent {'id': 'top'}
     Start element: child1 {'name': 'paul'}
     Character data: 'Text goes here'
     End element: child1
     Character data: '\n'
     Start element: child2 {'name': 'fred'}
     Character data: 'More text'
     End element: child2
     Character data: '\n'
     End element: parent


File: python.info,  Node: Content Model Descriptions,  Next: Expat error constants,  Prev: Example<10>,  Up: xml parsers expat --- Fast XML parsing using Expat

5.20.13.4 Content Model Descriptions
....................................

Content models are described using nested tuples.  Each tuple contains
four values: the type, the quantifier, the name, and a tuple of
children.  Children are simply additional content model descriptions.

The values of the first two fields are constants defined in the *note
xml.parsers.expat.model: 137. module.  These constants can be collected
in two groups: the model type group and the quantifier group.

The constants in the model type group are:

 -- Data: xml.parsers.expat.model.XML_CTYPE_ANY

     The element named by the model name was declared to have a content
     model of ‘ANY’.

 -- Data: xml.parsers.expat.model.XML_CTYPE_CHOICE

     The named element allows a choice from a number of options; this is
     used for content models such as ‘(A | B | C)’.

 -- Data: xml.parsers.expat.model.XML_CTYPE_EMPTY

     Elements which are declared to be ‘EMPTY’ have this model type.

 -- Data: xml.parsers.expat.model.XML_CTYPE_MIXED

 -- Data: xml.parsers.expat.model.XML_CTYPE_NAME

 -- Data: xml.parsers.expat.model.XML_CTYPE_SEQ

     Models which represent a series of models which follow one after
     the other are indicated with this model type.  This is used for
     models such as ‘(A, B, C)’.

The constants in the quantifier group are:

 -- Data: xml.parsers.expat.model.XML_CQUANT_NONE

     No modifier is given, so it can appear exactly once, as for ‘A’.

 -- Data: xml.parsers.expat.model.XML_CQUANT_OPT

     The model is optional: it can appear once or not at all, as for
     ‘A?’.

 -- Data: xml.parsers.expat.model.XML_CQUANT_PLUS

     The model must occur one or more times (like ‘A+’).

 -- Data: xml.parsers.expat.model.XML_CQUANT_REP

     The model must occur zero or more times, as for ‘A*’.


File: python.info,  Node: Expat error constants,  Prev: Content Model Descriptions,  Up: xml parsers expat --- Fast XML parsing using Expat

5.20.13.5 Expat error constants
...............................

The following constants are provided in the *note
xml.parsers.expat.errors: 136. module.  These constants are useful in
interpreting some of the attributes of the ‘ExpatError’ exception
objects raised when an error has occurred.  Since for backwards
compatibility reasons, the constants’ value is the error `message' and
not the numeric error `code', you do this by comparing its *note code:
1b. attribute with ‘errors.codes[errors.XML_ERROR_`CONSTANT_NAME']’.

The ‘errors’ module has the following attributes:

 -- Data: xml.parsers.expat.errors.codes

     A dictionary mapping numeric error codes to their string
     descriptions.

     New in version 3.2.

 -- Data: xml.parsers.expat.errors.messages

     A dictionary mapping string descriptions to their error codes.

     New in version 3.2.

 -- Data: xml.parsers.expat.errors.XML_ERROR_ASYNC_ENTITY

 -- Data:
          xml.parsers.expat.errors.XML_ERROR_ATTRIBUTE_EXTERNAL_ENTITY_REF

     An entity reference in an attribute value referred to an external
     entity instead of an internal entity.

 -- Data: xml.parsers.expat.errors.XML_ERROR_BAD_CHAR_REF

     A character reference referred to a character which is illegal in
     XML (for example, character ‘0’, or ’‘&#0;’’).

 -- Data: xml.parsers.expat.errors.XML_ERROR_BINARY_ENTITY_REF

     An entity reference referred to an entity which was declared with a
     notation, so cannot be parsed.

 -- Data: xml.parsers.expat.errors.XML_ERROR_DUPLICATE_ATTRIBUTE

     An attribute was used more than once in a start tag.

 -- Data: xml.parsers.expat.errors.XML_ERROR_INCORRECT_ENCODING

 -- Data: xml.parsers.expat.errors.XML_ERROR_INVALID_TOKEN

     Raised when an input byte could not properly be assigned to a
     character; for example, a NUL byte (value ‘0’) in a UTF-8 input
     stream.

 -- Data: xml.parsers.expat.errors.XML_ERROR_JUNK_AFTER_DOC_ELEMENT

     Something other than whitespace occurred after the document
     element.

 -- Data: xml.parsers.expat.errors.XML_ERROR_MISPLACED_XML_PI

     An XML declaration was found somewhere other than the start of the
     input data.

 -- Data: xml.parsers.expat.errors.XML_ERROR_NO_ELEMENTS

     The document contains no elements (XML requires all documents to
     contain exactly one top-level element)..

 -- Data: xml.parsers.expat.errors.XML_ERROR_NO_MEMORY

     Expat was not able to allocate memory internally.

 -- Data: xml.parsers.expat.errors.XML_ERROR_PARAM_ENTITY_REF

     A parameter entity reference was found where it was not allowed.

 -- Data: xml.parsers.expat.errors.XML_ERROR_PARTIAL_CHAR

     An incomplete character was found in the input.

 -- Data: xml.parsers.expat.errors.XML_ERROR_RECURSIVE_ENTITY_REF

     An entity reference contained another reference to the same entity;
     possibly via a different name, and possibly indirectly.

 -- Data: xml.parsers.expat.errors.XML_ERROR_SYNTAX

     Some unspecified syntax error was encountered.

 -- Data: xml.parsers.expat.errors.XML_ERROR_TAG_MISMATCH

     An end tag did not match the innermost open start tag.

 -- Data: xml.parsers.expat.errors.XML_ERROR_UNCLOSED_TOKEN

     Some token (such as a start tag) was not closed before the end of
     the stream or the next token was encountered.

 -- Data: xml.parsers.expat.errors.XML_ERROR_UNDEFINED_ENTITY

     A reference was made to an entity which was not defined.

 -- Data: xml.parsers.expat.errors.XML_ERROR_UNKNOWN_ENCODING

     The document encoding is not supported by Expat.

 -- Data: xml.parsers.expat.errors.XML_ERROR_UNCLOSED_CDATA_SECTION

     A CDATA marked section was not closed.

 -- Data: xml.parsers.expat.errors.XML_ERROR_EXTERNAL_ENTITY_HANDLING

 -- Data: xml.parsers.expat.errors.XML_ERROR_NOT_STANDALONE

     The parser determined that the document was not "standalone" though
     it declared itself to be in the XML declaration, and the
     ‘NotStandaloneHandler’ was set and returned ‘0’.

 -- Data: xml.parsers.expat.errors.XML_ERROR_UNEXPECTED_STATE

 -- Data: xml.parsers.expat.errors.XML_ERROR_ENTITY_DECLARED_IN_PE

 -- Data: xml.parsers.expat.errors.XML_ERROR_FEATURE_REQUIRES_XML_DTD

     An operation was requested that requires DTD support to be compiled
     in, but Expat was configured without DTD support.  This should
     never be reported by a standard build of the *note
     xml.parsers.expat: 135. module.

 -- Data:
          xml.parsers.expat.errors.XML_ERROR_CANT_CHANGE_FEATURE_ONCE_PARSING

     A behavioral change was requested after parsing started that can
     only be changed before parsing has started.  This is (currently)
     only raised by ‘UseForeignDTD()’.

 -- Data: xml.parsers.expat.errors.XML_ERROR_UNBOUND_PREFIX

     An undeclared prefix was found when namespace processing was
     enabled.

 -- Data: xml.parsers.expat.errors.XML_ERROR_UNDECLARING_PREFIX

     The document attempted to remove the namespace declaration
     associated with a prefix.

 -- Data: xml.parsers.expat.errors.XML_ERROR_INCOMPLETE_PE

     A parameter entity contained incomplete markup.

 -- Data: xml.parsers.expat.errors.XML_ERROR_XML_DECL

     The document contained no document element at all.

 -- Data: xml.parsers.expat.errors.XML_ERROR_TEXT_DECL

     There was an error parsing a text declaration in an external
     entity.

 -- Data: xml.parsers.expat.errors.XML_ERROR_PUBLICID

     Characters were found in the public id that are not allowed.

 -- Data: xml.parsers.expat.errors.XML_ERROR_SUSPENDED

     The requested operation was made on a suspended parser, but isn’t
     allowed.  This includes attempts to provide additional input or to
     stop the parser.

 -- Data: xml.parsers.expat.errors.XML_ERROR_NOT_SUSPENDED

     An attempt to resume the parser was made when the parser had not
     been suspended.

 -- Data: xml.parsers.expat.errors.XML_ERROR_ABORTED

     This should not be reported to Python applications.

 -- Data: xml.parsers.expat.errors.XML_ERROR_FINISHED

     The requested operation was made on a parser which was finished
     parsing input, but isn’t allowed.  This includes attempts to
     provide additional input or to stop the parser.

 -- Data: xml.parsers.expat.errors.XML_ERROR_SUSPEND_PE


File: python.info,  Node: Internet Protocols and Support,  Next: Multimedia Services,  Prev: Structured Markup Processing Tools,  Up: The Python Standard Library

5.21 Internet Protocols and Support
===================================

The modules described in this chapter implement Internet protocols and
support for related technology.  They are all implemented in Python.
Most of these modules require the presence of the system-dependent
module *note socket: ed, which is currently supported on most popular
platforms.  Here is an overview:

* Menu:

* webbrowser: webbrowser --- Convenient Web-browser controller. Convenient Web-browser controller
* cgi: cgi --- Common Gateway Interface support. Common Gateway Interface support
* cgitb: cgitb --- Traceback manager for CGI scripts. Traceback manager for CGI scripts
* wsgiref: wsgiref --- WSGI Utilities and Reference Implementation. WSGI Utilities and Reference Implementation
* urllib: urllib --- URL handling modules. URL handling modules
* urllib.request: urllib request --- Extensible library for opening URLs. Extensible library for opening URLs
* urllib.response: urllib response --- Response classes used by urllib. Response classes used by urllib
* urllib.parse: urllib parse --- Parse URLs into components. Parse URLs into components
* urllib.error: urllib error --- Exception classes raised by urllib request. Exception classes raised by urllib.request
* urllib.robotparser: urllib robotparser --- Parser for robots txt. Parser for robots.txt
* http: http --- HTTP modules. HTTP modules
* http.client: http client --- HTTP protocol client. HTTP protocol client
* ftplib: ftplib --- FTP protocol client. FTP protocol client
* poplib: poplib --- POP3 protocol client. POP3 protocol client
* imaplib: imaplib --- IMAP4 protocol client. IMAP4 protocol client
* nntplib: nntplib --- NNTP protocol client. NNTP protocol client
* smtplib: smtplib --- SMTP protocol client. SMTP protocol client
* smtpd: smtpd --- SMTP Server. SMTP Server
* telnetlib: telnetlib --- Telnet client. Telnet client
* uuid: uuid --- UUID objects according to RFC 4122. UUID objects according to RFC 4122
* socketserver: socketserver --- A framework for network servers. A framework for network servers
* http.server: http server --- HTTP servers. HTTP servers
* http.cookies: http cookies --- HTTP state management. HTTP state management
* http.cookiejar: http cookiejar --- Cookie handling for HTTP clients. Cookie handling for HTTP clients
* xmlrpc: xmlrpc --- XMLRPC server and client modules. XMLRPC server and client modules
* xmlrpc.client: xmlrpc client --- XML-RPC client access. XML-RPC client access
* xmlrpc.server: xmlrpc server --- Basic XML-RPC servers. Basic XML-RPC servers
* ipaddress: ipaddress --- IPv4/IPv6 manipulation library. IPv4/IPv6 manipulation library


File: python.info,  Node: webbrowser --- Convenient Web-browser controller,  Next: cgi --- Common Gateway Interface support,  Up: Internet Protocols and Support

5.21.1 ‘webbrowser’ — Convenient Web-browser controller
-------------------------------------------------------

`Source code:' Lib/webbrowser.py(1)

__________________________________________________________________

The *note webbrowser: 126. module provides a high-level interface to
allow displaying Web-based documents to users.  Under most
circumstances, simply calling the *note open(): 247b. function from this
module will do the right thing.

Under Unix, graphical browsers are preferred under X11, but text-mode
browsers will be used if graphical browsers are not available or an X11
display isn’t available.  If text-mode browsers are used, the calling
process will block until the user exits the browser.

If the environment variable ‘BROWSER’ exists, it is interpreted as the
*note os.pathsep: d15.-separated list of browsers to try ahead of the
platform defaults.  When the value of a list part contains the string
‘%s’, then it is interpreted as a literal browser command line to be
used with the argument URL substituted for ‘%s’; if the part does not
contain ‘%s’, it is simply interpreted as the name of the browser to
launch.  (2)

For non-Unix platforms, or when a remote browser is available on Unix,
the controlling process will not wait for the user to finish with the
browser, but allow the remote browser to maintain its own windows on the
display.  If remote browsers are not available on Unix, the controlling
process will launch a new browser and wait.

The script ‘webbrowser’ can be used as a command-line interface for the
module.  It accepts a URL as the argument.  It accepts the following
optional parameters: ‘-n’ opens the URL in a new browser window, if
possible; ‘-t’ opens the URL in a new browser page ("tab").  The options
are, naturally, mutually exclusive.  Usage example:

     python -m webbrowser -t "http://www.python.org"

The following exception is defined:

 -- Exception: webbrowser.Error

     Exception raised when a browser control error occurs.

The following functions are defined:

 -- Function: webbrowser.open (url, new=0, autoraise=True)

     Display `url' using the default browser.  If `new' is 0, the `url'
     is opened in the same browser window if possible.  If `new' is 1, a
     new browser window is opened if possible.  If `new' is 2, a new
     browser page ("tab") is opened if possible.  If `autoraise' is
     ‘True’, the window is raised if possible (note that under many
     window managers this will occur regardless of the setting of this
     variable).

     Note that on some platforms, trying to open a filename using this
     function, may work and start the operating system’s associated
     program.  However, this is neither supported nor portable.

 -- Function: webbrowser.open_new (url)

     Open `url' in a new window of the default browser, if possible,
     otherwise, open `url' in the only browser window.

 -- Function: webbrowser.open_new_tab (url)

     Open `url' in a new page ("tab") of the default browser, if
     possible, otherwise equivalent to *note open_new(): 247d.

 -- Function: webbrowser.get (using=None)

     Return a controller object for the browser type `using'.  If
     `using' is ‘None’, return a controller for a default browser
     appropriate to the caller’s environment.

 -- Function: webbrowser.register (name, constructor, instance=None)

     Register the browser type `name'.  Once a browser type is
     registered, the *note get(): 247f. function can return a controller
     for that browser type.  If `instance' is not provided, or is
     ‘None’, `constructor' will be called without parameters to create
     an instance when needed.  If `instance' is provided, `constructor'
     will never be called, and may be ‘None’.

     This entry point is only useful if you plan to either set the
     ‘BROWSER’ variable or call *note get(): 247f. with a nonempty
     argument matching the name of a handler you declare.

A number of browser types are predefined.  This table gives the type
names that may be passed to the *note get(): 247f. function and the
corresponding instantiations for the controller classes, all defined in
this module.

Type Name                    Class Name                                    Notes
                                                                           
---------------------------------------------------------------------------------------
                                                                           
‘'mozilla'’                  ‘Mozilla('mozilla')’
                             
                                                                           
‘'firefox'’                  ‘Mozilla('mozilla')’
                             
                                                                           
‘'netscape'’                 ‘Mozilla('netscape')’
                             
                                                                           
‘'galeon'’                   ‘Galeon('galeon')’
                             
                                                                           
‘'epiphany'’                 ‘Galeon('epiphany')’
                             
                                                                           
‘'skipstone'’                ‘BackgroundBrowser('skipstone')’
                             
                                                                           
‘'kfmclient'’                ‘Konqueror()’                                 (1)
                                                                           
                                                                           
‘'konqueror'’                ‘Konqueror()’                                 (1)
                                                                           
                                                                           
‘'kfm'’                      ‘Konqueror()’                                 (1)
                                                                           
                                                                           
‘'mosaic'’                   ‘BackgroundBrowser('mosaic')’
                             
                                                                           
‘'opera'’                    ‘Opera()’
                             
                                                                           
‘'grail'’                    ‘Grail()’
                             
                                                                           
‘'links'’                    ‘GenericBrowser('links')’
                             
                                                                           
‘'elinks'’                   ‘Elinks('elinks')’
                             
                                                                           
‘'lynx'’                     ‘GenericBrowser('lynx')’
                             
                                                                           
‘'w3m'’                      ‘GenericBrowser('w3m')’
                             
                                                                           
‘'windows-default'’          ‘WindowsDefault’                              (2)
                                                                           
                                                                           
‘'macosx'’                   ‘MacOSX('default')’                           (3)
                                                                           
                                                                           
‘'safari'’                   ‘MacOSX('safari')’                            (3)
                                                                           
                                                                           
‘'google-chrome'’            ‘Chrome('google-chrome')’
                             
                                                                           
‘'chrome'’                   ‘Chrome('chrome')’
                             
                                                                           
‘'chromium'’                 ‘Chromium('chromium')’
                             
                                                                           
‘'chromium-browser'’         ‘Chromium('chromium-browser')’
                             

Notes:

  1. "Konqueror" is the file manager for the KDE desktop environment for
     Unix, and only makes sense to use if KDE is running.  Some way of
     reliably detecting KDE would be nice; the ‘KDEDIR’ variable is not
     sufficient.  Note also that the name "kfm" is used even when using
     the ‘konqueror’ command with KDE 2 — the implementation selects the
     best strategy for running Konqueror.

  2. Only on Windows platforms.

  3. Only on Mac OS X platform.

New in version 3.3: Support for Chrome/Chromium has been added.

Here are some simple examples:

     url = 'http://docs.python.org/'

     # Open URL in a new tab, if a browser window is already open.
     webbrowser.open_new_tab(url)

     # Open URL in new window, raising the window if possible.
     webbrowser.open_new(url)

* Menu:

* Browser Controller Objects:: 

   ---------- Footnotes ----------

   (1) https://hg.python.org/cpython/file/default/Lib/webbrowser.py

   (2) Executables named here without a full path will be searched in
the directories given in the ‘PATH’ environment variable.


File: python.info,  Node: Browser Controller Objects,  Up: webbrowser --- Convenient Web-browser controller

5.21.1.1 Browser Controller Objects
...................................

Browser controllers provide these methods which parallel three of the
module-level convenience functions:

 -- Method: controller.open (url, new=0, autoraise=True)

     Display `url' using the browser handled by this controller.  If
     `new' is 1, a new browser window is opened if possible.  If `new'
     is 2, a new browser page ("tab") is opened if possible.

 -- Method: controller.open_new (url)

     Open `url' in a new window of the browser handled by this
     controller, if possible, otherwise, open `url' in the only browser
     window.  Alias *note open_new(): 247d.

 -- Method: controller.open_new_tab (url)

     Open `url' in a new page ("tab") of the browser handled by this
     controller, if possible, otherwise equivalent to *note open_new():
     247d.


File: python.info,  Node: cgi --- Common Gateway Interface support,  Next: cgitb --- Traceback manager for CGI scripts,  Prev: webbrowser --- Convenient Web-browser controller,  Up: Internet Protocols and Support

5.21.2 ‘cgi’ — Common Gateway Interface support
-----------------------------------------------

`Source code:' Lib/cgi.py(1)

__________________________________________________________________

Support module for Common Gateway Interface (CGI) scripts.

This module defines a number of utilities for use by CGI scripts written
in Python.

* Menu:

* Introduction: Introduction<10>. 
* Using the cgi module:: 
* Higher Level Interface:: 
* Functions: Functions<6>. 
* Caring about security:: 
* Installing your CGI script on a Unix system:: 
* Testing your CGI script:: 
* Debugging CGI scripts:: 
* Common problems and solutions:: 

   ---------- Footnotes ----------

   (1) https://hg.python.org/cpython/file/default/Lib/cgi.py


File: python.info,  Node: Introduction<10>,  Next: Using the cgi module,  Up: cgi --- Common Gateway Interface support

5.21.2.1 Introduction
.....................

A CGI script is invoked by an HTTP server, usually to process user input
submitted through an HTML ‘<FORM>’ or ‘<ISINDEX>’ element.

Most often, CGI scripts live in the server’s special ‘cgi-bin’
directory.  The HTTP server places all sorts of information about the
request (such as the client’s hostname, the requested URL, the query
string, and lots of other goodies) in the script’s shell environment,
executes the script, and sends the script’s output back to the client.

The script’s input is connected to the client too, and sometimes the
form data is read this way; at other times the form data is passed via
the "query string" part of the URL. This module is intended to take care
of the different cases and provide a simpler interface to the Python
script.  It also provides a number of utilities that help in debugging
scripts, and the latest addition is support for file uploads from a form
(if your browser supports it).

The output of a CGI script should consist of two sections, separated by
a blank line.  The first section contains a number of headers, telling
the client what kind of data is following.  Python code to generate a
minimal header section looks like this:

     print("Content-Type: text/html")    # HTML is following
     print()                             # blank line, end of headers

The second section is usually HTML, which allows the client software to
display nicely formatted text with header, in-line images, etc.  Here’s
Python code that prints a simple piece of HTML:

     print("<TITLE>CGI script output</TITLE>")
     print("<H1>This is my first CGI script</H1>")
     print("Hello, world!")


File: python.info,  Node: Using the cgi module,  Next: Higher Level Interface,  Prev: Introduction<10>,  Up: cgi --- Common Gateway Interface support

5.21.2.2 Using the cgi module
.............................

Begin by writing ‘import cgi’.

When you write a new script, consider adding these lines:

     import cgitb
     cgitb.enable()

This activates a special exception handler that will display detailed
reports in the Web browser if any errors occur.  If you’d rather not
show the guts of your program to users of your script, you can have the
reports saved to files instead, with code like this:

     import cgitb
     cgitb.enable(display=0, logdir="/path/to/logdir")

It’s very helpful to use this feature during script development.  The
reports produced by *note cgitb: 17. provide information that can save
you a lot of time in tracking down bugs.  You can always remove the
‘cgitb’ line later when you have tested your script and are confident
that it works correctly.

To get at submitted form data, use the ‘FieldStorage’ class.  If the
form contains non-ASCII characters, use the `encoding' keyword parameter
set to the value of the encoding defined for the document.  It is
usually contained in the META tag in the HEAD section of the HTML
document or by the ‘Content-Type’ header).  This reads the form contents
from the standard input or the environment (depending on the value of
various environment variables set according to the CGI standard).  Since
it may consume standard input, it should be instantiated only once.

The ‘FieldStorage’ instance can be indexed like a Python dictionary.  It
allows membership testing with the *note in: 37d. operator, and also
supports the standard dictionary method *note keys(): 88f. and the
built-in function *note len(): 5a8.  Form fields containing empty
strings are ignored and do not appear in the dictionary; to keep such
values, provide a true value for the optional `keep_blank_values'
keyword parameter when creating the ‘FieldStorage’ instance.

For instance, the following code (which assumes that the ‘Content-Type’
header and blank line have already been printed) checks that the fields
‘name’ and ‘addr’ are both set to a non-empty string:

     form = cgi.FieldStorage()
     if "name" not in form or "addr" not in form:
         print("<H1>Error</H1>")
         print("Please fill in the name and addr fields.")
         return
     print("<p>name:", form["name"].value)
     print("<p>addr:", form["addr"].value)
     ...further form processing here...

Here the fields, accessed through ‘form[key]’, are themselves instances
of ‘FieldStorage’ (or ‘MiniFieldStorage’, depending on the form
encoding).  The ‘value’ attribute of the instance yields the string
value of the field.  The ‘getvalue()’ method returns this string value
directly; it also accepts an optional second argument as a default to
return if the requested key is not present.

If the submitted form data contains more than one field with the same
name, the object retrieved by ‘form[key]’ is not a ‘FieldStorage’ or
‘MiniFieldStorage’ instance but a list of such instances.  Similarly, in
this situation, ‘form.getvalue(key)’ would return a list of strings.  If
you expect this possibility (when your HTML form contains multiple
fields with the same name), use the *note getlist(): 248c. method, which
always returns a list of values (so that you do not need to special-case
the single item case).  For example, this code concatenates any number
of username fields, separated by commas:

     value = form.getlist("username")
     usernames = ",".join(value)

If a field represents an uploaded file, accessing the value via the
‘value’ attribute or the ‘getvalue()’ method reads the entire file in
memory as bytes.  This may not be what you want.  You can test for an
uploaded file by testing either the ‘filename’ attribute or the ‘file’
attribute.  You can then read the data from the ‘file’ attribute before
it is automatically closed as part of the garbage collection of the
‘FieldStorage’ instance (the *note read(): 2b9. and *note readline():
10b8. methods will return bytes):

     fileitem = form["userfile"]
     if fileitem.file:
         # It's an uploaded file; count lines
         linecount = 0
         while True:
             line = fileitem.file.readline()
             if not line: break
             linecount = linecount + 1

‘FieldStorage’ objects also support being used in a *note with: 29d.
statement, which will automatically close them when done.

If an error is encountered when obtaining the contents of an uploaded
file (for example, when the user interrupts the form submission by
clicking on a Back or Cancel button) the ‘done’ attribute of the object
for the field will be set to the value -1.

The file upload draft standard entertains the possibility of uploading
multiple files from one field (using a recursive ‘multipart/*’
encoding).  When this occurs, the item will be a dictionary-like
‘FieldStorage’ item.  This can be determined by testing its ‘type’
attribute, which should be ‘multipart/form-data’ (or perhaps another
MIME type matching ‘multipart/*’).  In this case, it can be iterated
over recursively just like the top-level form object.

When a form is submitted in the "old" format (as the query string or as
a single data part of type ‘application/x-www-form-urlencoded’), the
items will actually be instances of the class ‘MiniFieldStorage’.  In
this case, the ‘list’, ‘file’, and ‘filename’ attributes are always
‘None’.

A form submitted via POST that also has a query string will contain both
‘FieldStorage’ and ‘MiniFieldStorage’ items.

Changed in version 3.4: The ‘file’ attribute is automatically closed
upon the garbage collection of the creating ‘FieldStorage’ instance.

Changed in version 3.5: Added support for the context management
protocol to the ‘FieldStorage’ class.


File: python.info,  Node: Higher Level Interface,  Next: Functions<6>,  Prev: Using the cgi module,  Up: cgi --- Common Gateway Interface support

5.21.2.3 Higher Level Interface
...............................

The previous section explains how to read CGI form data using the
‘FieldStorage’ class.  This section describes a higher level interface
which was added to this class to allow one to do it in a more readable
and intuitive way.  The interface doesn’t make the techniques described
in previous sections obsolete — they are still useful to process file
uploads efficiently, for example.

The interface consists of two simple methods.  Using the methods you can
process form data in a generic way, without the need to worry whether
only one or more values were posted under one name.

In the previous section, you learned to write following code anytime you
expected a user to post more than one value under one name:

     item = form.getvalue("item")
     if isinstance(item, list):
         # The user is requesting more than one item.
     else:
         # The user is requesting only one item.

This situation is common for example when a form contains a group of
multiple checkboxes with the same name:

     <input type="checkbox" name="item" value="1" />
     <input type="checkbox" name="item" value="2" />

In most situations, however, there’s only one form control with a
particular name in a form and then you expect and need only one value
associated with this name.  So you write a script containing for example
this code:

     user = form.getvalue("user").upper()

The problem with the code is that you should never expect that a client
will provide valid input to your scripts.  For example, if a curious
user appends another ‘user=foo’ pair to the query string, then the
script would crash, because in this situation the ‘getvalue("user")’
method call returns a list instead of a string.  Calling the *note
upper(): 1016. method on a list is not valid (since lists do not have a
method of this name) and results in an *note AttributeError: 356.
exception.

Therefore, the appropriate way to read form data values was to always
use the code which checks whether the obtained value is a single value
or a list of values.  That’s annoying and leads to less readable
scripts.

A more convenient approach is to use the methods *note getfirst(): 248e.
and *note getlist(): 248c. provided by this higher level interface.

 -- Method: FieldStorage.getfirst (name, default=None)

     This method always returns only one value associated with form
     field `name'.  The method returns only the first value in case that
     more values were posted under such name.  Please note that the
     order in which the values are received may vary from browser to
     browser and should not be counted on.  (1) If no such form field or
     value exists then the method returns the value specified by the
     optional parameter `default'.  This parameter defaults to ‘None’ if
     not specified.

 -- Method: FieldStorage.getlist (name)

     This method always returns a list of values associated with form
     field `name'.  The method returns an empty list if no such form
     field or value exists for `name'.  It returns a list consisting of
     one item if only one such value exists.

Using these methods you can write nice compact code:

     import cgi
     form = cgi.FieldStorage()
     user = form.getfirst("user", "").upper()    # This way it's safe.
     for item in form.getlist("item"):
         do_something(item)

   ---------- Footnotes ----------

   (1) Note that some recent versions of the HTML specification do state
what order the field values should be supplied in, but knowing whether a
request was received from a conforming browser, or even from a browser
at all, is tedious and error-prone.

